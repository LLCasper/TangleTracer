#include "Orthographic.h"
#include "MultipleObjects.h"
#include "SingleSphere.h"
#include "Plane.h"
#include "World.h"
#include "RayCast.h"
#include "Matte.h"
#include "Directional.h"
#include "PointLight.h"
#include "StereoCamera.h"
#include "Phong.h"
#include "AmbientOccluder.h"
#include "AreaLight.h"
#include "AreaLighting.h"
#include "EnvironmentLight.h"
#include "Emissive.h"
#include "ConcaveSphere.h"
#include "Hammersley.h"
#include "Instance.h"
#include "Triangle.h"
#include "SolidCylinder.h"
#include "Torus.h"
#include "Box.h"
#include "BeveledCylinder.h"
#include "Grid.h"
#include "Reflective.h"
#include "Whitted.h"
#include "Rectangle.h"
#include "GlossyReflector.h"
#include "PathTrace.h"
#include "GlobalTrace.h"
#include "Transparent.h"
#include "Dielectric.h"
#include "Image.h"
#include "CylindericalMap.h"
#include "SV_Matte.h"
#include "ImageTexture.h"
#include "OpenCylinder.h"
#include "SphericalMap.h"
#include "FishEye.h"
#include "LightProbeMap.h"
#include "Checker3D.h"
#include "PlaneChecker.h"
#include "SphereChecker.h"
#include "TInstance.h"
#include "CubicNoise.h"
#include "RampFBmTexture.h"
#include "WrappedTwoColors.h"
#include "FBmTexture.h"
#include "WrappedFBmTexture.h"
#include "SV_Phong.h"
#include "ConstantColor.h"
#include "Jittered.h"
#include "ThinLens.h"
#include "WireframeBox.h"
#include "Spherical.h"
#include "PureRandom.h"
#include "ConvexPartCylinder.h"
#include "OpenPartCylinder.h"
#include "ConcaveHemisphere.h"
#include "JitteredDirectional.h"
#include "FakeSphericalLight.h"
#include "FirstHit.h"
#include "OpenCone.h"
#include "ConeChecker.h"
#include "FlatRimmedBowl.h"
#include "RoundRimmedBowl.h"
#include "ThickRing.h"
#include "BeveledBox.h"
#include "BeveledRing.h"
#include "Annulus.h"
#include "SV_Emissive.h"
#include "SphereMaterials.h"
#include "SolidCone.h"
#include "SV_GlossyReflector.h"
#include "ConcavePartCylinder.h"
#include "BeveledBoxShell.h"
#include "ConcaveLens.h"
#include "ConvexOpenCylinder.h"
#include "ConvexPartSphere.h"
#include "GlassOfWater.h"
#include "FishBowl.h"
#include "ConcavePartSphere.h"
#include "CutFace.h"
#include "RectangularMap.h"
#include "CylindericalMap.h"
#include "HemisphericalMap.h"
#include "ProductJar.h"
#include "CutCube.h"
#include "Wood.h"
#include "CylinderChecker.h"
#include "DiskChecker.h"
#include "RectangleChecker.h"
#include "TurbulenceTexture.h"
#include "SphereTextures.h"
#include "WrappedThreeColors.h"
#include "NestedNoisesTexture.h"
#include "WrappedRamp.h"
#include "BeveledWedge.h"
#include "Rosette.h"
#include "Archway.h"
#include "SV_Reflector.h"

#define RGBColour RGBColor

QString ppmfile = ".\\TextureFiles\\ppm\\";
QString plyfile = ".\\PLYFiles\\";

//Here we need a function to confirm whether the files are already in the specific direction
bool CheckFile(const char* filename)
{
	FILE* file = NULL;
	file = fopen(filename,"r");
	if(file)
	{
		fclose(file);
		return true;
	}
	else
	{
		::MessageBoxA(NULL,"Cannot find related resource files, Check your work direction.","Warnning",MB_OK);
		return false;
	}
}

void							
World::build(int no) {
	switch(no)
	{
	case 0:
		{
			//3p1
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_pixel_size(0.5);
	
			background_color = black;
			tracer_ptr = new MultipleObjects(this);  
	
			// colours
			RGBColor yellow(1, 1, 0);										// yellow
			RGBColor brown(0.71, 0.40, 0.16);								// brown
			RGBColor dark_green(0.0, 0.41, 0.41);							// dark_green
			RGBColor orange(1.0, 0.75, 0.0);								// orange
			RGBColor green(0.0, 0.6, 0.3);									// green
			RGBColor light_green(0.65, 1.0, 0.30);							// light green
			RGBColor dark_yellow(0.61, 0.61, 0.0);							// dark yellow
			RGBColor light_purple(0.65, 0.3, 1.0);							// light purple
			RGBColor dark_purple(0.5, 0.0, 1.0);							// dark purple
	
			// spheres
				
			Sphere*	sphere_ptr1 = new Sphere(Point3D(5, 3, 0), 30); 
			sphere_ptr1->set_color(yellow);	   								// yellow
			add_object(sphere_ptr1);
	
			Sphere*	sphere_ptr2 = new Sphere(Point3D(45, -7, -60), 20); 
			sphere_ptr2->set_color(brown);									// brown
			add_object(sphere_ptr2);
		
			Sphere*	sphere_ptr3 = new Sphere(Point3D(40, 43, -100), 17); 
			sphere_ptr3->set_color(dark_green);								// dark green
			add_object(sphere_ptr3);
	
			Sphere*	sphere_ptr4 = new Sphere(Point3D(-20, 28, -15), 20); 
			sphere_ptr4->set_color(orange);									// orange
			add_object(sphere_ptr4);
	
			Sphere*	sphere_ptr5 = new Sphere(Point3D(-25, -7, -35), 27); 			
			sphere_ptr5->set_color(green);									// green
			add_object(sphere_ptr5);
	
			Sphere*	sphere_ptr6 = new Sphere(Point3D(20, -27, -35), 25); 
			sphere_ptr6->set_color(light_green);							// light green
			add_object(sphere_ptr6);
	
			Sphere*	sphere_ptr7 = new Sphere(Point3D(35, 18, -35), 22); 
			sphere_ptr7->set_color(green);   								// green
			add_object(sphere_ptr7);
	
			Sphere*	sphere_ptr8 = new Sphere(Point3D(-57, -17, -50), 15);  
			sphere_ptr8->set_color(brown);									// brown
			add_object(sphere_ptr8);
	
			Sphere*	sphere_ptr9 = new Sphere(Point3D(-47, 16, -80), 23); 
			sphere_ptr9->set_color(light_green);							// light green
			add_object(sphere_ptr9);
		
			Sphere*	sphere_ptr10 = new Sphere(Point3D(-15, -32, -60), 22); 
			sphere_ptr10->set_color(dark_green);     						// dark green
			add_object(sphere_ptr10);
	
			Sphere*	sphere_ptr11 = new Sphere(Point3D(-35, -37, -80), 22); 
			sphere_ptr11->set_color(dark_yellow);							// dark yellow
			add_object(sphere_ptr11);
	
			Sphere*	sphere_ptr12 = new Sphere(Point3D(10, 43, -80), 22); 
			sphere_ptr12->set_color(dark_yellow);							// dark yellow
			add_object(sphere_ptr12);
			
			Sphere*	sphere_ptr13 = new Sphere(Point3D(30, -7, -80), 10); 
			sphere_ptr13->set_color(dark_yellow);
			add_object(sphere_ptr13);										// dark yellow (hidden)
		
			Sphere*	sphere_ptr14 = new Sphere(Point3D(-40, 48, -110), 18); 
			sphere_ptr14->set_color(dark_green); 							// dark green
			add_object(sphere_ptr14);
		
			Sphere*	sphere_ptr15 = new Sphere(Point3D(-10, 53, -120), 18); 
			sphere_ptr15->set_color(brown); 								// brown
			add_object(sphere_ptr15);
	
			Sphere*	sphere_ptr16 = new Sphere(Point3D(-55, -52, -100), 10); 
			sphere_ptr16->set_color(light_purple);							// light purple
			add_object(sphere_ptr16);
	
			Sphere*	sphere_ptr17 = new Sphere(Point3D(5, -52, -100), 15); 		
			sphere_ptr17->set_color(brown);									// browm
			add_object(sphere_ptr17);
	
			Sphere*	sphere_ptr18 = new Sphere(Point3D(-20, -57, -120), 15); 
			sphere_ptr18->set_color(dark_purple);							// dark purple
			add_object(sphere_ptr18);
	
			Sphere*	sphere_ptr19 = new Sphere(Point3D(55, -27, -100), 17); 
			sphere_ptr19->set_color(dark_green);							// dark green
			add_object(sphere_ptr19);

			Sphere*	sphere_ptr20 = new Sphere(Point3D(50, -47, -120), 15); 
			sphere_ptr20->set_color(brown);									// browm
			add_object(sphere_ptr20);
	 	
			Sphere*	sphere_ptr21 = new Sphere(Point3D(70, -42, -150), 10); 
			sphere_ptr21->set_color(light_purple);							// light purple
			add_object(sphere_ptr21);
	
			Sphere*	sphere_ptr22 = new Sphere(Point3D(5, 73, -130), 12); 
			sphere_ptr22->set_color(light_purple);							// light purple
			add_object(sphere_ptr22);
	
			Sphere*	sphere_ptr23 = new Sphere(Point3D(66, 21, -130), 13); 			
			sphere_ptr23->set_color(dark_purple);							// dark purple
			add_object(sphere_ptr23);	
	  
			Sphere*	sphere_ptr24 = new Sphere(Point3D(72, -12, -140), 12); 
			sphere_ptr24->set_color(light_purple);							// light purple
			add_object(sphere_ptr24);
	
			Sphere*	sphere_ptr25 = new Sphere(Point3D(64, 5, -160), 11); 			
			sphere_ptr25->set_color(green);					 				// green
			add_object(sphere_ptr25);
	  
			Sphere*	sphere_ptr26 = new Sphere(Point3D(55, 38, -160), 12); 		
			sphere_ptr26->set_color(light_purple);							// light purple
			add_object(sphere_ptr26);
	
			Sphere*	sphere_ptr27 = new Sphere(Point3D(-73, -2, -160), 12); 		
			sphere_ptr27->set_color(light_purple);							// light purple
			add_object(sphere_ptr27);
	 
			Sphere*	sphere_ptr28 = new Sphere(Point3D(30, -62, -140), 15); 
			sphere_ptr28->set_color(dark_purple); 							// dark purple
			add_object(sphere_ptr28);
	
			Sphere*	sphere_ptr29 = new Sphere(Point3D(25, 63, -140), 15); 
			sphere_ptr29->set_color(dark_purple);							// dark purple
			add_object(sphere_ptr29);
	
			Sphere*	sphere_ptr30 = new Sphere(Point3D(-60, 46, -140), 15);  
			sphere_ptr30->set_color(dark_purple); 							// dark purple
			add_object(sphere_ptr30);
	
			Sphere*	sphere_ptr31 = new Sphere(Point3D(-30, 68, -130), 12); 
			sphere_ptr31->set_color(light_purple); 							// light purple
			add_object(sphere_ptr31);
	
			Sphere*	sphere_ptr32 = new Sphere(Point3D(58, 56, -180), 11);   
			sphere_ptr32->set_color(green);									//  green
			add_object(sphere_ptr32);
	
			Sphere*	sphere_ptr33 = new Sphere(Point3D(-63, -39, -180), 11); 
			sphere_ptr33->set_color(green);									// green 
			add_object(sphere_ptr33);
	
			Sphere*	sphere_ptr34 = new Sphere(Point3D(46, 68, -200), 10); 	
			sphere_ptr34->set_color(light_purple);							// light purple
			add_object(sphere_ptr34);
	
			Sphere*	sphere_ptr35 = new Sphere(Point3D(-3, -72, -130), 12); 
			sphere_ptr35->set_color(light_purple);							// light purple
			add_object(sphere_ptr35);

			break;
		}
	case 1:
		{
			//3.18
			vp.set_hres(200);
			vp.set_vres(200);
			vp.set_pixel_size(1.0);

			background_color = black;
			tracer_ptr = new SingleSphere(this);

			sphere.set_center(0.0);
			sphere.set_radius(85.0);
			break;
		}
	case 2:
		{
			//3.20a
			vp.set_hres(200);
			vp.set_vres(200);
	
			background_color = black;
			tracer_ptr = new MultipleObjects(this);
	
			// use access functions to set center and radius for this sphere
	
			Sphere* sphere_ptr = new Sphere;
			sphere_ptr->set_center(0, -25, 0);
			sphere_ptr->set_radius(80.0);
			sphere_ptr->set_color(1, 0, 0);  // red
			add_object(sphere_ptr);

			// use a constructor to set center and radius for this sphere
	
			sphere_ptr = new Sphere(Point3D(0, 30, 0), 60);
			sphere_ptr->set_color(1, 1, 0);	// yellow
			add_object(sphere_ptr);
	
	
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 1));
			plane_ptr->set_color(0.0, 0.25, 0.0);	// dark green 
			add_object(plane_ptr);
		break;
		}
	case 3:
		{
			//4.04a
			int num_samples = 1;  // use 1 for 4.4(a) and 16 for 4.4(b)
	
			Regular* uniform_ptr = new Regular(num_samples);
	
			vp.set_hres(32);
			vp.set_vres(32);
			vp.set_pixel_size(1);
			vp.set_sampler(uniform_ptr);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Orthographic* orthographic_ptr = new Orthographic;
			orthographic_ptr->set_eye(0, 0, 100);
			orthographic_ptr->set_lookat(0.0);
			set_camera(orthographic_ptr);
	
			ambient_ptr = new Ambient;
		
			PointLight* light_ptr = new PointLight();
			light_ptr->set_location(100, 100, 200);
			light_ptr->scale_radiance(2.0);
			add_light(light_ptr);

			Matte* matte_ptr = new Matte;
			matte_ptr->set_ka(0.2);
			matte_ptr->set_kd(0.8);
			matte_ptr->set_cd(1, 1, 0);				// yellow	
	
			Sphere*	sphere_ptr = new Sphere(Point3D(0.0), 13.0); 
			sphere_ptr->set_material(matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 4:
		{
			//4.04b
			int num_samples = 16;  // use 1 for 4.4(a) and 16 for 4.4(b)
	
			Regular* uniform_ptr = new Regular(num_samples);
	
			vp.set_hres(32);
			vp.set_vres(32);
			vp.set_pixel_size(1);
			vp.set_sampler(uniform_ptr);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Orthographic* orthographic_ptr = new Orthographic;
			orthographic_ptr->set_eye(0, 0, 100);
			orthographic_ptr->set_lookat(0.0);
			set_camera(orthographic_ptr);
	
			ambient_ptr = new Ambient;
		
			PointLight* light_ptr = new PointLight();
			light_ptr->set_location(100, 100, 200);
			light_ptr->scale_radiance(2.0);
			add_light(light_ptr);

			Matte* matte_ptr = new Matte;
			matte_ptr->set_ka(0.2);
			matte_ptr->set_kd(0.8);
			matte_ptr->set_cd(1, 1, 0);				// yellow	
	
			Sphere*	sphere_ptr = new Sphere(Point3D(0.0), 13.0); 
			sphere_ptr->set_material(matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 5:
		{
			//4.08a
			int num_samples = 1;  // use 1 for 4.8(a), 64 for 4.8(b)
	
			Jittered* sampler_ptr = new Jittered(num_samples);
	
			vp.set_hres(300);
			vp.set_vres(200);
			vp.set_samples(num_samples);		// for 4.8(a) (one regular sample per pixel)
		//	vp.set_sampler(sampler_ptr);		// for 4.8(b)	
			vp.set_max_depth(0);
	
			background_color = RGBColor(0.25);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(1.0);
			set_ambient_light(ambient_ptr);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 500, 100);   
			pinhole_ptr->set_lookat(0, 450, 0);    
			pinhole_ptr->set_view_distance(175);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(0, 1, 0); 
			light_ptr3->scale_radiance(4.0);
			light_ptr3->set_shadows(false);
			add_light(light_ptr3);
		
	
			// plane
		
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(250.0);
			checker3D_ptr->set_color1(black);  	
			checker3D_ptr->set_color2(white); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker3D_ptr);	
	
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0.0, 1.0, 0.0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 6:
		{
			//4.08b
			int num_samples = 64;  // use 1 for 4.8(a), 64 for 4.8(b)
	
			Jittered* sampler_ptr = new Jittered(num_samples);
	
			vp.set_hres(300);
			vp.set_vres(200);
		//	vp.set_samples(num_samples);		// for 4.8(a) (one regular sample per pixel)
			vp.set_sampler(sampler_ptr);		// for 4.8(b)	
			vp.set_max_depth(0);
	
			background_color = RGBColor(0.25);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(1.0);
			set_ambient_light(ambient_ptr);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 500, 100);   
			pinhole_ptr->set_lookat(0, 450, 0);    
			pinhole_ptr->set_view_distance(175);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(0, 1, 0); 
			light_ptr3->scale_radiance(4.0);
			light_ptr3->set_shadows(false);
			add_light(light_ptr3);
		
	
			// plane
		
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(250.0);
			checker3D_ptr->set_color1(black);  	
			checker3D_ptr->set_color2(white); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker3D_ptr);	
	
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0.0, 1.0, 0.0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 7:
		{
			//5.13, Notice that 5.13a is uses Sampler::sample_unit_square() from Listing 5.8, while 5.13b uses Listing 5.13 
			int num_samples = 16;
			Sampler* sampler_ptr = new MultiJittered(num_samples);

			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_max_depth(1);
			vp.set_sampler(sampler_ptr);	

			background_color = black;

			tracer_ptr = new AreaLighting(this);

			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(30, 13, 20);
			pinhole_ptr->set_lookat(0, -2, 0); 
			pinhole_ptr->set_view_distance(12000); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 

			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(3.0);
			emissive_ptr->set_ce(white);
	
			TRectangle* rectangle_ptr = new TRectangle(Point3D(-1, -0.5, -1), Vector3D(2, 0, 0), Vector3D(0, 0, 2), Normal(0, -1, 0));
			rectangle_ptr->set_material(emissive_ptr);
			rectangle_ptr->set_sampler(sampler_ptr);
			add_object(rectangle_ptr);
	
			AreaLight* rectangularLight_ptr = new AreaLight;
			rectangularLight_ptr->set_object(rectangle_ptr);
			rectangularLight_ptr->set_shadows(true);
			add_light(rectangularLight_ptr);
	
	
			Reflective* reflective_ptr1 = new Reflective;
			reflective_ptr1->set_ka(0.2); 
			reflective_ptr1->set_kd(0.1); 
			reflective_ptr1->set_cd(0, 1, 0.2);  // green
			reflective_ptr1->set_ks(0.0);     
			reflective_ptr1->set_exp(1);
			reflective_ptr1->set_kr(0.85); 
			reflective_ptr1->set_cr(0.75, 0.75, 1);  // blue 

			Sphere* sphere_ptr1 = new Sphere(Point3D(0, -2, 0), 0.5); 	
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);

		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(1);		
			checker_ptr->set_color1(1.0);  
			checker_ptr->set_color2(0.9);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.75);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -2.75, 0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 8:
		{
			//6p1
			int num_samples = 100;
	
			vp.set_hres(600);			
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);
			vp.set_max_depth(0);
	
			background_color = black;
			tracer_ptr = new RayCast(this);	
		
			// thin lens camera	
	
			ThinLens* thin_lens_ptr = new ThinLens;
			thin_lens_ptr->set_eye(100, 100, 50); 
			thin_lens_ptr->set_lookat(0, -10, 0);
			thin_lens_ptr->set_view_distance(390.0); 
			thin_lens_ptr->set_focal_distance(135.0);
			thin_lens_ptr->set_lens_radius(5.0); 			
			thin_lens_ptr->set_sampler(new MultiJittered(num_samples));		
			thin_lens_ptr->compute_uvw();     
			set_camera(thin_lens_ptr);
	   	
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(150, 500, 300);  
			light_ptr2->scale_radiance(3.75);  
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// city parameters
	
			float 	a					= 10;   // city block width:  xw extent
			float 	b   				= 12;	// city block length:  yw extent
			int 	num_rows			= 10;  	// number of blocks in the xw direction
			int 	num_columns			= 12; 	// number of blocks in the zw direction
			float	width				= 7;	// building width: xw extent in range [min, a - offset]
			float 	length				= 7;	// building length: zw extent in range [min, b - offset]
			float 	min_size			= 6;	// mininum building extent in xw and yw directions
			float 	offset				= 1.0;	// half the minimum distance between buildings
			float 	min_height			= 0.0; 	// minimum building height
			float 	max_height			= 30; 	// maximum bulding height
			float 	height;						// the building height in range [min_height, max_height]
			int		num_park_rows		= 4;  	// number of blocks of park in xw direction
			int		num_park_columns	= 6;  	// number of blocks of park in xw direction
			int 	row_test;					// there are no buildings in the park
			int 	column_test;				// there are no buildings in the park
			float 	min_color			= 0.1;  // prevents colors that are too dark
			float 	max_color			= 0.9;	// prevents colors that are too saturated
		
			set_rand_seed(15);  				// As the buildings' dimensions and colors are random, it's necessary to 
												// seed rand to keep these quantities the same at each run
												// If you leave this out, and change the number of samples per pixel,
												// these will change
	
			// The buildings are stored in a grid for efficiency, but you can render them without the grid
			// by storing them directly in the world.
	
			Grid* grid_ptr = new Grid;
	
			for (int r = 0; r < num_rows; r++)  			// xw direction
				for (int c = 0; c < num_columns; c++) {		// zw direction
					// determine if the block is in the park
		
					if ((r - num_rows / 2) >= 0)
						row_test = r -  num_rows / 2;
					else
						row_test = r -  num_rows / 2 + 1;
				
					if ((c - num_columns / 2) >= 0)
						column_test = c - num_columns / 2;
					else
						column_test = c - num_columns / 2 + 1;
			
					if (abs(row_test) >= (num_park_rows / 2) || abs(column_test) >= (num_park_columns / 2)) {
		
						// because both matte_ptr and reflective_ptr call randf, we have to keep one of
						// them commented out to keep the boxes and colours the same for a given seed

						Matte* matte_ptr = new Matte;			
						matte_ptr->set_cd(	min_color + rand_float() * (max_color - min_color), 
											min_color + rand_float() * (max_color - min_color), 
											min_color + rand_float() * (max_color - min_color));    
						matte_ptr->set_ka(0.4); 
						matte_ptr->set_kd(0.6); 			 
			
						// block center coordinates
				
						float xc = a * (r - num_rows / 2.0 + 0.5);
						float zc = b * (c - num_columns / 2.0 + 0.5);
				
						width = min_size + rand_float() * (a - 2 * offset - min_size);
						length = min_size + rand_float() * (b - 2 * offset - min_size);
				
				
						// minimum building coordinates
				
						float xmin = xc - width / 2.0;
						float ymin = 0.0;
						float zmin = zc - length / 2.0;
				
						// maximum building coordinates
				
						height = min_height + rand_float() * (max_height - min_height);
				
				
						// The following is a hack to make the middle row and column of buildings higher
						// on average than the other buildings. 
						// This only works when there are three rows and columns of buildings
				
						if (r == 1 || r == num_rows - 2 || c == 1 || c == num_columns - 2)
							height *= 1.5;
				
						float xmax = xc + width / 2.0;
						float ymax = height;
						float zmax = zc + length / 2.0;
				
						Box* building_ptr = new  Box(Point3D(xmin, ymin, zmin), Point3D(xmax, ymax, zmax));
						building_ptr->set_material(matte_ptr);
						grid_ptr->add_object(building_ptr);
					}
				}
		
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
			// render the park with small green checkers
		
			Checker3D* checker3D_ptr1 = new Checker3D;
			checker3D_ptr1->set_size(5.0); 
			checker3D_ptr1->set_color1(0.35, 0.75, 0.35);  
			checker3D_ptr1->set_color2(0.3, 0.5, 0.3);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.3);
			sv_matte_ptr1->set_kd(0.50);  
			sv_matte_ptr1->set_cd(checker3D_ptr1);
											
			Box* park_ptr = new Box( 	Point3D(-a * num_park_rows / 2, 0.0, -b * num_park_columns / 2), 
										Point3D(a * num_park_rows / 2, 0.1, b * num_park_columns / 2)  );										
			park_ptr->set_material(sv_matte_ptr1);
			add_object(park_ptr);
											
	
			// ground plane with checker:
	
			Checker3D* checker3D_ptr2 = new Checker3D;
			checker3D_ptr2->set_size(50.0); 
			checker3D_ptr2->set_color1(RGBColor(0.7));  
			checker3D_ptr2->set_color2(RGBColor(1));
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.30);
			sv_matte_ptr2->set_kd(0.40);  
			sv_matte_ptr2->set_cd(checker3D_ptr2);
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr2);
			add_object(plane_ptr);
			break;
		}
	case 9:
		{
			//8p1
			int num_samples = 1;
	
			vp.set_hres(500);			
			vp.set_vres(500);
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 2, 0); 
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->set_view_distance(73.0);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
		
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 1, 1);
			light_ptr->scale_radiance(3.0);
			add_light(light_ptr);
	
			// construct the spheres
	
			float d = 2.0; 		// sphere center spacing 
			float r = 0.75; 	// sphere radius
			float xc, yc; 		// sphere center coordinates
			int num_rows = 5;
			int num_columns = 5;
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(0.5);
			checker_ptr->set_color1(0,0.4,0.8);
			checker_ptr->set_color2(1,1,1);
			
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.2);
			sv_matte_ptr->set_kd(0.8);
			sv_matte_ptr->set_cd(checker_ptr);
	
			for (int k = 0; k < num_columns; k++) 		// up
				for (int j = 0; j < num_rows; j++) {	// across
						Sphere*	sphere_ptr = new Sphere();
						xc = d * (j - (num_columns - 1) / 2.0);
						yc = d * (k - (num_rows - 1) / 2.0);
						sphere_ptr->set_center(xc, 0, yc);
						sphere_ptr->set_radius(r);		
						sphere_ptr->set_material(sv_matte_ptr);
						add_object(sphere_ptr);
				}	
			break;
		}
	case 10:
		{
			//8.16a
			int num_samples = 1;
	
			vp.set_hres(400);			
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
			camera_ptr->set_eye(0, 0, 250);
			camera_ptr->set_lookat(0);    
			camera_ptr->set_view_distance(200);  	// for Figure 8.16(a)	
		//	camera_ptr->set_view_distance(450);  	// for Figure 8.16(b)		
		//	camera_ptr->set_view_distance(1000);  	// for Figure 8.16(c)
			camera_ptr->compute_uvw();		  
			set_camera(camera_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(50, 150, 200); 
			light_ptr1->scale_radiance(6.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			// sphere
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(0.5); 
			phong_ptr1->set_kd(0.4);
			phong_ptr1->set_cd(0.5, 0.6, 0);  	// green
			phong_ptr1->set_ks(0.05); 
			phong_ptr1->set_exp(25); 	
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(-45, 45, 40), 50); 
			sphere_ptr1->set_material(phong_ptr1);
			add_object(sphere_ptr1);
	
	
			// box
	
			Matte* matte_ptr = new Matte;				
			matte_ptr->set_ka(0.4); 
			matte_ptr->set_kd(0.3);
			matte_ptr->set_cd(0.8, 0.5, 0);  	// orange
	
			Box* box_ptr1 = new Box(Point3D(20, -101, -100), Point3D(90, 100, 20));
			box_ptr1->set_material(matte_ptr);
			add_object(box_ptr1);

	
			// triangle
	
			Phong*	phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(0.25); 
			phong_ptr2->set_kd(0.5); 
			phong_ptr2->set_cd(0, 0.5, 0.5);     // cyan
			phong_ptr2->set_ks(0.05); 
			phong_ptr2->set_exp(50); 

			Triangle* triangle_ptr1 = new Triangle(Point3D(-110, -85, 80), Point3D(120, 10, 20), Point3D(-40, 50, -30));
			triangle_ptr1->set_material(phong_ptr2);     
			add_object(triangle_ptr1);
			break;
		}
	case 11:
		{
			//8.16b
			int num_samples = 1;
	
			vp.set_hres(400);			
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
			camera_ptr->set_eye(0, 0, 250);
			camera_ptr->set_lookat(0);    
		//	camera_ptr->set_view_distance(200);  	// for Figure 8.16(a)	
			camera_ptr->set_view_distance(450);  	// for Figure 8.16(b)		
		//	camera_ptr->set_view_distance(1000);  	// for Figure 8.16(c)
			camera_ptr->compute_uvw();		  
			set_camera(camera_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(50, 150, 200); 
			light_ptr1->scale_radiance(6.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			// sphere
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(0.5); 
			phong_ptr1->set_kd(0.4);
			phong_ptr1->set_cd(0.5, 0.6, 0);  	// green
			phong_ptr1->set_ks(0.05); 
			phong_ptr1->set_exp(25); 	
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(-45, 45, 40), 50); 
			sphere_ptr1->set_material(phong_ptr1);
			add_object(sphere_ptr1);
	
	
			// box
	
			Matte* matte_ptr = new Matte;				
			matte_ptr->set_ka(0.4); 
			matte_ptr->set_kd(0.3);
			matte_ptr->set_cd(0.8, 0.5, 0);  	// orange
	
			Box* box_ptr1 = new Box(Point3D(20, -101, -100), Point3D(90, 100, 20));
			box_ptr1->set_material(matte_ptr);
			add_object(box_ptr1);

	
			// triangle
	
			Phong*	phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(0.25); 
			phong_ptr2->set_kd(0.5); 
			phong_ptr2->set_cd(0, 0.5, 0.5);     // cyan
			phong_ptr2->set_ks(0.05); 
			phong_ptr2->set_exp(50); 

			Triangle* triangle_ptr1 = new Triangle(Point3D(-110, -85, 80), Point3D(120, 10, 20), Point3D(-40, 50, -30));
			triangle_ptr1->set_material(phong_ptr2);     
			add_object(triangle_ptr1);
			break;
		}
	case 12:
		{
			//8.16c
			int num_samples = 1;
	
			vp.set_hres(400);			
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
			camera_ptr->set_eye(0, 0, 250);
			camera_ptr->set_lookat(0);    
		//	camera_ptr->set_view_distance(200);  	// for Figure 8.16(a)	
		//	camera_ptr->set_view_distance(450);  	// for Figure 8.16(b)		
			camera_ptr->set_view_distance(1000);  	// for Figure 8.16(c)
			camera_ptr->compute_uvw();		  
			set_camera(camera_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(50, 150, 200); 
			light_ptr1->scale_radiance(6.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			// sphere
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(0.5); 
			phong_ptr1->set_kd(0.4);
			phong_ptr1->set_cd(0.5, 0.6, 0);  	// green
			phong_ptr1->set_ks(0.05); 
			phong_ptr1->set_exp(25); 	
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(-45, 45, 40), 50); 
			sphere_ptr1->set_material(phong_ptr1);
			add_object(sphere_ptr1);
	
	
			// box
	
			Matte* matte_ptr = new Matte;				
			matte_ptr->set_ka(0.4); 
			matte_ptr->set_kd(0.3);
			matte_ptr->set_cd(0.8, 0.5, 0);  	// orange
	
			Box* box_ptr1 = new Box(Point3D(20, -101, -100), Point3D(90, 100, 20));
			box_ptr1->set_material(matte_ptr);
			add_object(box_ptr1);

	
			// triangle
	
			Phong*	phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(0.25); 
			phong_ptr2->set_kd(0.5); 
			phong_ptr2->set_cd(0, 0.5, 0.5);     // cyan
			phong_ptr2->set_ks(0.05); 
			phong_ptr2->set_exp(50); 

			Triangle* triangle_ptr1 = new Triangle(Point3D(-110, -85, 80), Point3D(120, 10, 20), Point3D(-40, 50, -30));
			triangle_ptr1->set_material(phong_ptr2);     
			add_object(triangle_ptr1);
			break;
		}
	case 13:
		{
			//8.19a
			int num_samples = 1;
	
			vp.set_hres(400);			
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
			camera_ptr->set_eye(0, 0, 200);     // for Figure 8.19(a)
		//	camera_ptr->set_eye(0, 0, 135);     // for Figure 8.19(b)
		//	camera_ptr->set_eye(0, 0, 75);      // for Figure 8.19(c)
			camera_ptr->set_view_distance(100);
		
			camera_ptr->compute_uvw();		  
			set_camera(camera_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(50, 150, 200); 
			light_ptr1->scale_radiance(6.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			// sphere
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(0.5); 
			phong_ptr1->set_kd(0.4);
			phong_ptr1->set_cd(0.5, 0.6, 0);  	// green
			phong_ptr1->set_ks(0.05); 
			phong_ptr1->set_exp(25); 	
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(-45, 45, 40), 50); 
			sphere_ptr1->set_material(phong_ptr1);
			add_object(sphere_ptr1);
	
	
			// box
	
			Matte* matte_ptr = new Matte;				
			matte_ptr->set_ka(0.4); 
			matte_ptr->set_kd(0.3);
			matte_ptr->set_cd(0.8, 0.5, 0);  	// orange
	
			Box* box_ptr1 = new Box(Point3D(20, -101, -100), Point3D(90, 100, 20));
			box_ptr1->set_material(matte_ptr);
			add_object(box_ptr1);

	
			// triangle
	
			Phong*	phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(0.25); 
			phong_ptr2->set_kd(0.5); 
			phong_ptr2->set_cd(0, 0.5, 0.5);     // cyan
			phong_ptr2->set_ks(0.05); 
			phong_ptr2->set_exp(50); 

			Triangle* triangle_ptr1 = new Triangle(Point3D(-110, -85, 80), Point3D(120, 10, 20), Point3D(-40, 50, -30));
			triangle_ptr1->set_material(phong_ptr2);     
			add_object(triangle_ptr1);
			break;
		}
	case 14:
		{
			//8.19b
			int num_samples = 1;
	
			vp.set_hres(400);			
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
		//	camera_ptr->set_eye(0, 0, 200);     // for Figure 8.19(a)
			camera_ptr->set_eye(0, 0, 135);     // for Figure 8.19(b)
		//	camera_ptr->set_eye(0, 0, 75);      // for Figure 8.19(c)
			camera_ptr->set_view_distance(100);
		
			camera_ptr->compute_uvw();		  
			set_camera(camera_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(50, 150, 200); 
			light_ptr1->scale_radiance(6.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			// sphere
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(0.5); 
			phong_ptr1->set_kd(0.4);
			phong_ptr1->set_cd(0.5, 0.6, 0);  	// green
			phong_ptr1->set_ks(0.05); 
			phong_ptr1->set_exp(25); 	
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(-45, 45, 40), 50); 
			sphere_ptr1->set_material(phong_ptr1);
			add_object(sphere_ptr1);
	
	
			// box
	
			Matte* matte_ptr = new Matte;				
			matte_ptr->set_ka(0.4); 
			matte_ptr->set_kd(0.3);
			matte_ptr->set_cd(0.8, 0.5, 0);  	// orange
	
			Box* box_ptr1 = new Box(Point3D(20, -101, -100), Point3D(90, 100, 20));
			box_ptr1->set_material(matte_ptr);
			add_object(box_ptr1);

	
			// triangle
	
			Phong*	phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(0.25); 
			phong_ptr2->set_kd(0.5); 
			phong_ptr2->set_cd(0, 0.5, 0.5);     // cyan
			phong_ptr2->set_ks(0.05); 
			phong_ptr2->set_exp(50); 

			Triangle* triangle_ptr1 = new Triangle(Point3D(-110, -85, 80), Point3D(120, 10, 20), Point3D(-40, 50, -30));
			triangle_ptr1->set_material(phong_ptr2);     
			add_object(triangle_ptr1);
			break;
		}
	case 15:
		{
			//8.19c
			int num_samples = 1;
	
			vp.set_hres(400);			
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
		//	camera_ptr->set_eye(0, 0, 200);     // for Figure 8.19(a)
		//	camera_ptr->set_eye(0, 0, 135);     // for Figure 8.19(b)
			camera_ptr->set_eye(0, 0, 75);      // for Figure 8.19(c)
			camera_ptr->set_view_distance(100);
		
			camera_ptr->compute_uvw();		  
			set_camera(camera_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(50, 150, 200); 
			light_ptr1->scale_radiance(6.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			// sphere
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(0.5); 
			phong_ptr1->set_kd(0.4);
			phong_ptr1->set_cd(0.5, 0.6, 0);  	// green
			phong_ptr1->set_ks(0.05); 
			phong_ptr1->set_exp(25); 	
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(-45, 45, 40), 50); 
			sphere_ptr1->set_material(phong_ptr1);
			add_object(sphere_ptr1);
	
	
			// box
	
			Matte* matte_ptr = new Matte;				
			matte_ptr->set_ka(0.4); 
			matte_ptr->set_kd(0.3);
			matte_ptr->set_cd(0.8, 0.5, 0);  	// orange
	
			Box* box_ptr1 = new Box(Point3D(20, -101, -100), Point3D(90, 100, 20));
			box_ptr1->set_material(matte_ptr);
			add_object(box_ptr1);

	
			// triangle
	
			Phong*	phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(0.25); 
			phong_ptr2->set_kd(0.5); 
			phong_ptr2->set_cd(0, 0.5, 0.5);     // cyan
			phong_ptr2->set_ks(0.05); 
			phong_ptr2->set_exp(50); 

			Triangle* triangle_ptr1 = new Triangle(Point3D(-110, -85, 80), Point3D(120, 10, 20), Point3D(-40, 50, -30));
			triangle_ptr1->set_material(phong_ptr2);     
			add_object(triangle_ptr1);
			break;
		}
	case 16:
		{
			//8.21a
			int num_samples = 1;
	
			vp.set_hres(500);			
			vp.set_vres(500);
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
	
			Pinhole* pinhole_ptr = new Pinhole;
	
			pinhole_ptr->set_eye(0, 15, 0); 		// for Figure 8.21(a)
			pinhole_ptr->set_view_distance(755);
		
		//	pinhole_ptr->set_eye(0, 5, 0); 			// for Figure 8.21(b)
		//	pinhole_ptr->set_view_distance(235);
		
		//	pinhole_ptr->set_eye(0, 2, 0); 			// for Figure 8.21(c)
		//	pinhole_ptr->set_view_distance(73.0);
	
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
		
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 1, 1);
			light_ptr->scale_radiance(3.0);
			add_light(light_ptr);
	
			// construct the spheres
	
			float d = 2.0; 		// sphere center spacing 
			float r = 0.75; 	// sphere radius
			float xc, yc; 		// sphere center coordinates
			int num_rows = 5;
			int num_columns = 5;
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(0.5);
			checker_ptr->set_color1(0,0.4,0.8);
			checker_ptr->set_color2(1,1,1);
			
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.2);
			sv_matte_ptr->set_kd(0.8);
			sv_matte_ptr->set_cd(checker_ptr);
	
			for (int k = 0; k < num_columns; k++) 		// up
				for (int j = 0; j < num_rows; j++) {	// across
						Sphere*	sphere_ptr = new Sphere();
						xc = d * (j - (num_columns - 1) / 2.0);
						yc = d * (k - (num_rows - 1) / 2.0);
						sphere_ptr->set_center(xc, 0, yc);
						sphere_ptr->set_radius(r);		
						sphere_ptr->set_material(sv_matte_ptr);
						add_object(sphere_ptr);
				}	
			break;
		}
	case 17:
		{
			//8.21b
			int num_samples = 1;
	
			vp.set_hres(500);			
			vp.set_vres(500);
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
	
			Pinhole* pinhole_ptr = new Pinhole;
	
		//	pinhole_ptr->set_eye(0, 15, 0); 		// for Figure 8.21(a)
		//	pinhole_ptr->set_view_distance(755);
		
			pinhole_ptr->set_eye(0, 5, 0); 			// for Figure 8.21(b)
			pinhole_ptr->set_view_distance(235);
		
		//	pinhole_ptr->set_eye(0, 2, 0); 			// for Figure 8.21(c)
		//	pinhole_ptr->set_view_distance(73.0);
	
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
		
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 1, 1);
			light_ptr->scale_radiance(3.0);
			add_light(light_ptr);
	
			// construct the spheres
	
			float d = 2.0; 		// sphere center spacing 
			float r = 0.75; 	// sphere radius
			float xc, yc; 		// sphere center coordinates
			int num_rows = 5;
			int num_columns = 5;
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(0.5);
			checker_ptr->set_color1(0,0.4,0.8);
			checker_ptr->set_color2(1,1,1);
			
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.2);
			sv_matte_ptr->set_kd(0.8);
			sv_matte_ptr->set_cd(checker_ptr);
	
			for (int k = 0; k < num_columns; k++) 		// up
				for (int j = 0; j < num_rows; j++) {	// across
						Sphere*	sphere_ptr = new Sphere();
						xc = d * (j - (num_columns - 1) / 2.0);
						yc = d * (k - (num_rows - 1) / 2.0);
						sphere_ptr->set_center(xc, 0, yc);
						sphere_ptr->set_radius(r);		
						sphere_ptr->set_material(sv_matte_ptr);
						add_object(sphere_ptr);
				}	
			break;
		}
	case 18:
		{
			//8.21c
			int num_samples = 1;
	
			vp.set_hres(500);			
			vp.set_vres(500);
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
	
			Pinhole* pinhole_ptr = new Pinhole;
	
		//	pinhole_ptr->set_eye(0, 15, 0); 		// for Figure 8.21(a)
		//	pinhole_ptr->set_view_distance(755);
		
		//	pinhole_ptr->set_eye(0, 5, 0); 			// for Figure 8.21(b)
		//	pinhole_ptr->set_view_distance(235);
		
			pinhole_ptr->set_eye(0, 2, 0); 			// for Figure 8.21(c)
			pinhole_ptr->set_view_distance(73.0);
	
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
		
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 1, 1);
			light_ptr->scale_radiance(3.0);
			add_light(light_ptr);
	
			// construct the spheres
	
			float d = 2.0; 		// sphere center spacing 
			float r = 0.75; 	// sphere radius
			float xc, yc; 		// sphere center coordinates
			int num_rows = 5;
			int num_columns = 5;
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(0.5);
			checker_ptr->set_color1(0,0.4,0.8);
			checker_ptr->set_color2(1,1,1);
			
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.2);
			sv_matte_ptr->set_kd(0.8);
			sv_matte_ptr->set_cd(checker_ptr);
	
			for (int k = 0; k < num_columns; k++) 		// up
				for (int j = 0; j < num_rows; j++) {	// across
						Sphere*	sphere_ptr = new Sphere();
						xc = d * (j - (num_columns - 1) / 2.0);
						yc = d * (k - (num_rows - 1) / 2.0);
						sphere_ptr->set_center(xc, 0, yc);
						sphere_ptr->set_radius(r);		
						sphere_ptr->set_material(sv_matte_ptr);
						add_object(sphere_ptr);
				}	
			break;
		}
	case 19:
		{
			//8.22a
			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);

			Pinhole* pinhole_ptr = new Pinhole;	
		
			pinhole_ptr->set_eye(0, 0, 10);       	// for Figure 8.22(a)
			pinhole_ptr->set_view_distance(1687);
	
		//	pinhole_ptr->set_eye(0, 0, 5);       	// for Figure 8.22(b)
		//	pinhole_ptr->set_view_distance(750);
	
		//	pinhole_ptr->set_eye(0, 0, 2.5);       	// for Figure 8.22(c)
		//	pinhole_ptr->set_view_distance(280);
	
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(10, 50, 40);
			light_ptr->scale_radiance(3.0); 
			add_light(light_ptr);
	
			Phong* phong_ptr = new Phong;			
			phong_ptr->set_ka(0.25); 
			phong_ptr->set_kd(0.65); 
			phong_ptr->set_cd(white);   
			phong_ptr->set_ks(0.1); 
			phong_ptr->set_exp(25); 
	
			Point3D p0(-1.0);
			Point3D p1(1.0);
			float bevel_radius = 0.02;
	
			WireframeBox* box_ptr = new WireframeBox(p0, p1, bevel_radius);
			box_ptr->set_material(phong_ptr);
			add_object(box_ptr);	
			break;
		}
	case 20:
		{
			//8.22b
			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);

			Pinhole* pinhole_ptr = new Pinhole;	
		
		//	pinhole_ptr->set_eye(0, 0, 10);       	// for Figure 8.22(a)
		//	pinhole_ptr->set_view_distance(1687);
	
			pinhole_ptr->set_eye(0, 0, 5);       	// for Figure 8.22(b)
			pinhole_ptr->set_view_distance(750);
	
		//	pinhole_ptr->set_eye(0, 0, 2.5);       	// for Figure 8.22(c)
		//	pinhole_ptr->set_view_distance(280);
	
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(10, 50, 40);
			light_ptr->scale_radiance(3.0); 
			add_light(light_ptr);
	
			Phong* phong_ptr = new Phong;			
			phong_ptr->set_ka(0.25); 
			phong_ptr->set_kd(0.65); 
			phong_ptr->set_cd(white);   
			phong_ptr->set_ks(0.1); 
			phong_ptr->set_exp(25); 
	
			Point3D p0(-1.0);
			Point3D p1(1.0);
			float bevel_radius = 0.02;
	
			WireframeBox* box_ptr = new WireframeBox(p0, p1, bevel_radius);
			box_ptr->set_material(phong_ptr);
			add_object(box_ptr);	
			break;
		}
	case 21:
		{
			//8.22c
			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);

			Pinhole* pinhole_ptr = new Pinhole;	
		
		//	pinhole_ptr->set_eye(0, 0, 10);       	// for Figure 8.22(a)
		//	pinhole_ptr->set_view_distance(1687);
	
		//	pinhole_ptr->set_eye(0, 0, 5);       	// for Figure 8.22(b)
		//	pinhole_ptr->set_view_distance(750);
	
			pinhole_ptr->set_eye(0, 0, 2.5);       	// for Figure 8.22(c)
			pinhole_ptr->set_view_distance(280);
	
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(10, 50, 40);
			light_ptr->scale_radiance(3.0); 
			add_light(light_ptr);
	
			Phong* phong_ptr = new Phong;			
			phong_ptr->set_ka(0.25); 
			phong_ptr->set_kd(0.65); 
			phong_ptr->set_cd(white);   
			phong_ptr->set_ks(0.1); 
			phong_ptr->set_exp(25); 
	
			Point3D p0(-1.0);
			Point3D p1(1.0);
			float bevel_radius = 0.02;
	
			WireframeBox* box_ptr = new WireframeBox(p0, p1, bevel_radius);
			box_ptr->set_material(phong_ptr);
			add_object(box_ptr);	
			break;
		}
	case 22:
		{
			//9.09a
			int num_samples = 1;
	
			vp.set_hres(300);			
			vp.set_vres(300);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
	
			// for Figure 9.9(a)	

			camera_ptr->set_eye(0, 0, 500);
			camera_ptr->set_lookat(0);    
			camera_ptr->set_view_distance(500); 
		
		/*	
			// for Figure 9.9(b)
	
			camera_ptr->set_eye(300, 400, 500);
			camera_ptr->set_lookat(0, 0, -50);
			camera_ptr->set_view_distance(400);
		*/

		/*	
			// for Figure 9.9(c)
	
			camera_ptr->set_eye(-1000, 2000, -500);
			camera_ptr->set_lookat(0, -100, 0);
			camera_ptr->set_view_distance(250);
		*/
	
			camera_ptr->compute_uvw();		  
			set_camera(camera_ptr);
	

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(50, 150, 200); 
			light_ptr1->scale_radiance(6.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			// sphere
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(0.5); 
			phong_ptr1->set_kd(0.4);
			phong_ptr1->set_cd(0.5, 0.6, 0);  	// green
			phong_ptr1->set_ks(0.05); 
			phong_ptr1->set_exp(25); 	
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(-45, 45, 40), 50); 
			sphere_ptr1->set_material(phong_ptr1);
			add_object(sphere_ptr1);
	
	
			// box
	
			Matte* matte_ptr = new Matte;				
			matte_ptr->set_ka(0.4); 
			matte_ptr->set_kd(0.3);
			matte_ptr->set_cd(0.8, 0.5, 0);  	// orange
	
			Box* box_ptr1 = new Box(Point3D(20, -101, -100), Point3D(90, 100, 20));
			box_ptr1->set_material(matte_ptr);
			add_object(box_ptr1);

	
			// triangle
	
			Phong*	phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(0.25); 
			phong_ptr2->set_kd(0.5); 
			phong_ptr2->set_cd(0, 0.5, 0.5);     // cyan
			phong_ptr2->set_ks(0.05); 
			phong_ptr2->set_exp(50); 

			Triangle* triangle_ptr1 = new Triangle(Point3D(-110, -85, 80), Point3D(120, 10, 20), Point3D(-40, 50, -30));
			triangle_ptr1->set_material(phong_ptr2);     
			add_object(triangle_ptr1);
	
	
			// ground plane with checker
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(100); 
			checker3D_ptr->set_color1(0.7);  
			checker3D_ptr->set_color2(1.0);

			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker3D_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -101, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 23:
		{
			//9.09b
			int num_samples = 1;
	
			vp.set_hres(300);			
			vp.set_vres(300);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
		/*
			// for Figure 9.9(a)	

			camera_ptr->set_eye(0, 0, 500);
			camera_ptr->set_lookat(0);    
			camera_ptr->set_view_distance(500); 
		*/
			
			// for Figure 9.9(b)
	
			camera_ptr->set_eye(300, 400, 500);
			camera_ptr->set_lookat(0, 0, -50);
			camera_ptr->set_view_distance(400);
		

		/*	
			// for Figure 9.9(c)
	
			camera_ptr->set_eye(-1000, 2000, -500);
			camera_ptr->set_lookat(0, -100, 0);
			camera_ptr->set_view_distance(250);
		*/
	
			camera_ptr->compute_uvw();		  
			set_camera(camera_ptr);
	

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(50, 150, 200); 
			light_ptr1->scale_radiance(6.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			// sphere
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(0.5); 
			phong_ptr1->set_kd(0.4);
			phong_ptr1->set_cd(0.5, 0.6, 0);  	// green
			phong_ptr1->set_ks(0.05); 
			phong_ptr1->set_exp(25); 	
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(-45, 45, 40), 50); 
			sphere_ptr1->set_material(phong_ptr1);
			add_object(sphere_ptr1);
	
	
			// box
	
			Matte* matte_ptr = new Matte;				
			matte_ptr->set_ka(0.4); 
			matte_ptr->set_kd(0.3);
			matte_ptr->set_cd(0.8, 0.5, 0);  	// orange
	
			Box* box_ptr1 = new Box(Point3D(20, -101, -100), Point3D(90, 100, 20));
			box_ptr1->set_material(matte_ptr);
			add_object(box_ptr1);

	
			// triangle
	
			Phong*	phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(0.25); 
			phong_ptr2->set_kd(0.5); 
			phong_ptr2->set_cd(0, 0.5, 0.5);     // cyan
			phong_ptr2->set_ks(0.05); 
			phong_ptr2->set_exp(50); 

			Triangle* triangle_ptr1 = new Triangle(Point3D(-110, -85, 80), Point3D(120, 10, 20), Point3D(-40, 50, -30));
			triangle_ptr1->set_material(phong_ptr2);     
			add_object(triangle_ptr1);
	
	
			// ground plane with checker
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(100); 
			checker3D_ptr->set_color1(0.7);  
			checker3D_ptr->set_color2(1.0);

			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker3D_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -101, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 24:
		{
			//9.09c
			int num_samples = 1;
	
			vp.set_hres(300);			
			vp.set_vres(300);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
		/*
			// for Figure 9.9(a)	

			camera_ptr->set_eye(0, 0, 500);
			camera_ptr->set_lookat(0);    
			camera_ptr->set_view_distance(500); 
		*/
		/*	
			// for Figure 9.9(b)
	
			camera_ptr->set_eye(300, 400, 500);
			camera_ptr->set_lookat(0, 0, -50);
			camera_ptr->set_view_distance(400);
		*/

			
			// for Figure 9.9(c)
	
			camera_ptr->set_eye(-1000, 2000, -500);
			camera_ptr->set_lookat(0, -100, 0);
			camera_ptr->set_view_distance(250);
		
	
			camera_ptr->compute_uvw();		  
			set_camera(camera_ptr);
	

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(50, 150, 200); 
			light_ptr1->scale_radiance(6.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			// sphere
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(0.5); 
			phong_ptr1->set_kd(0.4);
			phong_ptr1->set_cd(0.5, 0.6, 0);  	// green
			phong_ptr1->set_ks(0.05); 
			phong_ptr1->set_exp(25); 	
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(-45, 45, 40), 50); 
			sphere_ptr1->set_material(phong_ptr1);
			add_object(sphere_ptr1);
	
	
			// box
	
			Matte* matte_ptr = new Matte;				
			matte_ptr->set_ka(0.4); 
			matte_ptr->set_kd(0.3);
			matte_ptr->set_cd(0.8, 0.5, 0);  	// orange
	
			Box* box_ptr1 = new Box(Point3D(20, -101, -100), Point3D(90, 100, 20));
			box_ptr1->set_material(matte_ptr);
			add_object(box_ptr1);

	
			// triangle
	
			Phong*	phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(0.25); 
			phong_ptr2->set_kd(0.5); 
			phong_ptr2->set_cd(0, 0.5, 0.5);     // cyan
			phong_ptr2->set_ks(0.05); 
			phong_ptr2->set_exp(50); 

			Triangle* triangle_ptr1 = new Triangle(Point3D(-110, -85, 80), Point3D(120, 10, 20), Point3D(-40, 50, -30));
			triangle_ptr1->set_material(phong_ptr2);     
			add_object(triangle_ptr1);
	
	
			// ground plane with checker
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(100); 
			checker3D_ptr->set_color1(0.7);  
			checker3D_ptr->set_color2(1.0);

			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker3D_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -101, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 25:
		{
			//9.10a
			vp.set_hres(400);			
			vp.set_vres(400);
			vp.set_samples(25);
	
			tracer_ptr = new RayCast(this);
			
			Pinhole* camera_ptr = new Pinhole;
	
			// Figure9.10(a)
		
			camera_ptr->set_eye(150, 195, 125);
			camera_ptr->set_lookat(0, 195, -40);
			camera_ptr->set_view_distance(167);
		
		/*		
			// Figure9.10(b)
		
			camera_ptr->set_eye(150, 300, 125);   
			camera_ptr->set_lookat(0, 265, -40);  
			camera_ptr->set_view_distance(167);
		*/
			/*
			// Figure9.10(c)
		
			camera_ptr->set_eye(-250, 350, 500);   
			camera_ptr->set_lookat(-250, 350, 0);  
			camera_ptr->set_view_distance(280);
			*/
			camera_ptr->compute_uvw(); 
			set_camera(camera_ptr);

	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(150, 200, 65);   
			light_ptr1->scale_radiance(5.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_cd(0, 0.5, 0.5);     // cyan
			matte_ptr1->set_ka(0.4); 
			matte_ptr1->set_kd(0.5); 
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_cd(0.8, 0.5, 0);     // orange
			matte_ptr2->set_ka(0.4); 
			matte_ptr2->set_kd(0.5);  
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_cd(0.5, 0.6, 0);     // green
			matte_ptr3->set_ka(0.4); 
			matte_ptr3->set_kd(0.5); 
	
	
			// construct rows of boxes parallel to the zw axis
	
			Grid* grid_ptr = new Grid;
	
			// first row
	
			int num_boxes = 40;
			float wx = 50;
			float wz = 50;
			float h = 150;
			float s = 100;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx, 0, -(j + 1) * wz - j * s), 
										Point3D(0, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr2);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// second row
	
			h = 300;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx -wx - s, 0, -(j + 1) * wz - j * s), 
										Point3D(-wx - s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr1);
		//		add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// third row
	
			h = 600;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx - 2 * wx - 2 * s, 0, -(j + 1) * wz - j * s), 
										Point3D(-2 * wx - 2 * s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr3);
		//		add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// a column
	
			h = 150;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-3 * (wx + s) - (j + 1) * wz - j * s, 0, -wx), 
										Point3D(-3 * (wx + s) - j * wz - j * s, h, 0));
				box_ptr->set_material(matte_ptr2);
		//		add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
	
			// ground plane with checker:
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(wx); 
			checker3D_ptr->set_color1(0.7);  
			checker3D_ptr->set_color2(1.0);

			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker3D_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, 1, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 26:
		{
			//9.10b
			vp.set_hres(400);			
			vp.set_vres(400);
			vp.set_samples(25);
	
			tracer_ptr = new RayCast(this);
			
			Pinhole* camera_ptr = new Pinhole;
	
			// Figure9.10(a)
		/*	
			camera_ptr->set_eye(150, 195, 125);
			camera_ptr->set_lookat(0, 195, -40);
			camera_ptr->set_view_distance(167);
		*/	
			
			// Figure9.10(b)
		
			camera_ptr->set_eye(150, 300, 125);   
			camera_ptr->set_lookat(0, 265, -40);  
			camera_ptr->set_view_distance(167);
		

			// Figure9.10(c)
		/*
			camera_ptr->set_eye(-250, 350, 500);   
			camera_ptr->set_lookat(-250, 350, 0);  
			camera_ptr->set_view_distance(280);
			*/
			camera_ptr->compute_uvw(); 
			set_camera(camera_ptr);

	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(150, 200, 65);   
			light_ptr1->scale_radiance(5.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_cd(0, 0.5, 0.5);     // cyan
			matte_ptr1->set_ka(0.4); 
			matte_ptr1->set_kd(0.5); 
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_cd(0.8, 0.5, 0);     // orange
			matte_ptr2->set_ka(0.4); 
			matte_ptr2->set_kd(0.5);  
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_cd(0.5, 0.6, 0);     // green
			matte_ptr3->set_ka(0.4); 
			matte_ptr3->set_kd(0.5); 
	
	
			// construct rows of boxes parallel to the zw axis
	
			Grid* grid_ptr = new Grid;
	
			// first row
	
			int num_boxes = 40;
			float wx = 50;
			float wz = 50;
			float h = 150;
			float s = 100;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx, 0, -(j + 1) * wz - j * s), 
										Point3D(0, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr2);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// second row
	
			h = 300;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx -wx - s, 0, -(j + 1) * wz - j * s), 
										Point3D(-wx - s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr1);
		//		add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// third row
	
			h = 600;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx - 2 * wx - 2 * s, 0, -(j + 1) * wz - j * s), 
										Point3D(-2 * wx - 2 * s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr3);
		//		add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// a column
	
			h = 150;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-3 * (wx + s) - (j + 1) * wz - j * s, 0, -wx), 
										Point3D(-3 * (wx + s) - j * wz - j * s, h, 0));
				box_ptr->set_material(matte_ptr2);
		//		add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
	
			// ground plane with checker:
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(wx); 
			checker3D_ptr->set_color1(0.7);  
			checker3D_ptr->set_color2(1.0);

			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker3D_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, 1, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 27:
		{
			//9.10a
			vp.set_hres(400);			
			vp.set_vres(400);
			vp.set_samples(25);
	
			tracer_ptr = new RayCast(this);
			
			Pinhole* camera_ptr = new Pinhole;
	
			// Figure9.10(a)
		/*	
			camera_ptr->set_eye(150, 195, 125);
			camera_ptr->set_lookat(0, 195, -40);
			camera_ptr->set_view_distance(167);
		*/	
		/*		
			// Figure9.10(b)
		
			camera_ptr->set_eye(150, 300, 125);   
			camera_ptr->set_lookat(0, 265, -40);  
			camera_ptr->set_view_distance(167);
		*/

			// Figure9.10(c)
		
			camera_ptr->set_eye(-250, 350, 500);   
			camera_ptr->set_lookat(-250, 350, 0);  
			camera_ptr->set_view_distance(280);

			camera_ptr->compute_uvw(); 
			set_camera(camera_ptr);

	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(150, 200, 65);   
			light_ptr1->scale_radiance(5.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_cd(0, 0.5, 0.5);     // cyan
			matte_ptr1->set_ka(0.4); 
			matte_ptr1->set_kd(0.5); 
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_cd(0.8, 0.5, 0);     // orange
			matte_ptr2->set_ka(0.4); 
			matte_ptr2->set_kd(0.5);  
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_cd(0.5, 0.6, 0);     // green
			matte_ptr3->set_ka(0.4); 
			matte_ptr3->set_kd(0.5); 
	
	
			// construct rows of boxes parallel to the zw axis
	
			Grid* grid_ptr = new Grid;
	
			// first row
	
			int num_boxes = 40;
			float wx = 50;
			float wz = 50;
			float h = 150;
			float s = 100;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx, 0, -(j + 1) * wz - j * s), 
										Point3D(0, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr2);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// second row
	
			h = 300;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx -wx - s, 0, -(j + 1) * wz - j * s), 
										Point3D(-wx - s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr1);
		//		add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// third row
	
			h = 600;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx - 2 * wx - 2 * s, 0, -(j + 1) * wz - j * s), 
										Point3D(-2 * wx - 2 * s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr3);
		//		add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// a column
	
			h = 150;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-3 * (wx + s) - (j + 1) * wz - j * s, 0, -wx), 
										Point3D(-3 * (wx + s) - j * wz - j * s, h, 0));
				box_ptr->set_material(matte_ptr2);
		//		add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
	
			// ground plane with checker:
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(wx); 
			checker3D_ptr->set_color1(0.7);  
			checker3D_ptr->set_color2(1.0);

			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker3D_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, 1, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 28:
		{
			//9.11a
			int num_samples = 1;
	
			vp.set_hres(300);			
			vp.set_vres(300);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
	
			// for Figure 9.11(a)	

			camera_ptr->set_eye(0, 0, 500);
			camera_ptr->set_lookat(0);    
			camera_ptr->set_view_distance(500);
			camera_ptr->set_up_vector(1, 1, 0); 


		/*
	
			// for Figure 9.11(b)
	
			camera_ptr->set_eye(500, 0, 0);
			camera_ptr->set_lookat(0);    
			camera_ptr->set_view_distance(400);
			camera_ptr->set_up_vector(0, 1, -1);
	
		*/

		/*	
			// for Figure 9.11(c)
		
			camera_ptr->set_eye(300, 400, 500);
			camera_ptr->set_lookat(-20, -30, -50); 
			camera_ptr->set_view_distance(400);
			camera_ptr->set_roll_angle(145);        // see Exercise 9.6
	
		*/

	
			camera_ptr->compute_uvw();		  
			set_camera(camera_ptr);
	

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(50, 150, 200); 
			light_ptr1->scale_radiance(6.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			// sphere
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(0.5); 
			phong_ptr1->set_kd(0.4);
			phong_ptr1->set_cd(0.5, 0.6, 0);  	// green
			phong_ptr1->set_ks(0.05); 
			phong_ptr1->set_exp(25); 	
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(-45, 45, 40), 50); 
			sphere_ptr1->set_material(phong_ptr1);
			add_object(sphere_ptr1);
	
	
			// box
	
			Matte* matte_ptr = new Matte;				
			matte_ptr->set_ka(0.4); 
			matte_ptr->set_kd(0.3);
			matte_ptr->set_cd(0.8, 0.5, 0);  	// orange
	
			Box* box_ptr1 = new Box(Point3D(20, -101, -100), Point3D(90, 100, 20));
			box_ptr1->set_material(matte_ptr);
			add_object(box_ptr1);

	
			// triangle
	
			Phong*	phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(0.25); 
			phong_ptr2->set_kd(0.5); 
			phong_ptr2->set_cd(0, 0.5, 0.5);     // cyan
			phong_ptr2->set_ks(0.05); 
			phong_ptr2->set_exp(50); 

			Triangle* triangle_ptr1 = new Triangle(Point3D(-110, -85, 80), Point3D(120, 10, 20), Point3D(-40, 50, -30));
			triangle_ptr1->set_material(phong_ptr2);     
			add_object(triangle_ptr1);
	
	
			// ground plane with checker
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(100); 
			checker3D_ptr->set_color1(0.7);  
			checker3D_ptr->set_color2(1.0);

			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker3D_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -101, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 29:
		{
			//9.11b
			int num_samples = 1;
	
			vp.set_hres(300);			
			vp.set_vres(300);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
	
			// for Figure 9.11(a)	
		/*
			camera_ptr->set_eye(0, 0, 500);
			camera_ptr->set_lookat(0);    
			camera_ptr->set_view_distance(500);
			camera_ptr->set_up_vector(1, 1, 0); 
			*/
	
			// for Figure 9.11(b)
	
			camera_ptr->set_eye(500, 0, 0);
			camera_ptr->set_lookat(0);    
			camera_ptr->set_view_distance(400);
			camera_ptr->set_up_vector(0, 1, -1);

		/*	
			// for Figure 9.11(c)
		
			camera_ptr->set_eye(300, 400, 500);
			camera_ptr->set_lookat(-20, -30, -50); 
			camera_ptr->set_view_distance(400);
			camera_ptr->set_roll_angle(145);        // see Exercise 9.6
	
		*/

	
			camera_ptr->compute_uvw();		  
			set_camera(camera_ptr);
	

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(50, 150, 200); 
			light_ptr1->scale_radiance(6.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			// sphere
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(0.5); 
			phong_ptr1->set_kd(0.4);
			phong_ptr1->set_cd(0.5, 0.6, 0);  	// green
			phong_ptr1->set_ks(0.05); 
			phong_ptr1->set_exp(25); 	
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(-45, 45, 40), 50); 
			sphere_ptr1->set_material(phong_ptr1);
			add_object(sphere_ptr1);
	
	
			// box
	
			Matte* matte_ptr = new Matte;				
			matte_ptr->set_ka(0.4); 
			matte_ptr->set_kd(0.3);
			matte_ptr->set_cd(0.8, 0.5, 0);  	// orange
	
			Box* box_ptr1 = new Box(Point3D(20, -101, -100), Point3D(90, 100, 20));
			box_ptr1->set_material(matte_ptr);
			add_object(box_ptr1);

	
			// triangle
	
			Phong*	phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(0.25); 
			phong_ptr2->set_kd(0.5); 
			phong_ptr2->set_cd(0, 0.5, 0.5);     // cyan
			phong_ptr2->set_ks(0.05); 
			phong_ptr2->set_exp(50); 

			Triangle* triangle_ptr1 = new Triangle(Point3D(-110, -85, 80), Point3D(120, 10, 20), Point3D(-40, 50, -30));
			triangle_ptr1->set_material(phong_ptr2);     
			add_object(triangle_ptr1);
	
	
			// ground plane with checker
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(100); 
			checker3D_ptr->set_color1(0.7);  
			checker3D_ptr->set_color2(1.0);

			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker3D_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -101, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 30:
		{
			//9.11c
			int num_samples = 16;	//Here we need more samples to perform antialiasing

			vp.set_hres(300);
			vp.set_vres(300);
			vp.set_samples(num_samples);

			tracer_ptr = new RayCast(this);

			Pinhole* camera_ptr = new Pinhole;
		/*
			// for Figure 9.11(a)	

			camera_ptr->set_eye(0, 0, 500);
			camera_ptr->set_lookat(0);    
			camera_ptr->set_view_distance(500);
			camera_ptr->set_up_vector(1, 1, 0);
		*/
		/*
	
			// for Figure 9.11(b)
	
			camera_ptr->set_eye(500, 0, 0);
			camera_ptr->set_lookat(0);
			camera_ptr->set_view_distance(400);
			camera_ptr->set_up_vector(0, 1, -1);
	
		*/
			// for Figure 9.11(c)
			camera_ptr->set_eye(300, 400, 500);
			camera_ptr->set_lookat(-20, -30, -50);
			camera_ptr->set_view_distance(400);
			camera_ptr->set_roll_angle(145);        // In fact it means Exercise 9.7 but not 9.6...While you can refer to 20.6
	
			camera_ptr->compute_uvw();
			set_camera(camera_ptr);

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(50, 150, 200);
			light_ptr1->scale_radiance(6.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
			// sphere
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(0.5); 
			phong_ptr1->set_kd(0.4);
			phong_ptr1->set_cd(0.5, 0.6, 0);  	// green
			phong_ptr1->set_ks(0.05); 
			phong_ptr1->set_exp(25);
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(-45, 45, 40), 50); 
			sphere_ptr1->set_material(phong_ptr1);
			add_object(sphere_ptr1);	
	
			// box
	
			Matte* matte_ptr = new Matte;				
			matte_ptr->set_ka(0.4); 
			matte_ptr->set_kd(0.3);
			matte_ptr->set_cd(0.8, 0.5, 0);  	// orange
	
			Box* box_ptr1 = new Box(Point3D(20, -101, -100), Point3D(90, 100, 20));
			box_ptr1->set_material(matte_ptr);
			add_object(box_ptr1);

	
			// triangle
	
			Phong*	phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(0.25); 
			phong_ptr2->set_kd(0.5); 
			phong_ptr2->set_cd(0, 0.5, 0.5);     // cyan
			phong_ptr2->set_ks(0.05); 
			phong_ptr2->set_exp(50); 

			Triangle* triangle_ptr1 = new Triangle(Point3D(-110, -85, 80), Point3D(120, 10, 20), Point3D(-40, 50, -30));
			triangle_ptr1->set_material(phong_ptr2);     
			add_object(triangle_ptr1);
	
	
			// ground plane with checker
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(100); 
			checker3D_ptr->set_color1(0.7);  
			checker3D_ptr->set_color2(1.0);

			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker3D_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -101, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 31:
		{
			//10.9a
			int num_samples = 25;  // for Figure 10.9(a)
		//	int num_samples = 1;  //  for Figure 10.9(b)
	
			vp.set_hres(400);                                                               	  		
			vp.set_vres(300);
			vp.set_pixel_size(0.05);
			vp.set_sampler(new MultiJittered(num_samples)); 
			vp.set_max_depth(0);
	
			tracer_ptr = new RayCast(this);
			background_color = white;
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			ThinLens* thin_lens_ptr = new ThinLens;
			thin_lens_ptr->set_sampler(new MultiJittered(num_samples));
			thin_lens_ptr->set_eye(0, 6, 50);  
			thin_lens_ptr->set_lookat(0, 6, 0);
			thin_lens_ptr->set_view_distance(40.0);
			thin_lens_ptr->set_focal_distance(74.0); 
			thin_lens_ptr->set_lens_radius(0.0);      // for Figure 10.9(a)
		//	thin_lens_ptr->set_lens_radius(1.0);	  // for Figure 10.9(b)
			thin_lens_ptr->compute_uvw();     
			set_camera(thin_lens_ptr);
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(1, 1, 1);     
			light_ptr->scale_radiance(7.5); 
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// box 1
	
			Checker3D* checker_ptr1 = new Checker3D;
			checker_ptr1->set_size(2.0);
			checker_ptr1->set_color1(1, 1, 0.33);  		// lemon
			checker_ptr1->set_color2(black);	 
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.5);
			sv_matte_ptr1->set_kd(0.35);
			sv_matte_ptr1->set_cd(checker_ptr1);
	
			Box* box_ptr1 = new Box(Point3D(-9, 0, -1), Point3D(-3, 12, 0));
			box_ptr1->set_material(sv_matte_ptr1);
			add_object(box_ptr1);
		
	
			// box 2
	
			Checker3D* checker_ptr2 = new Checker3D;
			checker_ptr2->set_size(2.0);
			checker_ptr2->set_color1(black);  	
			checker_ptr2->set_color2(0.1, 1, 0.5);	  	// green
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.5);
			sv_matte_ptr2->set_kd(0.35);
			sv_matte_ptr2->set_cd(checker_ptr2);	
	
			Box* box_ptr2 = new Box(Point3D(-3.25, 0, -25), Point3D(4.75, 14, -24));
			box_ptr2->set_material(sv_matte_ptr2);
			add_object(box_ptr2);
	
	
			// box 3
	
			Checker3D* checker_ptr3 = new Checker3D;
			checker_ptr3->set_size(2.0);
			checker_ptr3->set_color1(black);  	
			checker_ptr3->set_color2(1, 0.6, 0.15);	  	// orange
	
			SV_Matte* sv_matte_ptr3 = new SV_Matte;		
			sv_matte_ptr3->set_ka(0.5);
			sv_matte_ptr3->set_kd(0.35);
			sv_matte_ptr3->set_cd(checker_ptr3);
		
			Box* box_ptr3 = new Box(Point3D(8, 0, -49), Point3D(18, 15, -48));
			box_ptr3->set_material(sv_matte_ptr3);
			add_object(box_ptr3);
	

			// ground plane
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(8.0);
			checker_ptr->set_color1(0.25);  			// gray
			checker_ptr->set_color2(white);	 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	

			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);	
			break;
		}
	case 32:
		{
			//10.9b
		//	int num_samples = 25;  // for Figure 10.9(a)
			int num_samples = 1;  //  for Figure 10.9(b)
	
			vp.set_hres(400);                                                               	  		
			vp.set_vres(300);
			vp.set_pixel_size(0.05);
			vp.set_sampler(new MultiJittered(num_samples)); 
			vp.set_max_depth(0);
	
			tracer_ptr = new RayCast(this);
			background_color = white;
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			ThinLens* thin_lens_ptr = new ThinLens;
			thin_lens_ptr->set_sampler(new MultiJittered(num_samples));
			thin_lens_ptr->set_eye(0, 6, 50);  
			thin_lens_ptr->set_lookat(0, 6, 0);
			thin_lens_ptr->set_view_distance(40.0);
			thin_lens_ptr->set_focal_distance(74.0); 
		//	thin_lens_ptr->set_lens_radius(0.0);      // for Figure 10.9(a)
			thin_lens_ptr->set_lens_radius(1.0);	  // for Figure 10.9(b)
			thin_lens_ptr->compute_uvw();     
			set_camera(thin_lens_ptr);
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(1, 1, 1);     
			light_ptr->scale_radiance(7.5); 
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// box 1
	
			Checker3D* checker_ptr1 = new Checker3D;
			checker_ptr1->set_size(2.0);
			checker_ptr1->set_color1(1, 1, 0.33);  		// lemon
			checker_ptr1->set_color2(black);	 
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.5);
			sv_matte_ptr1->set_kd(0.35);
			sv_matte_ptr1->set_cd(checker_ptr1);
	
			Box* box_ptr1 = new Box(Point3D(-9, 0, -1), Point3D(-3, 12, 0));
			box_ptr1->set_material(sv_matte_ptr1);
			add_object(box_ptr1);
		
	
			// box 2
	
			Checker3D* checker_ptr2 = new Checker3D;
			checker_ptr2->set_size(2.0);
			checker_ptr2->set_color1(black);  	
			checker_ptr2->set_color2(0.1, 1, 0.5);	  	// green
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.5);
			sv_matte_ptr2->set_kd(0.35);
			sv_matte_ptr2->set_cd(checker_ptr2);	
	
			Box* box_ptr2 = new Box(Point3D(-3.25, 0, -25), Point3D(4.75, 14, -24));
			box_ptr2->set_material(sv_matte_ptr2);
			add_object(box_ptr2);
	
	
			// box 3
	
			Checker3D* checker_ptr3 = new Checker3D;
			checker_ptr3->set_size(2.0);
			checker_ptr3->set_color1(black);  	
			checker_ptr3->set_color2(1, 0.6, 0.15);	  	// orange
	
			SV_Matte* sv_matte_ptr3 = new SV_Matte;		
			sv_matte_ptr3->set_ka(0.5);
			sv_matte_ptr3->set_kd(0.35);
			sv_matte_ptr3->set_cd(checker_ptr3);
		
			Box* box_ptr3 = new Box(Point3D(8, 0, -49), Point3D(18, 15, -48));
			box_ptr3->set_material(sv_matte_ptr3);
			add_object(box_ptr3);
	

			// ground plane
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(8.0);
			checker_ptr->set_color1(0.25);  			// gray
			checker_ptr->set_color2(white);	 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	

			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);		
			break;
		}
	case 33:
		{
			//10.10a
			int num_samples = 100;
	
			vp.set_hres(400);                                                               	  		
			vp.set_vres(300);
			vp.set_pixel_size(0.05);
			vp.set_sampler(new MultiJittered(num_samples)); 
			vp.set_max_depth(0);
	
			tracer_ptr = new RayCast(this);
			background_color = white;
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			ThinLens* thin_lens_ptr = new ThinLens;
			thin_lens_ptr->set_sampler(new MultiJittered(num_samples));
			thin_lens_ptr->set_eye(0, 6, 50);  
			thin_lens_ptr->set_lookat(0, 6, 0);
			thin_lens_ptr->set_view_distance(40.0);
			thin_lens_ptr->set_focal_distance(50.0);	// for Figure 10.10(a)
		//	thin_lens_ptr->set_focal_distance(74.0);	// for Figure 10.10(b) 
		//	thin_lens_ptr->set_focal_distance(98.0);	// for Figure 10.10(c)
			thin_lens_ptr->set_lens_radius(1.0);
			thin_lens_ptr->compute_uvw();     
			set_camera(thin_lens_ptr);
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(1, 1, 1);     
			light_ptr->scale_radiance(7.5); 
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// box 1
	
			Checker3D* checker_ptr1 = new Checker3D;
			checker_ptr1->set_size(2.0);
			checker_ptr1->set_color1(1, 1, 0.33);  		// lemon
			checker_ptr1->set_color2(black);	 
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.5);
			sv_matte_ptr1->set_kd(0.35);
			sv_matte_ptr1->set_cd(checker_ptr1);
	
			Box* box_ptr1 = new Box(Point3D(-9, 0, -1), Point3D(-3, 12, 0));
			box_ptr1->set_material(sv_matte_ptr1);
			add_object(box_ptr1);
		
	
			// box 2
	
			Checker3D* checker_ptr2 = new Checker3D;
			checker_ptr2->set_size(2.0);
			checker_ptr2->set_color1(black);  	
			checker_ptr2->set_color2(0.1, 1, 0.5);	  	// green
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.5);
			sv_matte_ptr2->set_kd(0.35);
			sv_matte_ptr2->set_cd(checker_ptr2);	
	
			Box* box_ptr2 = new Box(Point3D(-3.25, 0, -25), Point3D(4.75, 14, -24));
			box_ptr2->set_material(sv_matte_ptr2);
			add_object(box_ptr2);
	
	
			// box 3
	
			Checker3D* checker_ptr3 = new Checker3D;
			checker_ptr3->set_size(2.0);
			checker_ptr3->set_color1(black);  	
			checker_ptr3->set_color2(1, 0.6, 0.15);	  	// orange
	
			SV_Matte* sv_matte_ptr3 = new SV_Matte;		
			sv_matte_ptr3->set_ka(0.5);
			sv_matte_ptr3->set_kd(0.35);
			sv_matte_ptr3->set_cd(checker_ptr3);
		
			Box* box_ptr3 = new Box(Point3D(8, 0, -49), Point3D(18, 15, -48));
			box_ptr3->set_material(sv_matte_ptr3);
			add_object(box_ptr3);
	

			// ground plane
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(8.0);
			checker_ptr->set_color1(0.25);  			// gray
			checker_ptr->set_color2(white);	 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	

			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 34:
		{
			//10.10b
			int num_samples = 100;
	
			vp.set_hres(400);                                                               	  		
			vp.set_vres(300);
			vp.set_pixel_size(0.05);
			vp.set_sampler(new MultiJittered(num_samples)); 
			vp.set_max_depth(0);
	
			tracer_ptr = new RayCast(this);
			background_color = white;
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			ThinLens* thin_lens_ptr = new ThinLens;
			thin_lens_ptr->set_sampler(new MultiJittered(num_samples));
			thin_lens_ptr->set_eye(0, 6, 50);  
			thin_lens_ptr->set_lookat(0, 6, 0);
			thin_lens_ptr->set_view_distance(40.0);
		//	thin_lens_ptr->set_focal_distance(50.0);	// for Figure 10.10(a)
			thin_lens_ptr->set_focal_distance(74.0);	// for Figure 10.10(b) 
		//	thin_lens_ptr->set_focal_distance(98.0);	// for Figure 10.10(c)
			thin_lens_ptr->set_lens_radius(1.0);
			thin_lens_ptr->compute_uvw();     
			set_camera(thin_lens_ptr);
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(1, 1, 1);     
			light_ptr->scale_radiance(7.5); 
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// box 1
	
			Checker3D* checker_ptr1 = new Checker3D;
			checker_ptr1->set_size(2.0);
			checker_ptr1->set_color1(1, 1, 0.33);  		// lemon
			checker_ptr1->set_color2(black);	 
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.5);
			sv_matte_ptr1->set_kd(0.35);
			sv_matte_ptr1->set_cd(checker_ptr1);
	
			Box* box_ptr1 = new Box(Point3D(-9, 0, -1), Point3D(-3, 12, 0));
			box_ptr1->set_material(sv_matte_ptr1);
			add_object(box_ptr1);
		
	
			// box 2
	
			Checker3D* checker_ptr2 = new Checker3D;
			checker_ptr2->set_size(2.0);
			checker_ptr2->set_color1(black);  	
			checker_ptr2->set_color2(0.1, 1, 0.5);	  	// green
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.5);
			sv_matte_ptr2->set_kd(0.35);
			sv_matte_ptr2->set_cd(checker_ptr2);	
	
			Box* box_ptr2 = new Box(Point3D(-3.25, 0, -25), Point3D(4.75, 14, -24));
			box_ptr2->set_material(sv_matte_ptr2);
			add_object(box_ptr2);
	
	
			// box 3
	
			Checker3D* checker_ptr3 = new Checker3D;
			checker_ptr3->set_size(2.0);
			checker_ptr3->set_color1(black);  	
			checker_ptr3->set_color2(1, 0.6, 0.15);	  	// orange
	
			SV_Matte* sv_matte_ptr3 = new SV_Matte;		
			sv_matte_ptr3->set_ka(0.5);
			sv_matte_ptr3->set_kd(0.35);
			sv_matte_ptr3->set_cd(checker_ptr3);
		
			Box* box_ptr3 = new Box(Point3D(8, 0, -49), Point3D(18, 15, -48));
			box_ptr3->set_material(sv_matte_ptr3);
			add_object(box_ptr3);
	

			// ground plane
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(8.0);
			checker_ptr->set_color1(0.25);  			// gray
			checker_ptr->set_color2(white);	 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	

			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 35:
		{
			//10.10c
			int num_samples = 100;
	
			vp.set_hres(400);                                                               	  		
			vp.set_vres(300);
			vp.set_pixel_size(0.05);
			vp.set_sampler(new MultiJittered(num_samples)); 
			vp.set_max_depth(0);
	
			tracer_ptr = new RayCast(this);
			background_color = white;
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			ThinLens* thin_lens_ptr = new ThinLens;
			thin_lens_ptr->set_sampler(new MultiJittered(num_samples));
			thin_lens_ptr->set_eye(0, 6, 50);  
			thin_lens_ptr->set_lookat(0, 6, 0);
			thin_lens_ptr->set_view_distance(40.0);
		//	thin_lens_ptr->set_focal_distance(50.0);	// for Figure 10.10(a)
		//	thin_lens_ptr->set_focal_distance(74.0);	// for Figure 10.10(b) 
			thin_lens_ptr->set_focal_distance(98.0);	// for Figure 10.10(c)
			thin_lens_ptr->set_lens_radius(1.0);
			thin_lens_ptr->compute_uvw();     
			set_camera(thin_lens_ptr);
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(1, 1, 1);     
			light_ptr->scale_radiance(7.5); 
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// box 1
	
			Checker3D* checker_ptr1 = new Checker3D;
			checker_ptr1->set_size(2.0);
			checker_ptr1->set_color1(1, 1, 0.33);  		// lemon
			checker_ptr1->set_color2(black);	 
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.5);
			sv_matte_ptr1->set_kd(0.35);
			sv_matte_ptr1->set_cd(checker_ptr1);
	
			Box* box_ptr1 = new Box(Point3D(-9, 0, -1), Point3D(-3, 12, 0));
			box_ptr1->set_material(sv_matte_ptr1);
			add_object(box_ptr1);
		
	
			// box 2
	
			Checker3D* checker_ptr2 = new Checker3D;
			checker_ptr2->set_size(2.0);
			checker_ptr2->set_color1(black);  	
			checker_ptr2->set_color2(0.1, 1, 0.5);	  	// green
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.5);
			sv_matte_ptr2->set_kd(0.35);
			sv_matte_ptr2->set_cd(checker_ptr2);	
	
			Box* box_ptr2 = new Box(Point3D(-3.25, 0, -25), Point3D(4.75, 14, -24));
			box_ptr2->set_material(sv_matte_ptr2);
			add_object(box_ptr2);
	
	
			// box 3
	
			Checker3D* checker_ptr3 = new Checker3D;
			checker_ptr3->set_size(2.0);
			checker_ptr3->set_color1(black);  	
			checker_ptr3->set_color2(1, 0.6, 0.15);	  	// orange
	
			SV_Matte* sv_matte_ptr3 = new SV_Matte;		
			sv_matte_ptr3->set_ka(0.5);
			sv_matte_ptr3->set_kd(0.35);
			sv_matte_ptr3->set_cd(checker_ptr3);
		
			Box* box_ptr3 = new Box(Point3D(8, 0, -49), Point3D(18, 15, -48));
			box_ptr3->set_material(sv_matte_ptr3);
			add_object(box_ptr3);
	

			// ground plane
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(8.0);
			checker_ptr->set_color1(0.25);  			// gray
			checker_ptr->set_color2(white);	 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	

			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 36:
		{
			//10.11a
			int num_samples = 100;
	
			vp.set_hres(400);                                                               	  		
			vp.set_vres(300);
			vp.set_pixel_size(0.05);
			vp.set_sampler(new MultiJittered(num_samples)); 
			vp.set_max_depth(0);
	
			tracer_ptr = new RayCast(this);
			background_color = white;
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			ThinLens* thin_lens_ptr = new ThinLens;
			thin_lens_ptr->set_sampler(new MultiJittered(num_samples));
			thin_lens_ptr->set_eye(0, 6, 50);  
			thin_lens_ptr->set_lookat(0, 6, 0);
			thin_lens_ptr->set_view_distance(40.0);
	
			thin_lens_ptr->set_focal_distance(98.0);	// for Figure 10.11(a)
			thin_lens_ptr->set_lens_radius(3.0);		// for Figure 10.11(a)
	
		//	thin_lens_ptr->set_focal_distance(100000);	// for Figure 10.11(a)?
		//	thin_lens_ptr->set_lens_radius(0.25);		// for Figure 10.11(a)?
	
			thin_lens_ptr->compute_uvw();     
			set_camera(thin_lens_ptr);
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(1, 1, 1);     
			light_ptr->scale_radiance(7.5); 
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// box 1
	
			Checker3D* checker_ptr1 = new Checker3D;
			checker_ptr1->set_size(2.0);
			checker_ptr1->set_color1(1, 1, 0.33);  		// lemon
			checker_ptr1->set_color2(black);	 
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.5);
			sv_matte_ptr1->set_kd(0.35);
			sv_matte_ptr1->set_cd(checker_ptr1);
	
			Box* box_ptr1 = new Box(Point3D(-9, 0, -1), Point3D(-3, 12, 0));
			box_ptr1->set_material(sv_matte_ptr1);
			add_object(box_ptr1);
		
	
			// box 2
	
			Checker3D* checker_ptr2 = new Checker3D;
			checker_ptr2->set_size(2.0);
			checker_ptr2->set_color1(black);  	
			checker_ptr2->set_color2(0.1, 1, 0.5);	  	// green
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.5);
			sv_matte_ptr2->set_kd(0.35);
			sv_matte_ptr2->set_cd(checker_ptr2);	
	
			Box* box_ptr2 = new Box(Point3D(-3.25, 0, -25), Point3D(4.75, 14, -24));
			box_ptr2->set_material(sv_matte_ptr2);
			add_object(box_ptr2);
	
	
			// box 3
	
			Checker3D* checker_ptr3 = new Checker3D;
			checker_ptr3->set_size(2.0);
			checker_ptr3->set_color1(black);  	
			checker_ptr3->set_color2(1, 0.6, 0.15);	  	// orange
	
			SV_Matte* sv_matte_ptr3 = new SV_Matte;		
			sv_matte_ptr3->set_ka(0.5);
			sv_matte_ptr3->set_kd(0.35);
			sv_matte_ptr3->set_cd(checker_ptr3);
		
			Box* box_ptr3 = new Box(Point3D(8, 0, -49), Point3D(18, 15, -48));
			box_ptr3->set_material(sv_matte_ptr3);
			add_object(box_ptr3);
	

			// ground plane
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(8.0);
			checker_ptr->set_color1(0.25);  			// gray
			checker_ptr->set_color2(white);	 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	

			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 37:
		{
			//10.11b
			int num_samples = 100;
	
			vp.set_hres(400);                                                               	  		
			vp.set_vres(300);
			vp.set_pixel_size(0.05);
			vp.set_sampler(new MultiJittered(num_samples)); 
			vp.set_max_depth(0);
	
			tracer_ptr = new RayCast(this);
			background_color = white;
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			ThinLens* thin_lens_ptr = new ThinLens;
			thin_lens_ptr->set_sampler(new MultiJittered(num_samples));
			thin_lens_ptr->set_eye(0, 6, 50);  
			thin_lens_ptr->set_lookat(0, 6, 0);
			thin_lens_ptr->set_view_distance(40.0);
	
			//thin_lens_ptr->set_focal_distance(98.0);	// for Figure 10.11(a)
			//thin_lens_ptr->set_lens_radius(3.0);		// for Figure 10.11(a)
	
			thin_lens_ptr->set_focal_distance(100000);	// for Figure 10.11(b)?
			thin_lens_ptr->set_lens_radius(0.25);		// for Figure 10.11(b)?
	
			thin_lens_ptr->compute_uvw();     
			set_camera(thin_lens_ptr);
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(1, 1, 1);     
			light_ptr->scale_radiance(7.5); 
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// box 1
	
			Checker3D* checker_ptr1 = new Checker3D;
			checker_ptr1->set_size(2.0);
			checker_ptr1->set_color1(1, 1, 0.33);  		// lemon
			checker_ptr1->set_color2(black);	 
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.5);
			sv_matte_ptr1->set_kd(0.35);
			sv_matte_ptr1->set_cd(checker_ptr1);
	
			Box* box_ptr1 = new Box(Point3D(-9, 0, -1), Point3D(-3, 12, 0));
			box_ptr1->set_material(sv_matte_ptr1);
			add_object(box_ptr1);
		
	
			// box 2
	
			Checker3D* checker_ptr2 = new Checker3D;
			checker_ptr2->set_size(2.0);
			checker_ptr2->set_color1(black);  	
			checker_ptr2->set_color2(0.1, 1, 0.5);	  	// green
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.5);
			sv_matte_ptr2->set_kd(0.35);
			sv_matte_ptr2->set_cd(checker_ptr2);	
	
			Box* box_ptr2 = new Box(Point3D(-3.25, 0, -25), Point3D(4.75, 14, -24));
			box_ptr2->set_material(sv_matte_ptr2);
			add_object(box_ptr2);
	
	
			// box 3
	
			Checker3D* checker_ptr3 = new Checker3D;
			checker_ptr3->set_size(2.0);
			checker_ptr3->set_color1(black);  	
			checker_ptr3->set_color2(1, 0.6, 0.15);	  	// orange
	
			SV_Matte* sv_matte_ptr3 = new SV_Matte;		
			sv_matte_ptr3->set_ka(0.5);
			sv_matte_ptr3->set_kd(0.35);
			sv_matte_ptr3->set_cd(checker_ptr3);
		
			Box* box_ptr3 = new Box(Point3D(8, 0, -49), Point3D(18, 15, -48));
			box_ptr3->set_material(sv_matte_ptr3);
			add_object(box_ptr3);
	

			// ground plane
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(8.0);
			checker_ptr->set_color1(0.25);  			// gray
			checker_ptr->set_color2(white);	 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	

			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 38:
		{
			//10.12
			int num_samples = 100;
	
			vp.set_hres(450);                                                               	  		
			vp.set_vres(300);
			vp.set_pixel_size(0.05);
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
	
			tracer_ptr = new Whitted(this);

			background_color = white;
	
			ThinLens* thin_lens_ptr = new ThinLens;
			thin_lens_ptr->set_sampler(new MultiJittered(num_samples));

			Point3D eye(15, 25, 50); 
			Point3D lookat(0, 8, 0); 
			Vector3D direction(lookat - eye); 
			direction.normalize();
			float fd = 100;
		
			thin_lens_ptr->set_eye(15, 25, 50);  
			thin_lens_ptr->set_lookat(0, 8, 0);
			thin_lens_ptr->set_view_distance(30);
			thin_lens_ptr->set_focal_distance(100); 
			thin_lens_ptr->set_lens_radius(1);
			thin_lens_ptr->compute_uvw();     
			set_camera(thin_lens_ptr);
	

			// directional light 
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(1, 1, -0.5);      
			light_ptr->scale_radiance(4.0);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	

			Reflective* reflective_ptr = new Reflective;
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(0.2, 0.9, 0.75);
	
			Box* box_ptr = new Box(Point3D(-17, 0, -1), Point3D(13, 19, 0));
			box_ptr->set_material(reflective_ptr);
			add_object(box_ptr);
	
	
			// ground plane
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(8.0);
			checker_ptr->set_color1(0.25);  			// gray
			checker_ptr->set_color2(white);	 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.75);
			sv_matte_ptr->set_cd(checker_ptr);	

			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
	
			// focal plane plane
	
			Matte* matte_ptr = new Matte;
			matte_ptr->set_cd(1, 0, 0);
			matte_ptr->set_ka(0.5);
			matte_ptr->set_kd(0.5);
	
			Point3D point = eye + direction * fd;
			Normal normal = -direction;
	
			Plane* plane_ptr2 = new Plane(point, normal); 
			plane_ptr2->set_material(matte_ptr);
			add_object(plane_ptr2);
			break;
		}
	case 39:
		{
			//10.13
			int num_samples = 1; 
			vp.set_hres(400);                                                               	  		
			vp.set_vres(300);
			vp.set_pixel_size(0.05);
			vp.set_sampler(new Regular(num_samples)); 
	
			tracer_ptr = new RayCast(this);
			background_color = white;
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			ThinLens* thin_lens_ptr = new ThinLens;
			thin_lens_ptr->set_sampler(new Regular(num_samples));
			thin_lens_ptr->set_eye(0, 6, 50);  
			thin_lens_ptr->set_lookat(0, 6, 0);
			thin_lens_ptr->set_view_distance(40.0);
			thin_lens_ptr->set_focal_distance(74.0); 
			thin_lens_ptr->set_lens_radius(1.0);	 
			thin_lens_ptr->compute_uvw();     
			set_camera(thin_lens_ptr);
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(1, 1, 1);     
			light_ptr->scale_radiance(7.5); 
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// box 1
	
			Checker3D* checker_ptr1 = new Checker3D;
			checker_ptr1->set_size(2.0);
			checker_ptr1->set_color1(1, 1, 0.33);  		// lemon
			checker_ptr1->set_color2(black);	 
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.5);
			sv_matte_ptr1->set_kd(0.35);
			sv_matte_ptr1->set_cd(checker_ptr1);
	
			Box* box_ptr1 = new Box(Point3D(-9, 0, -1), Point3D(-3, 12, 0));
			box_ptr1->set_material(sv_matte_ptr1);
			add_object(box_ptr1);
		
	
			// box 2
	
			Checker3D* checker_ptr2 = new Checker3D;
			checker_ptr2->set_size(2.0);
			checker_ptr2->set_color1(black);  	
			checker_ptr2->set_color2(0.1, 1, 0.5);	  	// green
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.5);
			sv_matte_ptr2->set_kd(0.35);
			sv_matte_ptr2->set_cd(checker_ptr2);	
	
			Box* box_ptr2 = new Box(Point3D(-3.25, 0, -25), Point3D(4.75, 14, -24));
			box_ptr2->set_material(sv_matte_ptr2);
			add_object(box_ptr2);
	
	
			// box 3
	
			Checker3D* checker_ptr3 = new Checker3D;
			checker_ptr3->set_size(2.0);
			checker_ptr3->set_color1(black);  	
			checker_ptr3->set_color2(1, 0.6, 0.15);	  	// orange
	
			SV_Matte* sv_matte_ptr3 = new SV_Matte;		
			sv_matte_ptr3->set_ka(0.5);
			sv_matte_ptr3->set_kd(0.35);
			sv_matte_ptr3->set_cd(checker_ptr3);
		
			Box* box_ptr3 = new Box(Point3D(8, 0, -49), Point3D(18, 15, -48));
			box_ptr3->set_material(sv_matte_ptr3);
			add_object(box_ptr3);
	

			// ground plane
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(8.0);
			checker_ptr->set_color1(0.25);  			// gray
			checker_ptr->set_color2(white);	 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	

			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 40:
		{
			//11.07a
			//It's very pity because I cannot find CloudSmall.ppm in Author's website...Here we give a instead and It' OK after all
			if( !CheckFile(QString(ppmfile+"MorningSky.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);

			tracer_ptr = new RayCast(this);
	
			// pinhole camera for Figure 11.7(a)
			
			Pinhole* pinHole_ptr = new Pinhole;
			pinHole_ptr->set_eye(250, 300, 150); 
			pinHole_ptr->set_lookat(-20, 300, -110);  
			pinHole_ptr->set_view_distance(250);
			pinHole_ptr->compute_uvw();  
			set_camera(pinHole_ptr);
		
	
			// fisheye camera for the other parts
	
			FishEye* fisheye_ptr = new FishEye;
	
			// for parts (b), (c), (d)
	
			fisheye_ptr->set_eye(250, 300, 150);
			fisheye_ptr->set_lookat(-20, 300, -110);
			fisheye_ptr->set_fov(120);  // part (b)
		//	fisheye_ptr->set_fov(180);  // part (c)
		//	fisheye_ptr->set_fov(360);  // part (d)

		/*	
			// for part (e)
	
			fisheye_ptr->set_eye(250, 450, 150); 
			fisheye_ptr->set_lookat(-20, 250, -110);  
			fisheye_ptr->set_fov(360);
	
		*/


		/*	
			// for part (f)
			// for this image the skydome is the only object in the scene
			// you need to comment out the two statements:
			// add_object(grid_ptr);
			// add_object(plane_ptr);
	
			fisheye_ptr->set_eye(0, 0, 0);     
			fisheye_ptr->set_lookat(0, 1, 0);
			fisheye_ptr->set_fov(180);
		*/	
		
			fisheye_ptr->compute_uvw();  
		//	set_camera(fisheye_ptr);

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(150, 200, 65);  
			light_ptr1->scale_radiance(5.25);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
			// box materials
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_cd(0, 0.5, 0.5);     // cyan
			matte_ptr1->set_ka(0.4); 
			matte_ptr1->set_kd(0.5); 
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_cd(1, 0, 0);     	  // red
			matte_ptr2->set_ka(0.4); 
			matte_ptr2->set_kd(0.5);  
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_cd(0.5, 0.6, 0);     // green
			matte_ptr3->set_ka(0.4); 
			matte_ptr3->set_kd(0.5); 
	
	
			// Construct rows of boxes stored in a grid
		
			Grid* grid_ptr = new Grid;
	
			// first row
	
			int num_boxes = 40;
			float wx = 50;
			float wz = 50;
			float h = 150;
			float s = 100;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx, 0, -(j + 1) * wz - j * s), 
										Point3D(0, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr1);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// second row
	
			h = 300;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx -wx - s, 0, -(j + 1) * wz - j * s), 
										Point3D(-wx - s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr2);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// third row
	
			h = 850; 
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx - 2 * wx - 2 * s, 0, -(j + 1) * wz - j * s), 
										Point3D(-2 * wx - 2 * s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr3);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// a column
	
			h = 150;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-3 * (wx + s) - (j + 1) * wz - j * s, 0, -wx), 
										Point3D(-3 * (wx + s) - j * wz - j * s, h, 0));
				box_ptr->set_material(matte_ptr1);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
	
			// ground plane with checker
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(2 * wx); 
			checker_ptr->set_color1(0.7);  
			checker_ptr->set_color2(white);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.20);
			sv_matte_ptr1->set_kd(0.50); 
			sv_matte_ptr1->set_cd(checker_ptr);	
			Plane* plane_ptr = new Plane(Point3D(0, 1, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr1);
			add_object(plane_ptr);

	
			// skydome with clouds
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"MorningSky.ppm").toLatin1().data());

			SphericalMap* spherical_map_ptr = new SphericalMap;
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(spherical_map_ptr);
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(1);
			sv_matte_ptr2->set_kd(0.85);
			sv_matte_ptr2->set_cd(image_texture_ptr);	
	
			Instance* sphere_ptr1 = new Instance(new Sphere); 
			sphere_ptr1->scale(1000000);
			sphere_ptr1->set_material(sv_matte_ptr2);
			add_object(sphere_ptr1);
			break;
		}
	case 41:
		{
			//11.07b
			//It's very pity because I cannot find CloudSmall.ppm in Author's website...Here we give a instead and It' OK after all
			if( !CheckFile(QString(ppmfile+"MorningSky.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);

			tracer_ptr = new RayCast(this);
	
			// pinhole camera for Figure 11.7(a)
			
			Pinhole* pinHole_ptr = new Pinhole;
			pinHole_ptr->set_eye(250, 300, 150); 
			pinHole_ptr->set_lookat(-20, 300, -110);  
			pinHole_ptr->set_view_distance(250);
			pinHole_ptr->compute_uvw();  
		//	set_camera(pinHole_ptr);
		
	
			// fisheye camera for the other parts
	
			FishEye* fisheye_ptr = new FishEye;
	
			// for parts (b), (c), (d)
	
			fisheye_ptr->set_eye(250, 300, 150);
			fisheye_ptr->set_lookat(-20, 300, -110);
			fisheye_ptr->set_fov(120);  // part (b)
		//	fisheye_ptr->set_fov(180);  // part (c)
		//	fisheye_ptr->set_fov(360);  // part (d)

		/*	
			// for part (e)
	
			fisheye_ptr->set_eye(250, 450, 150); 
			fisheye_ptr->set_lookat(-20, 250, -110);  
			fisheye_ptr->set_fov(360);
	
		*/


		/*	
			// for part (f)
			// for this image the skydome is the only object in the scene
			// you need to comment out the two statements:
			// add_object(grid_ptr);
			// add_object(plane_ptr);
	
			fisheye_ptr->set_eye(0, 0, 0);     
			fisheye_ptr->set_lookat(0, 1, 0);
			fisheye_ptr->set_fov(180);
		*/	
		
			fisheye_ptr->compute_uvw();  
			set_camera(fisheye_ptr);

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(150, 200, 65);  
			light_ptr1->scale_radiance(5.25);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
			// box materials
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_cd(0, 0.5, 0.5);     // cyan
			matte_ptr1->set_ka(0.4); 
			matte_ptr1->set_kd(0.5); 
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_cd(1, 0, 0);     	  // red
			matte_ptr2->set_ka(0.4); 
			matte_ptr2->set_kd(0.5);  
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_cd(0.5, 0.6, 0);     // green
			matte_ptr3->set_ka(0.4); 
			matte_ptr3->set_kd(0.5); 
	
	
			// Construct rows of boxes stored in a grid
		
			Grid* grid_ptr = new Grid;
	
			// first row
	
			int num_boxes = 40;
			float wx = 50;
			float wz = 50;
			float h = 150;
			float s = 100;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx, 0, -(j + 1) * wz - j * s), 
										Point3D(0, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr1);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// second row
	
			h = 300;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx -wx - s, 0, -(j + 1) * wz - j * s), 
										Point3D(-wx - s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr2);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// third row
	
			h = 850; 
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx - 2 * wx - 2 * s, 0, -(j + 1) * wz - j * s), 
										Point3D(-2 * wx - 2 * s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr3);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// a column
	
			h = 150;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-3 * (wx + s) - (j + 1) * wz - j * s, 0, -wx), 
										Point3D(-3 * (wx + s) - j * wz - j * s, h, 0));
				box_ptr->set_material(matte_ptr1);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
	
			// ground plane with checker
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(2 * wx); 
			checker_ptr->set_color1(0.7);  
			checker_ptr->set_color2(white);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.20);
			sv_matte_ptr1->set_kd(0.50); 
			sv_matte_ptr1->set_cd(checker_ptr);	
			Plane* plane_ptr = new Plane(Point3D(0, 1, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr1);
			add_object(plane_ptr);

	
			// skydome with clouds
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"MorningSky.ppm").toLatin1().data());

			SphericalMap* spherical_map_ptr = new SphericalMap;
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(spherical_map_ptr);
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(1);
			sv_matte_ptr2->set_kd(0.85);
			sv_matte_ptr2->set_cd(image_texture_ptr);	
	
			Instance* sphere_ptr1 = new Instance(new Sphere); 
			sphere_ptr1->scale(1000000);
			sphere_ptr1->set_material(sv_matte_ptr2);
			add_object(sphere_ptr1);
			break;
		}
	case 42:
		{
			//11.07c
			//It's very pity because I cannot find CloudSmall.ppm in Author's website...Here we give a instead and It' OK after all
			if( !CheckFile(QString(ppmfile+"MorningSky.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);

			tracer_ptr = new RayCast(this);
	
			// pinhole camera for Figure 11.7(a)
			
			Pinhole* pinHole_ptr = new Pinhole;
			pinHole_ptr->set_eye(250, 300, 150); 
			pinHole_ptr->set_lookat(-20, 300, -110);  
			pinHole_ptr->set_view_distance(250);
			pinHole_ptr->compute_uvw();  
		//	set_camera(pinHole_ptr);
		
	
			// fisheye camera for the other parts
	
			FishEye* fisheye_ptr = new FishEye;
	
			// for parts (b), (c), (d)
	
			fisheye_ptr->set_eye(250, 300, 150);
			fisheye_ptr->set_lookat(-20, 300, -110);
		//	fisheye_ptr->set_fov(120);  // part (b)
			fisheye_ptr->set_fov(180);  // part (c)
		//	fisheye_ptr->set_fov(360);  // part (d)

		/*	
			// for part (e)
	
			fisheye_ptr->set_eye(250, 450, 150); 
			fisheye_ptr->set_lookat(-20, 250, -110);  
			fisheye_ptr->set_fov(360);
	
		*/


		/*	
			// for part (f)
			// for this image the skydome is the only object in the scene
			// you need to comment out the two statements:
			// add_object(grid_ptr);
			// add_object(plane_ptr);
	
			fisheye_ptr->set_eye(0, 0, 0);     
			fisheye_ptr->set_lookat(0, 1, 0);
			fisheye_ptr->set_fov(180);
		*/	
		
			fisheye_ptr->compute_uvw();  
			set_camera(fisheye_ptr);

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(150, 200, 65);  
			light_ptr1->scale_radiance(5.25);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
			// box materials
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_cd(0, 0.5, 0.5);     // cyan
			matte_ptr1->set_ka(0.4); 
			matte_ptr1->set_kd(0.5); 
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_cd(1, 0, 0);     	  // red
			matte_ptr2->set_ka(0.4); 
			matte_ptr2->set_kd(0.5);  
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_cd(0.5, 0.6, 0);     // green
			matte_ptr3->set_ka(0.4); 
			matte_ptr3->set_kd(0.5); 
	
	
			// Construct rows of boxes stored in a grid
		
			Grid* grid_ptr = new Grid;
	
			// first row
	
			int num_boxes = 40;
			float wx = 50;
			float wz = 50;
			float h = 150;
			float s = 100;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx, 0, -(j + 1) * wz - j * s), 
										Point3D(0, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr1);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// second row
	
			h = 300;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx -wx - s, 0, -(j + 1) * wz - j * s), 
										Point3D(-wx - s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr2);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// third row
	
			h = 850; 
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx - 2 * wx - 2 * s, 0, -(j + 1) * wz - j * s), 
										Point3D(-2 * wx - 2 * s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr3);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// a column
	
			h = 150;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-3 * (wx + s) - (j + 1) * wz - j * s, 0, -wx), 
										Point3D(-3 * (wx + s) - j * wz - j * s, h, 0));
				box_ptr->set_material(matte_ptr1);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
	
			// ground plane with checker
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(2 * wx); 
			checker_ptr->set_color1(0.7);  
			checker_ptr->set_color2(white);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.20);
			sv_matte_ptr1->set_kd(0.50); 
			sv_matte_ptr1->set_cd(checker_ptr);	
			Plane* plane_ptr = new Plane(Point3D(0, 1, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr1);
			add_object(plane_ptr);

	
			// skydome with clouds
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"MorningSky.ppm").toLatin1().data());

			SphericalMap* spherical_map_ptr = new SphericalMap;
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(spherical_map_ptr);
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(1);
			sv_matte_ptr2->set_kd(0.85);
			sv_matte_ptr2->set_cd(image_texture_ptr);	
	
			Instance* sphere_ptr1 = new Instance(new Sphere); 
			sphere_ptr1->scale(1000000);
			sphere_ptr1->set_material(sv_matte_ptr2);
			add_object(sphere_ptr1);
			break;
		}
	case 43:
		{
			//11.07d
			//It's very pity because I cannot find CloudSmall.ppm in Author's website...Here we give a instead and It' OK after all
			if( !CheckFile(QString(ppmfile+"MorningSky.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);

			tracer_ptr = new RayCast(this);
	
			// pinhole camera for Figure 11.7(a)
			
			Pinhole* pinHole_ptr = new Pinhole;
			pinHole_ptr->set_eye(250, 300, 150); 
			pinHole_ptr->set_lookat(-20, 300, -110);  
			pinHole_ptr->set_view_distance(250);
			pinHole_ptr->compute_uvw();  
		//	set_camera(pinHole_ptr);
		
	
			// fisheye camera for the other parts
	
			FishEye* fisheye_ptr = new FishEye;
	
			// for parts (b), (c), (d)
	
			fisheye_ptr->set_eye(250, 300, 150);
			fisheye_ptr->set_lookat(-20, 300, -110);
		//	fisheye_ptr->set_fov(120);  // part (b)
		//	fisheye_ptr->set_fov(180);  // part (c)
			fisheye_ptr->set_fov(360);  // part (d)

		/*	
			// for part (e)
	
			fisheye_ptr->set_eye(250, 450, 150); 
			fisheye_ptr->set_lookat(-20, 250, -110);  
			fisheye_ptr->set_fov(360);
	
		*/


		/*	
			// for part (f)
			// for this image the skydome is the only object in the scene
			// you need to comment out the two statements:
			// add_object(grid_ptr);
			// add_object(plane_ptr);
	
			fisheye_ptr->set_eye(0, 0, 0);     
			fisheye_ptr->set_lookat(0, 1, 0);
			fisheye_ptr->set_fov(180);
		*/	
		
			fisheye_ptr->compute_uvw();  
			set_camera(fisheye_ptr);

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(150, 200, 65);  
			light_ptr1->scale_radiance(5.25);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
			// box materials
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_cd(0, 0.5, 0.5);     // cyan
			matte_ptr1->set_ka(0.4); 
			matte_ptr1->set_kd(0.5); 
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_cd(1, 0, 0);     	  // red
			matte_ptr2->set_ka(0.4); 
			matte_ptr2->set_kd(0.5);  
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_cd(0.5, 0.6, 0);     // green
			matte_ptr3->set_ka(0.4); 
			matte_ptr3->set_kd(0.5); 
	
	
			// Construct rows of boxes stored in a grid
		
			Grid* grid_ptr = new Grid;
	
			// first row
	
			int num_boxes = 40;
			float wx = 50;
			float wz = 50;
			float h = 150;
			float s = 100;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx, 0, -(j + 1) * wz - j * s), 
										Point3D(0, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr1);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// second row
	
			h = 300;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx -wx - s, 0, -(j + 1) * wz - j * s), 
										Point3D(-wx - s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr2);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// third row
	
			h = 850; 
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx - 2 * wx - 2 * s, 0, -(j + 1) * wz - j * s), 
										Point3D(-2 * wx - 2 * s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr3);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// a column
	
			h = 150;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-3 * (wx + s) - (j + 1) * wz - j * s, 0, -wx), 
										Point3D(-3 * (wx + s) - j * wz - j * s, h, 0));
				box_ptr->set_material(matte_ptr1);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
	
			// ground plane with checker
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(2 * wx); 
			checker_ptr->set_color1(0.7);  
			checker_ptr->set_color2(white);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.20);
			sv_matte_ptr1->set_kd(0.50); 
			sv_matte_ptr1->set_cd(checker_ptr);	
			Plane* plane_ptr = new Plane(Point3D(0, 1, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr1);
			add_object(plane_ptr);

	
			// skydome with clouds
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"MorningSky.ppm").toLatin1().data());

			SphericalMap* spherical_map_ptr = new SphericalMap;
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(spherical_map_ptr);
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(1);
			sv_matte_ptr2->set_kd(0.85);
			sv_matte_ptr2->set_cd(image_texture_ptr);	
	
			Instance* sphere_ptr1 = new Instance(new Sphere); 
			sphere_ptr1->scale(1000000);
			sphere_ptr1->set_material(sv_matte_ptr2);
			add_object(sphere_ptr1);
			break;
		}
	case 44:
		{
			//11.07e
			//It's very pity because I cannot find CloudSmall.ppm in Author's website...Here we give a instead and It' OK after all
			if( !CheckFile(QString(ppmfile+"MorningSky.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);

			tracer_ptr = new RayCast(this);
	
			// pinhole camera for Figure 11.7(a)
			
			Pinhole* pinHole_ptr = new Pinhole;
			pinHole_ptr->set_eye(250, 300, 150); 
			pinHole_ptr->set_lookat(-20, 300, -110);  
			pinHole_ptr->set_view_distance(250);
			pinHole_ptr->compute_uvw();  
		//	set_camera(pinHole_ptr);
		
	
			// fisheye camera for the other parts
	
			FishEye* fisheye_ptr = new FishEye;
	
			// for parts (b), (c), (d)
	
			fisheye_ptr->set_eye(250, 300, 150);
			fisheye_ptr->set_lookat(-20, 300, -110);
		//	fisheye_ptr->set_fov(120);  // part (b)
		//	fisheye_ptr->set_fov(180);  // part (c)
		//	fisheye_ptr->set_fov(360);  // part (d)
	
			// for part (e)
	
			fisheye_ptr->set_eye(250, 450, 150); 
			fisheye_ptr->set_lookat(-20, 250, -110);  
			fisheye_ptr->set_fov(360);


		/*	
			// for part (f)
			// for this image the skydome is the only object in the scene
			// you need to comment out the two statements:
			// add_object(grid_ptr);
			// add_object(plane_ptr);
	
			fisheye_ptr->set_eye(0, 0, 0);     
			fisheye_ptr->set_lookat(0, 1, 0);
			fisheye_ptr->set_fov(180);
		*/	
		
			fisheye_ptr->compute_uvw();  
			set_camera(fisheye_ptr);

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(150, 200, 65);  
			light_ptr1->scale_radiance(5.25);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
			// box materials
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_cd(0, 0.5, 0.5);     // cyan
			matte_ptr1->set_ka(0.4); 
			matte_ptr1->set_kd(0.5); 
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_cd(1, 0, 0);     	  // red
			matte_ptr2->set_ka(0.4); 
			matte_ptr2->set_kd(0.5);  
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_cd(0.5, 0.6, 0);     // green
			matte_ptr3->set_ka(0.4); 
			matte_ptr3->set_kd(0.5); 
	
	
			// Construct rows of boxes stored in a grid
		
			Grid* grid_ptr = new Grid;
	
			// first row
	
			int num_boxes = 40;
			float wx = 50;
			float wz = 50;
			float h = 150;
			float s = 100;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx, 0, -(j + 1) * wz - j * s), 
										Point3D(0, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr1);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// second row
	
			h = 300;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx -wx - s, 0, -(j + 1) * wz - j * s), 
										Point3D(-wx - s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr2);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// third row
	
			h = 850; 
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx - 2 * wx - 2 * s, 0, -(j + 1) * wz - j * s), 
										Point3D(-2 * wx - 2 * s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr3);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// a column
	
			h = 150;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-3 * (wx + s) - (j + 1) * wz - j * s, 0, -wx), 
										Point3D(-3 * (wx + s) - j * wz - j * s, h, 0));
				box_ptr->set_material(matte_ptr1);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
	
			// ground plane with checker
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(2 * wx); 
			checker_ptr->set_color1(0.7);  
			checker_ptr->set_color2(white);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.20);
			sv_matte_ptr1->set_kd(0.50); 
			sv_matte_ptr1->set_cd(checker_ptr);	
			Plane* plane_ptr = new Plane(Point3D(0, 1, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr1);
			add_object(plane_ptr);

	
			// skydome with clouds
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"MorningSky.ppm").toLatin1().data());

			SphericalMap* spherical_map_ptr = new SphericalMap;
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(spherical_map_ptr);
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(1);
			sv_matte_ptr2->set_kd(0.85);
			sv_matte_ptr2->set_cd(image_texture_ptr);	
	
			Instance* sphere_ptr1 = new Instance(new Sphere); 
			sphere_ptr1->scale(1000000);
			sphere_ptr1->set_material(sv_matte_ptr2);
			add_object(sphere_ptr1);
			break;
		}
	case 45:
		{
			//11.07f
			//It's very pity because I cannot find CloudSmall.ppm in Author's website...Here we give a instead and It' OK after all
			if( !CheckFile(QString(ppmfile+"MorningSky.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);

			tracer_ptr = new RayCast(this);
	
			// pinhole camera for Figure 11.7(a)
			
			Pinhole* pinHole_ptr = new Pinhole;
			pinHole_ptr->set_eye(250, 300, 150); 
			pinHole_ptr->set_lookat(-20, 300, -110);  
			pinHole_ptr->set_view_distance(250);
			pinHole_ptr->compute_uvw();  
		//	set_camera(pinHole_ptr);
		
	
			// fisheye camera for the other parts
	
			FishEye* fisheye_ptr = new FishEye;
	
			// for parts (b), (c), (d)
	
			fisheye_ptr->set_eye(250, 300, 150);
			fisheye_ptr->set_lookat(-20, 300, -110);
		//	fisheye_ptr->set_fov(120);  // part (b)
		//	fisheye_ptr->set_fov(180);  // part (c)
		//	fisheye_ptr->set_fov(360);  // part (d)

		/*	
			// for part (e)
	
			fisheye_ptr->set_eye(250, 450, 150); 
			fisheye_ptr->set_lookat(-20, 250, -110);  
			fisheye_ptr->set_fov(360);
	
		*/

			// for part (f)
			// for this image the skydome is the only object in the scene
			// you need to comment out the two statements:
			// add_object(grid_ptr);
			// add_object(plane_ptr);
	
			fisheye_ptr->set_eye(0, 0, 0);     
			fisheye_ptr->set_lookat(0, 1, 0);
			fisheye_ptr->set_fov(180);
			
		
			fisheye_ptr->compute_uvw();  
			set_camera(fisheye_ptr);

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(150, 200, 65);  
			light_ptr1->scale_radiance(5.25);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
			// box materials
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_cd(0, 0.5, 0.5);     // cyan
			matte_ptr1->set_ka(0.4); 
			matte_ptr1->set_kd(0.5); 
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_cd(1, 0, 0);     	  // red
			matte_ptr2->set_ka(0.4); 
			matte_ptr2->set_kd(0.5);  
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_cd(0.5, 0.6, 0);     // green
			matte_ptr3->set_ka(0.4); 
			matte_ptr3->set_kd(0.5); 
	
	
			// Construct rows of boxes stored in a grid
		
			Grid* grid_ptr = new Grid;
	
			// first row
	
			int num_boxes = 40;
			float wx = 50;
			float wz = 50;
			float h = 150;
			float s = 100;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx, 0, -(j + 1) * wz - j * s), 
										Point3D(0, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr1);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// second row
	
			h = 300;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx -wx - s, 0, -(j + 1) * wz - j * s), 
										Point3D(-wx - s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr2);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// third row
	
			h = 850; 
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx - 2 * wx - 2 * s, 0, -(j + 1) * wz - j * s), 
										Point3D(-2 * wx - 2 * s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr3);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// a column
	
			h = 150;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-3 * (wx + s) - (j + 1) * wz - j * s, 0, -wx), 
										Point3D(-3 * (wx + s) - j * wz - j * s, h, 0));
				box_ptr->set_material(matte_ptr1);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
			grid_ptr->setup_cells();
			//add_object(grid_ptr);
	
	
			// ground plane with checker
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(2 * wx); 
			checker_ptr->set_color1(0.7);  
			checker_ptr->set_color2(white);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.20);
			sv_matte_ptr1->set_kd(0.50); 
			sv_matte_ptr1->set_cd(checker_ptr);	
			Plane* plane_ptr = new Plane(Point3D(0, 1, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr1);
			//add_object(plane_ptr);

	
			// skydome with clouds
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"MorningSky.ppm").toLatin1().data());

			SphericalMap* spherical_map_ptr = new SphericalMap;
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(spherical_map_ptr);
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(1);
			sv_matte_ptr2->set_kd(0.85);
			sv_matte_ptr2->set_cd(image_texture_ptr);	
	
			Instance* sphere_ptr1 = new Instance(new Sphere); 
			sphere_ptr1->scale(1000000);
			sphere_ptr1->set_material(sv_matte_ptr2);
			add_object(sphere_ptr1);
			break;
		}
	case 46:
		{
			//11.8a
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);
	
			tracer_ptr = new RayCast(this);	
	
		
			FishEye* fisheye_ptr = new FishEye;
	
			fisheye_ptr->set_eye(0); 
			fisheye_ptr->set_lookat(0, 0, -100);
	
			fisheye_ptr->set_fov(180);			// For Figure 11.8(a)
		//	fisheye_ptr->set_fov(360);	 		// For Figure 11.8(b)
	
		//	fisheye_ptr->set_lookat(0, 100, 0);	// For Figure 11.8(c) - camera looks vertically up
		//	fisheye_ptr->set_fov(200);		
	
			fisheye_ptr->compute_uvw(); 
			set_camera(fisheye_ptr);

	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());   // for development
		//	image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_large.ppm").toLatin1().data());   // for production

			//Here we should notice that The LightPorbe class in samples seems called LightProbeMap
			LightProbeMap* light_probe_ptr = new LightProbeMap;     	
			light_probe_ptr->set_map_type(panoramic);
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;	// ka + kd > 1
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85); 	
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr = new Instance(unit_sphere_ptr); 
			sphere_ptr->scale(1000000);
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 47:
		{
			//11.8b
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);
	
			tracer_ptr = new RayCast(this);	
	
		
			FishEye* fisheye_ptr = new FishEye;
	
			fisheye_ptr->set_eye(0); 
			fisheye_ptr->set_lookat(0, 0, -100);
	
		//	fisheye_ptr->set_fov(180);			// For Figure 11.8(a)
			fisheye_ptr->set_fov(360);	 		// For Figure 11.8(b)
	
		//	fisheye_ptr->set_lookat(0, 100, 0);	// For Figure 11.8(c) - camera looks vertically up
		//	fisheye_ptr->set_fov(200);		
	
			fisheye_ptr->compute_uvw(); 
			set_camera(fisheye_ptr);

	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());   // for development
		//	image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_large.ppm").toLatin1().data());   // for production

			LightProbeMap* light_probe_ptr = new LightProbeMap;     	
			light_probe_ptr->set_map_type(panoramic);
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;	// ka + kd > 1
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85); 	
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr = new Instance(unit_sphere_ptr); 
			sphere_ptr->scale(1000000);
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 48:
		{
			//11.8c
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);
	
			tracer_ptr = new RayCast(this);	
	
		
			FishEye* fisheye_ptr = new FishEye;
	
			fisheye_ptr->set_eye(0); 
			fisheye_ptr->set_lookat(0, 0, -100);
	
		//	fisheye_ptr->set_fov(180);			// For Figure 11.8(a)
		//	fisheye_ptr->set_fov(360);	 		// For Figure 11.8(b)
	
			fisheye_ptr->set_lookat(0, 100, 0);	// For Figure 11.8(c) - camera looks vertically up
			fisheye_ptr->set_fov(200);		
	
			fisheye_ptr->compute_uvw(); 
			set_camera(fisheye_ptr);

	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());   // for development
		//	image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_large.ppm").toLatin1().data());   // for production

			LightProbeMap* light_probe_ptr = new LightProbeMap;     	
			light_probe_ptr->set_map_type(panoramic);
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;	// ka + kd > 1
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85); 	
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr = new Instance(unit_sphere_ptr); 
			sphere_ptr->scale(1000000);
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 49:
		{
			//11.11a
			if( !CheckFile(QString(ppmfile+"MorningSky.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);			
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);
			vp.set_max_depth(0);
	
			tracer_ptr = new RayCast(this);	
	
			Spherical* spherical_ptr = new Spherical;
	
			// for Figure 11.11(a)
		
			spherical_ptr->set_eye(100, 100, 50);  
			spherical_ptr->set_lookat(0, -10, 0);
			spherical_ptr->set_horizontal_fov(84);  
			spherical_ptr->set_vertical_fov(56);
	
		/*
	
			// for Figure 11.11(b)
	
			spherical_ptr->set_eye(150, 50, 75);  
			spherical_ptr->set_lookat(0, 10, 0);
			spherical_ptr->set_horizontal_fov(60);  
			spherical_ptr->set_vertical_fov(40);

		*/
	
			spherical_ptr->compute_uvw(); 
			set_camera(spherical_ptr);
	   	
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(150, 500, 300);  
			light_ptr2->scale_radiance(3.75);  
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// city parameters
	
			float 	a					= 10;   // city block width:  xw extent
			float 	b   				= 12;	// city block length:  yw extent
			int 	num_rows			= 10;  	// number of blocks in the xw direction
			int 	num_columns			= 12; 	// number of blocks in the zw direction
			float	width				= 7;	// building width: xw extent in range [min, a - offset]
			float 	length				= 7;	// building length: zw extent in range [min, b - offset]
			float 	min_size			= 6;	// mininum building extent in xw and yw directions
			float 	offset				= 1.0;	// half the minimum distance between buildings
			float 	min_height			= 0.0; 	// minimum building height
			float 	max_height			= 30; 	// maximum bulding height
			float 	height;						// the building height in range [min_height, max_height]
			int		num_park_rows		= 4;  	// number of blocks of park in xw direction
			int		num_park_columns	= 6;  	// number of blocks of park in xw direction
			int 	row_test;					// there are no buildings in the park
			int 	column_test;				// there are no buildings in the park
			float 	min_color			= 0.1;  // prevents black buildings
			float 	max_color			= 0.9;	// prevents white buildings
		
			set_rand_seed(15);  				// as the buildings' dimensions and colors are random, it's necessary to 
												// seed rand to keep these quantities the same at each run
												// if you leave this out, and change the number of samples per pixel,
												// these will change
	
			// the buildings are stored in a grid
	
			Grid* grid_ptr = new Grid;
	
			for (int r = 0; r < num_rows; r++)  			// xw direction
				for (int c = 0; c < num_columns; c++) {		// zw direction
					// determine if the block is in the park
		
					if ((r - num_rows / 2) >= 0)
						row_test = r -  num_rows / 2;
					else
						row_test = r -  num_rows / 2 + 1;
				
					if ((c - num_columns / 2) >= 0)
						column_test = c - num_columns / 2;
					else
						column_test = c - num_columns / 2 + 1;
			
					if (abs(row_test) >= (num_park_rows / 2) || abs(column_test) >= (num_park_columns / 2)) {
		
						Matte* matte_ptr = new Matte;
						matte_ptr->set_ka(0.4); 
						matte_ptr->set_kd(0.6); 			
						matte_ptr->set_cd(	min_color + rand_float() * (max_color - min_color), 
											min_color + rand_float() * (max_color - min_color), 
											min_color + rand_float() * (max_color - min_color));    
				
						// block center coordinates
				
						float xc = a * (r - num_rows / 2.0 + 0.5);
						float zc = b * (c - num_columns / 2.0 + 0.5);
				
						width = min_size + rand_float() * (a - 2 * offset - min_size);
						length = min_size + rand_float() * (b - 2 * offset - min_size);	
				
						// minimum building coordinates
				
						float xmin = xc - width / 2.0;
						float ymin = 0.0;
						float zmin = zc - length / 2.0;
				
						// maximum building coordinates
				
						height = min_height + rand_float() * (max_height - min_height);
				
						// The following is a hack to make the middle row and column of buildings higher
						// on average than the other buildings. 
						// This only works properly when there are three rows and columns of buildings
				
						if (r == 1 || r == num_rows - 2 || c == 1 || c == num_columns - 2)
							height *= 1.5;
				
						float xmax = xc + width / 2.0;
						float ymax = height;
						float zmax = zc + length / 2.0;
				
						Box* building_ptr = new  Box(Point3D(xmin, ymin, zmin), Point3D(xmax, ymax, zmax));
						building_ptr->set_material(matte_ptr);
						grid_ptr->add_object(building_ptr);
					}
				}
		
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
	
			// render the park with small green checkers
	
			Checker3D* checker3D_ptr1 = new Checker3D;
			checker3D_ptr1->set_size(5); 
			checker3D_ptr1->set_color1(0.35, 0.75, 0.35);  
			checker3D_ptr1->set_color2(0.3, 0.5, 0.3);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.3);
			sv_matte_ptr1->set_kd(0.50);  
			sv_matte_ptr1->set_cd(checker3D_ptr1);
											
			Box* park_ptr = new Box( 	Point3D(-a * num_park_rows / 2, 0.0, -b * num_park_columns / 2), 
										Point3D(a * num_park_rows / 2, 0.1, b * num_park_columns / 2)  );										
			park_ptr->set_material(sv_matte_ptr1);
			add_object(park_ptr);
											
	
			// ground plane with checker:
	
			Checker3D* checker3D_ptr2 = new Checker3D;
			checker3D_ptr2->set_size(50); 
			checker3D_ptr2->set_color1(RGBColor(0.7));  
			checker3D_ptr2->set_color2(RGBColor(1));
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.30);
			sv_matte_ptr2->set_kd(0.40);  
			sv_matte_ptr2->set_cd(checker3D_ptr2);
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr2);
			add_object(plane_ptr);

	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"MorningSky.ppm").toLatin1().data());	
	
			SphericalMap* spherical_map_ptr = new SphericalMap; 
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(spherical_map_ptr); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85); 
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr = new Instance(unit_sphere_ptr); 
			sphere_ptr->scale(1000000);
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 50:
		{
			//11.11b
			if( !CheckFile(QString(ppmfile+"MorningSky.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);			
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);
			vp.set_max_depth(0);
	
			tracer_ptr = new RayCast(this);	
	
			Spherical* spherical_ptr = new Spherical;
	
		/*
			// for Figure 11.11(a)
		
			spherical_ptr->set_eye(100, 100, 50);  
			spherical_ptr->set_lookat(0, -10, 0);
			spherical_ptr->set_horizontal_fov(84);  
			spherical_ptr->set_vertical_fov(56);
		*/
	
			// for Figure 11.11(b)
	
			spherical_ptr->set_eye(150, 50, 75);  
			spherical_ptr->set_lookat(0, 10, 0);
			spherical_ptr->set_horizontal_fov(60);  
			spherical_ptr->set_vertical_fov(40);
	
			spherical_ptr->compute_uvw(); 
			set_camera(spherical_ptr);
	   	
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(150, 500, 300);  
			light_ptr2->scale_radiance(3.75);  
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// city parameters
	
			float 	a					= 10;   // city block width:  xw extent
			float 	b   				= 12;	// city block length:  yw extent
			int 	num_rows			= 10;  	// number of blocks in the xw direction
			int 	num_columns			= 12; 	// number of blocks in the zw direction
			float	width				= 7;	// building width: xw extent in range [min, a - offset]
			float 	length				= 7;	// building length: zw extent in range [min, b - offset]
			float 	min_size			= 6;	// mininum building extent in xw and yw directions
			float 	offset				= 1.0;	// half the minimum distance between buildings
			float 	min_height			= 0.0; 	// minimum building height
			float 	max_height			= 30; 	// maximum bulding height
			float 	height;						// the building height in range [min_height, max_height]
			int		num_park_rows		= 4;  	// number of blocks of park in xw direction
			int		num_park_columns	= 6;  	// number of blocks of park in xw direction
			int 	row_test;					// there are no buildings in the park
			int 	column_test;				// there are no buildings in the park
			float 	min_color			= 0.1;  // prevents black buildings
			float 	max_color			= 0.9;	// prevents white buildings
		
			set_rand_seed(15);  				// as the buildings' dimensions and colors are random, it's necessary to 
												// seed rand to keep these quantities the same at each run
												// if you leave this out, and change the number of samples per pixel,
												// these will change
	
			// the buildings are stored in a grid
	
			Grid* grid_ptr = new Grid;
	
			for (int r = 0; r < num_rows; r++)  			// xw direction
				for (int c = 0; c < num_columns; c++) {		// zw direction
					// determine if the block is in the park
		
					if ((r - num_rows / 2) >= 0)
						row_test = r -  num_rows / 2;
					else
						row_test = r -  num_rows / 2 + 1;
				
					if ((c - num_columns / 2) >= 0)
						column_test = c - num_columns / 2;
					else
						column_test = c - num_columns / 2 + 1;
			
					if (abs(row_test) >= (num_park_rows / 2) || abs(column_test) >= (num_park_columns / 2)) {
		
						Matte* matte_ptr = new Matte;
						matte_ptr->set_ka(0.4); 
						matte_ptr->set_kd(0.6); 			
						matte_ptr->set_cd(	min_color + rand_float() * (max_color - min_color), 
											min_color + rand_float() * (max_color - min_color), 
											min_color + rand_float() * (max_color - min_color));    
				
						// block center coordinates
				
						float xc = a * (r - num_rows / 2.0 + 0.5);
						float zc = b * (c - num_columns / 2.0 + 0.5);
				
						width = min_size + rand_float() * (a - 2 * offset - min_size);
						length = min_size + rand_float() * (b - 2 * offset - min_size);	
				
						// minimum building coordinates
				
						float xmin = xc - width / 2.0;
						float ymin = 0.0;
						float zmin = zc - length / 2.0;
				
						// maximum building coordinates
				
						height = min_height + rand_float() * (max_height - min_height);
				
						// The following is a hack to make the middle row and column of buildings higher
						// on average than the other buildings. 
						// This only works properly when there are three rows and columns of buildings
				
						if (r == 1 || r == num_rows - 2 || c == 1 || c == num_columns - 2)
							height *= 1.5;
				
						float xmax = xc + width / 2.0;
						float ymax = height;
						float zmax = zc + length / 2.0;
				
						Box* building_ptr = new  Box(Point3D(xmin, ymin, zmin), Point3D(xmax, ymax, zmax));
						building_ptr->set_material(matte_ptr);
						grid_ptr->add_object(building_ptr);
					}
				}
		
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
	
			// render the park with small green checkers
	
			Checker3D* checker3D_ptr1 = new Checker3D;
			checker3D_ptr1->set_size(5); 
			checker3D_ptr1->set_color1(0.35, 0.75, 0.35);  
			checker3D_ptr1->set_color2(0.3, 0.5, 0.3);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.3);
			sv_matte_ptr1->set_kd(0.50);  
			sv_matte_ptr1->set_cd(checker3D_ptr1);
											
			Box* park_ptr = new Box( 	Point3D(-a * num_park_rows / 2, 0.0, -b * num_park_columns / 2), 
										Point3D(a * num_park_rows / 2, 0.1, b * num_park_columns / 2)  );										
			park_ptr->set_material(sv_matte_ptr1);
			add_object(park_ptr);
											
	
			// ground plane with checker:
	
			Checker3D* checker3D_ptr2 = new Checker3D;
			checker3D_ptr2->set_size(50); 
			checker3D_ptr2->set_color1(RGBColor(0.7));  
			checker3D_ptr2->set_color2(RGBColor(1));
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.30);
			sv_matte_ptr2->set_kd(0.40);  
			sv_matte_ptr2->set_cd(checker3D_ptr2);
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr2);
			add_object(plane_ptr);

	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"MorningSky.ppm").toLatin1().data());	
	
			SphericalMap* spherical_map_ptr = new SphericalMap; 
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(spherical_map_ptr); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85); 
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr = new Instance(unit_sphere_ptr); 
			sphere_ptr->scale(1000000);
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 51:
		{
			//11.12a
			if( !CheckFile(QString(ppmfile+"MorningSky.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);
	
			tracer_ptr = new RayCast(this);	
	
			Spherical* spherical_ptr = new Spherical;
			spherical_ptr->set_eye(10, 15, 13);      
			spherical_ptr->set_lookat(34, 15, 0);
		
			// for Figure 11.12(a)
	
			vp.set_hres(600);			
			vp.set_vres(400);
	
			spherical_ptr->set_horizontal_fov(180);  
			spherical_ptr->set_vertical_fov(120);    
	
		/*	
			// for Figure 11.12(b)
	
			vp.set_hres(800);			
			vp.set_vres(400);
	
			spherical_ptr->set_horizontal_fov(360);  
			spherical_ptr->set_vertical_fov(180);  
		*/  
		
			spherical_ptr->compute_uvw(); 
			set_camera(spherical_ptr);
	   	
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(150, 500, 300);  
			light_ptr2->scale_radiance(3.75);  
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// city parameters
	
			float 	a					= 10;   // city block width:  xw extent
			float 	b   				= 12;	// city block length:  yw extent
			int 	num_rows			= 10;  	// number of blocks in the xw direction
			int 	num_columns			= 12; 	// number of blocks in the zw direction
			float	width				= 7;	// building width: xw extent in range [min, a - offset]
			float 	length				= 7;	// building length: zw extent in range [min, b - offset]
			float 	min_size			= 6;	// mininum building extent in xw and yw directions
			float 	offset				= 1.0;	// half the minimum distance between buildings
			float 	min_height			= 0.0; 	// minimum building height
			float 	max_height			= 30; 	// maximum bulding height
			float 	height;						// the building height in range [min_height, max_height]
			int		num_park_rows		= 4;  	// number of blocks of park in xw direction
			int		num_park_columns	= 6;  	// number of blocks of park in xw direction
			int 	row_test;					// there are no buildings in the park
			int 	column_test;				// there are no buildings in the park
			float 	min_color			= 0.1;  // prevents black buildings
			float 	max_color			= 0.9;	// prevents white buildings
		
			set_rand_seed(15);  				// as the buildings' dimensions and colors are random, it's necessary to 
												// seed rand to keep these quantities the same at each run
												// if you leave this out, and change the number of samples per pixel,
												// these will change
	
			// the buildings are stored in a grid
	
			Grid* grid_ptr = new Grid;
	
			for (int r = 0; r < num_rows; r++)  			// xw direction
				for (int c = 0; c < num_columns; c++) {		// zw direction
					// determine if the block is in the park
		
					if ((r - num_rows / 2) >= 0)
						row_test = r -  num_rows / 2;
					else
						row_test = r -  num_rows / 2 + 1;
				
					if ((c - num_columns / 2) >= 0)
						column_test = c - num_columns / 2;
					else
						column_test = c - num_columns / 2 + 1;
			
					if (abs(row_test) >= (num_park_rows / 2) || abs(column_test) >= (num_park_columns / 2)) {
		
						Matte* matte_ptr = new Matte;
						matte_ptr->set_ka(0.4); 
						matte_ptr->set_kd(0.6); 			
						matte_ptr->set_cd(	min_color + rand_float() * (max_color - min_color), 
											min_color + rand_float() * (max_color - min_color), 
											min_color + rand_float() * (max_color - min_color));    
				
						// block center coordinates
				
						float xc = a * (r - num_rows / 2.0 + 0.5);
						float zc = b * (c - num_columns / 2.0 + 0.5);
				
						width = min_size + rand_float() * (a - 2 * offset - min_size);
						length = min_size + rand_float() * (b - 2 * offset - min_size);	
				
						// minimum building coordinates
				
						float xmin = xc - width / 2.0;
						float ymin = 0.0;
						float zmin = zc - length / 2.0;
				
						// maximum building coordinates
				
						height = min_height + rand_float() * (max_height - min_height);
				
						// The following is a hack to make the middle row and column of buildings higher
						// on average than the other buildings. 
						// This only works properly when there are three rows and columns of buildings
				
						if (r == 1 || r == num_rows - 2 || c == 1 || c == num_columns - 2)
							height *= 1.5;
				
						float xmax = xc + width / 2.0;
						float ymax = height;
						float zmax = zc + length / 2.0;
				
						Box* building_ptr = new  Box(Point3D(xmin, ymin, zmin), Point3D(xmax, ymax, zmax));
						building_ptr->set_material(matte_ptr);
						grid_ptr->add_object(building_ptr);
					}
				}
		
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
	
			// render the park with small green checkers
	
			Checker3D* checker3D_ptr1 = new Checker3D;
			checker3D_ptr1->set_size(5); 
			checker3D_ptr1->set_color1(0.35, 0.75, 0.35);  
			checker3D_ptr1->set_color2(0.3, 0.5, 0.3);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.3);
			sv_matte_ptr1->set_kd(0.50);  
			sv_matte_ptr1->set_cd(checker3D_ptr1);
											
			Box* park_ptr = new Box( 	Point3D(-a * num_park_rows / 2, 0.0, -b * num_park_columns / 2), 
										Point3D(a * num_park_rows / 2, 0.1, b * num_park_columns / 2)  );										
			park_ptr->set_material(sv_matte_ptr1);
			add_object(park_ptr);
											
	
			// ground plane with checker:
	
			Checker3D* checker3D_ptr2 = new Checker3D;
			checker3D_ptr2->set_size(50); 
			checker3D_ptr2->set_color1(RGBColor(0.7));  
			checker3D_ptr2->set_color2(RGBColor(1));
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.30);
			sv_matte_ptr2->set_kd(0.40);  
			sv_matte_ptr2->set_cd(checker3D_ptr2);
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr2);
			add_object(plane_ptr);

	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"MorningSky.ppm").toLatin1().data());	
	
			SphericalMap* spherical_map_ptr = new SphericalMap; 
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(spherical_map_ptr); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85); 
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr = new Instance(unit_sphere_ptr); 
			sphere_ptr->scale(1000000);
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 52:
		{
			//11.12b
			if( !CheckFile(QString(ppmfile+"MorningSky.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);
	
			tracer_ptr = new RayCast(this);	
	
			Spherical* spherical_ptr = new Spherical;
			spherical_ptr->set_eye(10, 15, 13);      
			spherical_ptr->set_lookat(34, 15, 0);
		
		/*
			// for Figure 11.12(a)
	
			vp.set_hres(600);			
			vp.set_vres(400);
	
			spherical_ptr->set_horizontal_fov(180);  
			spherical_ptr->set_vertical_fov(120);    
		*/

			// for Figure 11.12(b)
	
			vp.set_hres(800);			
			vp.set_vres(400);
	
			spherical_ptr->set_horizontal_fov(360);
			spherical_ptr->set_vertical_fov(180);
		
			spherical_ptr->compute_uvw(); 
			set_camera(spherical_ptr);
	   	
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(150, 500, 300);  
			light_ptr2->scale_radiance(3.75);  
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// city parameters
	
			float 	a					= 10;   // city block width:  xw extent
			float 	b   				= 12;	// city block length:  yw extent
			int 	num_rows			= 10;  	// number of blocks in the xw direction
			int 	num_columns			= 12; 	// number of blocks in the zw direction
			float	width				= 7;	// building width: xw extent in range [min, a - offset]
			float 	length				= 7;	// building length: zw extent in range [min, b - offset]
			float 	min_size			= 6;	// mininum building extent in xw and yw directions
			float 	offset				= 1.0;	// half the minimum distance between buildings
			float 	min_height			= 0.0; 	// minimum building height
			float 	max_height			= 30; 	// maximum bulding height
			float 	height;						// the building height in range [min_height, max_height]
			int		num_park_rows		= 4;  	// number of blocks of park in xw direction
			int		num_park_columns	= 6;  	// number of blocks of park in xw direction
			int 	row_test;					// there are no buildings in the park
			int 	column_test;				// there are no buildings in the park
			float 	min_color			= 0.1;  // prevents black buildings
			float 	max_color			= 0.9;	// prevents white buildings
		
			set_rand_seed(15);  				// as the buildings' dimensions and colors are random, it's necessary to 
												// seed rand to keep these quantities the same at each run
												// if you leave this out, and change the number of samples per pixel,
												// these will change
	
			// the buildings are stored in a grid
	
			Grid* grid_ptr = new Grid;
	
			for (int r = 0; r < num_rows; r++)  			// xw direction
				for (int c = 0; c < num_columns; c++) {		// zw direction
					// determine if the block is in the park
		
					if ((r - num_rows / 2) >= 0)
						row_test = r -  num_rows / 2;
					else
						row_test = r -  num_rows / 2 + 1;
				
					if ((c - num_columns / 2) >= 0)
						column_test = c - num_columns / 2;
					else
						column_test = c - num_columns / 2 + 1;
			
					if (abs(row_test) >= (num_park_rows / 2) || abs(column_test) >= (num_park_columns / 2)) {
		
						Matte* matte_ptr = new Matte;
						matte_ptr->set_ka(0.4); 
						matte_ptr->set_kd(0.6); 			
						matte_ptr->set_cd(	min_color + rand_float() * (max_color - min_color), 
											min_color + rand_float() * (max_color - min_color), 
											min_color + rand_float() * (max_color - min_color));    
				
						// block center coordinates
				
						float xc = a * (r - num_rows / 2.0 + 0.5);
						float zc = b * (c - num_columns / 2.0 + 0.5);
				
						width = min_size + rand_float() * (a - 2 * offset - min_size);
						length = min_size + rand_float() * (b - 2 * offset - min_size);	
				
						// minimum building coordinates
				
						float xmin = xc - width / 2.0;
						float ymin = 0.0;
						float zmin = zc - length / 2.0;
				
						// maximum building coordinates
				
						height = min_height + rand_float() * (max_height - min_height);
				
						// The following is a hack to make the middle row and column of buildings higher
						// on average than the other buildings. 
						// This only works properly when there are three rows and columns of buildings
				
						if (r == 1 || r == num_rows - 2 || c == 1 || c == num_columns - 2)
							height *= 1.5;
				
						float xmax = xc + width / 2.0;
						float ymax = height;
						float zmax = zc + length / 2.0;
				
						Box* building_ptr = new  Box(Point3D(xmin, ymin, zmin), Point3D(xmax, ymax, zmax));
						building_ptr->set_material(matte_ptr);
						grid_ptr->add_object(building_ptr);
					}
				}
		
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
	
			// render the park with small green checkers
	
			Checker3D* checker3D_ptr1 = new Checker3D;
			checker3D_ptr1->set_size(5); 
			checker3D_ptr1->set_color1(0.35, 0.75, 0.35);  
			checker3D_ptr1->set_color2(0.3, 0.5, 0.3);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.3);
			sv_matte_ptr1->set_kd(0.50);  
			sv_matte_ptr1->set_cd(checker3D_ptr1);
											
			Box* park_ptr = new Box( 	Point3D(-a * num_park_rows / 2, 0.0, -b * num_park_columns / 2), 
										Point3D(a * num_park_rows / 2, 0.1, b * num_park_columns / 2)  );										
			park_ptr->set_material(sv_matte_ptr1);
			add_object(park_ptr);
											
	
			// ground plane with checker:
	
			Checker3D* checker3D_ptr2 = new Checker3D;
			checker3D_ptr2->set_size(50); 
			checker3D_ptr2->set_color1(RGBColor(0.7));  
			checker3D_ptr2->set_color2(RGBColor(1));
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.30);
			sv_matte_ptr2->set_kd(0.40);  
			sv_matte_ptr2->set_cd(checker3D_ptr2);
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr2);
			add_object(plane_ptr);

	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"MorningSky.ppm").toLatin1().data());	
	
			SphericalMap* spherical_map_ptr = new SphericalMap; 
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(spherical_map_ptr); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85); 
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr = new Instance(unit_sphere_ptr); 
			sphere_ptr->scale(1000000);
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 53:
		{
			//11.13
			if( !CheckFile(QString(ppmfile+"uffizi_probe_large.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(800);			
			vp.set_vres(400); 
			vp.set_samples(num_samples);
			vp.set_pixel_size(5.0);
	
			tracer_ptr = new RayCast(this);	
	
			Spherical* spherical_ptr = new Spherical;
			spherical_ptr->set_eye(0);     
			spherical_ptr->set_lookat(0, 0, -100);
			spherical_ptr->set_horizontal_fov(360);  
			spherical_ptr->set_vertical_fov(180);  
			spherical_ptr->compute_uvw(); 
			set_camera(spherical_ptr);
	
	
			Image* image_ptr = new Image;
		//	image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_.ppm").toLatin1().data());   // for development
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_large.ppm").toLatin1().data());   // for production

			LightProbeMap* light_probe_ptr = new LightProbeMap;     	
			light_probe_ptr->set_map_type(panoramic);
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;	// ka + kd > 1
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85); 	
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr = new Instance(unit_sphere_ptr); 
			sphere_ptr->scale(1000000);
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 54:
		{
			//12p1
			int num_samples = 16;
	
			vp.set_hres(300);
			vp.set_vres(300);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = RGBColor(0.0, 0.2, 0.4);
	
			// stereo camera setup using fisheye cameras
	
			float fov = 130.0;

			FishEye* left_camera_ptr = new FishEye;
			left_camera_ptr->set_fov(fov);
	
			FishEye* right_camera_ptr = new FishEye;
			right_camera_ptr->set_fov(fov);

			StereoCamera* stereo_ptr = new StereoCamera;	
			stereo_ptr->set_left_camera(left_camera_ptr);
			stereo_ptr->set_right_camera(right_camera_ptr);
		//	stereo_ptr->use_parallel_viewing();
			stereo_ptr->use_transverse_viewing();
			stereo_ptr->set_pixel_gap(5);       // in pixels
			stereo_ptr->set_eye(100.0, 750.0, 0.0);
			stereo_ptr->set_lookat(0.0);
			stereo_ptr->compute_uvw();
			stereo_ptr->set_stereo_angle(5.0);  // in degrees
			stereo_ptr->setup_cameras(); 
			set_camera(stereo_ptr);
	
		
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(0, 350, 0);   
			light_ptr1->scale_radiance(3.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(0, 2000, 0);  
			light_ptr2->scale_radiance(2.0);
			light_ptr2->scale_radiance(1.0);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// cylinder materials
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_cd(1, 1, 0);     	// yellow
			matte_ptr1->set_ka(0.4); 
			matte_ptr1->set_kd(0.5); 
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_cd(1, 0.35, 0);     // red
			matte_ptr2->set_ka(0.4); 
			matte_ptr2->set_kd(0.5);  
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_cd(0, 0.5, 0.5);    // cyan
			matte_ptr3->set_ka(0.4); 
			matte_ptr3->set_kd(0.5); 
	
	
			// construct rings of cylinders stored in a grid
		
			Grid* grid_ptr = new Grid;
	
			int num_cylinders = 12;
			float bottom = 0.0;
			float top = 500.0;
			float radius = 25.0;
			float ring_radius = 150.0;
			float delta_phi = 360.0 / num_cylinders;  // in degrees
	
			// inner ring
	
			for (int j = 0; j < num_cylinders; j++) {
				Instance* cylinder_ptr = new Instance (new SolidCylinder(bottom, top, radius));
				cylinder_ptr->set_material(matte_ptr1);
				cylinder_ptr->translate(0, 0, ring_radius);
				cylinder_ptr->rotate_y(j * delta_phi);
				cylinder_ptr->set_bounding_box();
				//add_object(cylinder_ptr);
				grid_ptr->add_object(cylinder_ptr);
			}
		
	
			// middle ring
	
			num_cylinders = 16;
			top = 450.0;
			ring_radius = 350.0;
			delta_phi = 360.0 / num_cylinders;  // in degrees
	
			for (int j = 0; j < num_cylinders; j++) {
				Instance* cylinder_ptr = new Instance (new SolidCylinder(bottom, top, radius));
				cylinder_ptr->set_material(matte_ptr3);
				cylinder_ptr->translate(0, 0, ring_radius);
				cylinder_ptr->rotate_y(j * delta_phi);
				cylinder_ptr->set_bounding_box();
				//add_object(cylinder_ptr);
				grid_ptr->add_object(cylinder_ptr);
			}
	
	
			// outer ring
	
			num_cylinders = 16;
			top = 325.0;
			ring_radius = 500.0;
			delta_phi = 360.0 / num_cylinders;  // in degrees
	
			for (int j = 0; j < num_cylinders; j++) {
				Instance* cylinder_ptr = new Instance (new SolidCylinder(bottom, top, radius));
				cylinder_ptr->set_material(matte_ptr2);
				cylinder_ptr->translate(0, 0, ring_radius);
				cylinder_ptr->rotate_y(j * delta_phi + 10);
				cylinder_ptr->set_bounding_box();
				//add_object(cylinder_ptr);
				grid_ptr->add_object(cylinder_ptr);
			}
	
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
			// ground plane with checkers:
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(200.0); 
			checker_ptr->set_color1(0.5);   
			checker_ptr->set_color2(white);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.20);
			sv_matte_ptr->set_kd(0.50); 
			sv_matte_ptr->set_cd(checker_ptr);	
			Plane* plane_ptr = new Plane(Point3D(0, 1, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 55:
		{
			//12.12
			int num_samples = 1;

			vp.set_hres(200);	
			vp.set_vres(200);
			vp.set_pixel_size(0.05);		
			vp.set_samples(num_samples);	
	
			tracer_ptr = new RayCast(this);			

			float vpd = 100;  // view plane distance for 200 x 200 pixel images

			Pinhole* left_camera_ptr = new Pinhole;  
			left_camera_ptr->set_view_distance(vpd);
	
			Pinhole* right_camera_ptr = new Pinhole; 
			right_camera_ptr->set_view_distance(vpd);
	
			StereoCamera* stereo_ptr = new StereoCamera;		
			stereo_ptr->set_left_camera(left_camera_ptr);
			stereo_ptr->set_right_camera(right_camera_ptr);
			stereo_ptr->use_parallel_viewing();
		//	stereo_ptr->use_transverse_viewing();
			stereo_ptr->set_pixel_gap(5);       // in pixels
			stereo_ptr->set_eye(5, 0, 100);
			stereo_ptr->set_lookat(0);
			stereo_ptr->compute_uvw();
			stereo_ptr->set_stereo_angle(0.75);  // in degrees
			stereo_ptr->setup_cameras(); 
			set_camera(stereo_ptr);
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(100, 100, 100);
			light_ptr->scale_radiance(3);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// sphere materials
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_cd(0, 0.5, 0.5);   	// cyan
			phong_ptr1->set_ka(0.4); 
			phong_ptr1->set_kd(0.6);
			phong_ptr1->set_ks(0.2); 
			phong_ptr1->set_exp(20); 
	
			Phong*	phong_ptr2 = new Phong;
			phong_ptr2->set_cd(0.85, 0.6, 0.2); 	// brown				
			phong_ptr2->set_ka(0.3); 
			phong_ptr2->set_kd(0.7);
			phong_ptr2->set_ks(0.08);
			phong_ptr2->set_exp(20);  
	
			Phong*	phong_ptr3 = new Phong;			
			phong_ptr3->set_cd(1, 1, 0);     		// yellow
			phong_ptr3->set_ka(0.2); 
			phong_ptr3->set_kd(0.6);
			phong_ptr3->set_ks(0.08); 
			phong_ptr3->set_exp(20);   
	
			// the spheres
	
			Sphere* sphere1 = new Sphere(Point3D(0, 0, 35), 0.75);
			sphere1->set_material(phong_ptr1);
			add_object(sphere1);
	
			Sphere* sphere2 = new Sphere(Point3D(0), 2);
			sphere2->set_material(phong_ptr2);
			add_object(sphere2);
	
			Sphere* sphere3 = new Sphere(Point3D(1.5, 0, -80), 2);
			sphere3->set_material(phong_ptr3);
			add_object(sphere3);	
			break;
		}
	case 56:
		{
			//12.13
			int num_samples = 16;
	
			vp.set_hres(200);	  		
			vp.set_vres(200);
			vp.set_samples(num_samples);
			vp.set_pixel_size(0.0325); 
	
			tracer_ptr = new RayCast(this);	
			background_color = black;
	
			float vpd = 10.0; 
	
			Pinhole* left_camera_ptr = new Pinhole;
			left_camera_ptr->set_view_distance(vpd);   
			set_camera(left_camera_ptr);
	
			Pinhole* right_camera_ptr = new Pinhole;
			right_camera_ptr->set_view_distance(vpd);   
			set_camera(right_camera_ptr);
	
			StereoCamera* stereo_ptr = new StereoCamera(left_camera_ptr, right_camera_ptr);
			stereo_ptr->use_parallel_viewing();
		// 	stereo_ptr->use_transverse_viewing();
			stereo_ptr->set_pixel_gap(5);
			stereo_ptr->set_eye(-2, 0, 5);    
			stereo_ptr->set_lookat(0.0);
			stereo_ptr->compute_uvw();
			stereo_ptr->set_stereo_angle(5.0);  // in degrees
			stereo_ptr->setup_cameras(); 
			set_camera(stereo_ptr);
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(Vector3D(20, 30, 40)); 
			light_ptr->scale_radiance(2.5);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
			
			Phong* phong_ptr = new Phong;			
			phong_ptr->set_cd(0.7);					
			phong_ptr->set_ka(0.3);    
			phong_ptr->set_kd(1);
			phong_ptr->set_ks(0.3);
			phong_ptr->set_exp(50);
	
			Point3D p0(-1.0);
			Point3D p1(1.0);
			float bevel_radius = 0.04;
	
			WireframeBox* box_ptr = new WireframeBox(p0, p1, bevel_radius);
			box_ptr->set_material(phong_ptr);
			add_object(box_ptr);
			break;
		}
	case 57:
		{
			//12.14
			int num_samples = 16;
	
			vp.set_hres(200);	  		
			vp.set_vres(200);
			vp.set_samples(num_samples);
			vp.set_pixel_size(0.05); 
	
			tracer_ptr = new RayCast(this);	
			background_color = black;
	
			float vpd = 10.0; 
	
			Pinhole* left_camera_ptr = new Pinhole;
			left_camera_ptr->set_view_distance(vpd);   
			set_camera(left_camera_ptr);
	
			Pinhole* right_camera_ptr = new Pinhole;
			right_camera_ptr->set_view_distance(vpd);   
			set_camera(right_camera_ptr);
	
			StereoCamera* stereo_ptr = new StereoCamera(left_camera_ptr, right_camera_ptr);
			stereo_ptr->use_parallel_viewing();
		// 	stereo_ptr->use_transverse_viewing();
			stereo_ptr->set_pixel_gap(5);
			stereo_ptr->set_eye(1.5, 1.75, 3);       
			stereo_ptr->set_lookat(-0.1, -0.2, 0);
			stereo_ptr->compute_uvw();
			stereo_ptr->set_stereo_angle(5.0);  // in degrees
			stereo_ptr->setup_cameras(); 
			set_camera(stereo_ptr);
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(Vector3D(20, 30, 40)); 
			light_ptr->scale_radiance(2.5);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
			
			Phong* phong_ptr = new Phong;			
			phong_ptr->set_cd(0.7);					
			phong_ptr->set_ka(0.3);    
			phong_ptr->set_kd(1);
			phong_ptr->set_ks(0.3);
			phong_ptr->set_exp(50);
	
			Point3D p0(-1.0);
			Point3D p1(1.0);
			float bevel_radius = 0.04;
	
			WireframeBox* box_ptr = new WireframeBox(p0, p1, bevel_radius);
			box_ptr->set_material(phong_ptr);
			add_object(box_ptr);	
			break;
		}
	case 58:
		{
			//12.15
			int num_samples = 16;
	
			vp.set_hres(200);                                                               	  		
			vp.set_vres(150);
			vp.set_pixel_size(0.2);  
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
	
			tracer_ptr = new RayCast(this);
			background_color = white;
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			float vpd = 98;
			float focal_distance = 74;
			float lens_radius = 1.0;
	
			ThinLens* left_camera_ptr = new ThinLens;
			left_camera_ptr->set_sampler(new MultiJittered(num_samples));	
			left_camera_ptr->set_view_distance(vpd);  
			left_camera_ptr->set_focal_distance(focal_distance); 
			left_camera_ptr->set_lens_radius(lens_radius);

			ThinLens* right_camera_ptr = new ThinLens;
			right_camera_ptr->set_sampler(new MultiJittered(num_samples));	
			right_camera_ptr->set_view_distance(vpd);   
			right_camera_ptr->set_focal_distance(focal_distance); 
			right_camera_ptr->set_lens_radius(lens_radius);

			StereoCamera* stereo_ptr = new StereoCamera(left_camera_ptr, right_camera_ptr);
			stereo_ptr->use_parallel_viewing();
		//	stereo_ptr->use_transverse_viewing();
			stereo_ptr->set_pixel_gap(5);
			stereo_ptr->set_eye(0, 6, 50);
			stereo_ptr->set_lookat(0, 6, 0);
			stereo_ptr->compute_uvw();
			stereo_ptr->set_stereo_angle(2.0);  // in degrees
			stereo_ptr->setup_cameras(); 
			set_camera(stereo_ptr);

	
			// Directional light 

			Directional* light_ptr = new Directional;
			light_ptr->set_direction(1, 1, 1);     
			light_ptr->scale_radiance(7.5); 
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// box 1
	
			Checker3D* checker_ptr1 = new Checker3D;
			checker_ptr1->set_size(2.0);
			checker_ptr1->set_color1(1, 1, 0.33);  		// lemon
			checker_ptr1->set_color2(black);	 
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.5);
			sv_matte_ptr1->set_kd(0.35);
			sv_matte_ptr1->set_cd(checker_ptr1);
	
			Box* box_ptr1 = new Box(Point3D(-9, 0, -1), Point3D(-3, 12, 0));
			box_ptr1->set_material(sv_matte_ptr1);
			add_object(box_ptr1);
		
	
			// box 2
	
			Checker3D* checker_ptr2 = new Checker3D;
			checker_ptr2->set_size(2.0);
			checker_ptr2->set_color1(black);  	
			checker_ptr2->set_color2(0.1, 1, 0.5);	  	// green
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.5);
			sv_matte_ptr2->set_kd(0.35);
			sv_matte_ptr2->set_cd(checker_ptr2);	
	
			Box* box_ptr2 = new Box(Point3D(-3.25, 0, -25), Point3D(4.75, 14, -24));
			box_ptr2->set_material(sv_matte_ptr2);
			add_object(box_ptr2);
	
	
			// box 3
	
			Checker3D* checker_ptr3 = new Checker3D;
			checker_ptr3->set_size(2.0);
			checker_ptr3->set_color1(black);  	
			checker_ptr3->set_color2(1, 0.6, 0.15);	  	// orange
	
			SV_Matte* sv_matte_ptr3 = new SV_Matte;		
			sv_matte_ptr3->set_ka(0.5);
			sv_matte_ptr3->set_kd(0.35);
			sv_matte_ptr3->set_cd(checker_ptr3);
		
			Box* box_ptr3 = new Box(Point3D(8, 0, -49), Point3D(18, 15, -48));
			box_ptr3->set_material(sv_matte_ptr3);
			add_object(box_ptr3);
	

			// ground plane
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(8.0);
			checker_ptr->set_color1(0.25);  			// gray
			checker_ptr->set_color2(white);	 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	

			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 59:
		{
			//12.16
			int num_samples = 16;
	
			vp.set_hres(200);			
			vp.set_vres(200);
			vp.set_pixel_size(1);
			vp.set_samples(num_samples);				

			tracer_ptr = new RayCast(this);	
			background_color = RGBColor(0.0, 0.2, 0.4);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.567);
			set_ambient_light(ambient_ptr);
			
			float fov = 200;
	
			FishEye* left_fisheye_ptr = new FishEye;
			left_fisheye_ptr->set_fov(fov);
	
			FishEye* right_fisheye_ptr = new FishEye;
			right_fisheye_ptr->set_fov(fov);
	
			StereoCamera* stereo_ptr = new StereoCamera; 
			stereo_ptr->set_left_camera(left_fisheye_ptr);
			stereo_ptr->set_right_camera(right_fisheye_ptr);
			stereo_ptr->use_parallel_viewing();
		// 	stereo_ptr->use_transverse_viewing();
			stereo_ptr->set_eye(-150, 1000, -500);
			stereo_ptr->set_lookat(-160, 300, -550);  
			stereo_ptr->compute_uvw();
			stereo_ptr->set_stereo_angle(5);  
			stereo_ptr->setup_cameras(); 	
			set_camera(stereo_ptr);	
		
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(1500, 750, 250);
			light_ptr2->scale_radiance(4.5);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// box materials
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_cd(0, 0.5, 0.5);     // cyan
			matte_ptr1->set_ka(0.8); 
			matte_ptr1->set_kd(0.3); 
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_cd(1, 0, 0);     	  // red
			matte_ptr2->set_ka(0.8); 
			matte_ptr2->set_kd(0.3);  
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_cd(1, 1, 0);     	// yellow
			matte_ptr3->set_ka(0.8); 
			matte_ptr3->set_kd(0.3); 
	
			
			Grid* grid_ptr = new Grid;
	
			// first row
	
			int num_boxes = 11;
			float wx = 50;
			float wz = 50;
			float h = 500;
			float s = 100;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx, 0, -(j + 1) * wz - j * s), 
										Point3D(0, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr1);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// second row
	
			h = 600;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx -wx - s, 0, -(j + 1) * wz - j * s), 
										Point3D(-wx - s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr2);
		//		add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// third row
	
			h = 750; 
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx - 2 * wx - 2 * s, 0, -(j + 1) * wz - j * s), 
										Point3D(-2 * wx - 2 * s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr3);
		//		add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
	
			// ground plane with checker
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(6 * wx); 
			checker_ptr->set_color1(0.7);  
			checker_ptr->set_color2(white);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.20);
			sv_matte_ptr1->set_kd(0.50); 
			sv_matte_ptr1->set_cd(checker_ptr);	
			Plane* plane_ptr = new Plane(Point3D(0, 1, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr1);
			add_object(plane_ptr);
			break;
		}
	case 60:
		{
			//12.17
			if( !CheckFile(QString(ppmfile+"MorningSky.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(200);			
			vp.set_vres(200); 
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);
	
			tracer_ptr = new RayCast(this);	
	
			AmbientOccluder* ambient_occluder_ptr = new AmbientOccluder;
			ambient_occluder_ptr->set_sampler(new MultiJittered(num_samples));
			ambient_occluder_ptr->set_min_amount(0.5);
			set_ambient_light(ambient_occluder_ptr);
	
			Spherical* left_camera_ptr = new Spherical;  
			left_camera_ptr->set_horizontal_fov(180);     
			left_camera_ptr->set_vertical_fov(180);
	
			Spherical* right_camera_ptr = new Spherical;  
			right_camera_ptr->set_horizontal_fov(180);    
			right_camera_ptr->set_vertical_fov(180);
	
	
			StereoCamera* stereo_ptr = new StereoCamera;	
			stereo_ptr->set_left_camera(left_camera_ptr);
			stereo_ptr->set_right_camera(right_camera_ptr);
			stereo_ptr->use_parallel_viewing();
		//	stereo_ptr->use_transverse_viewing();
			stereo_ptr->set_pixel_gap(5);       
			stereo_ptr->set_eye(10, 15, 13);;
			stereo_ptr->set_lookat(34, 15, 0);
			stereo_ptr->compute_uvw();
			stereo_ptr->set_stereo_angle(5.0);  
			stereo_ptr->setup_cameras(); 
			set_camera(stereo_ptr);
	   	
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(150, 500, 300);  
			light_ptr2->scale_radiance(3.75);  
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// city parameters
	
			float 	a					= 10;   // city block width:  xw extent
			float 	b   				= 12;	// city block length:  yw extent
			int 	num_rows			= 10;  	// number of blocks in the xw direction
			int 	num_columns			= 12; 	// number of blocks in the zw direction
			float	width				= 7;	// building width: xw extent in range [min, a - offset]
			float 	length				= 7;	// building length: zw extent in range [min, b - offset]
			float 	min_size			= 6;	// mininum building extent in xw and yw directions
			float 	offset				= 1.0;	// half the minimum distance between buildings
			float 	min_height			= 0.0; 	// minimum building height
			float 	max_height			= 30; 	// maximum bulding height
			float 	height;						// the building height in range [min_height, max_height]
			int		num_park_rows		= 4;  	// number of blocks of park in xw direction
			int		num_park_columns	= 6;  	// number of blocks of park in xw direction
			int 	row_test;					// there are no buildings in the park
			int 	column_test;				// there are no buildings in the park
			float 	min_color			= 0.1;  // prevents black buildings
			float 	max_color			= 0.9;	// prevents white buildings
		
			set_rand_seed(15);  				// as the buildings' dimensions and colors are random, it's necessary to 
												// seed rand to keep these quantities the same at each run
												// if you leave this out, and change the number of samples per pixel,
												// these will change
	
			// the buildings are stored in a grid
	
			Grid* grid_ptr = new Grid;
	
			for (int r = 0; r < num_rows; r++)  			// xw direction
				for (int c = 0; c < num_columns; c++) {		// zw direction
					// determine if the block is in the park
		
					if ((r - num_rows / 2) >= 0)
						row_test = r -  num_rows / 2;
					else
						row_test = r -  num_rows / 2 + 1;
				
					if ((c - num_columns / 2) >= 0)
						column_test = c - num_columns / 2;
					else
						column_test = c - num_columns / 2 + 1;
			
					if (abs(row_test) >= (num_park_rows / 2) || abs(column_test) >= (num_park_columns / 2)) {
		
						Matte* matte_ptr = new Matte;
						matte_ptr->set_ka(0.4); 
						matte_ptr->set_kd(0.6);			
						matte_ptr->set_cd(	min_color + rand_float() * (max_color - min_color), 
											min_color + rand_float() * (max_color - min_color), 
											min_color + rand_float() * (max_color - min_color));    
			
						// block center coordinates
				
						float xc = a * (r - num_rows / 2.0 + 0.5);
						float zc = b * (c - num_columns / 2.0 + 0.5);
				
						width = min_size + rand_float() * (a - 2 * offset - min_size);
						length = min_size + rand_float() * (b - 2 * offset - min_size);	
				
						// minimum building coordinates
				
						float xmin = xc - width / 2.0;
						float ymin = 0.0;
						float zmin = zc - length / 2.0;
				
						// maximum building coordinates
				
						height = min_height + rand_float() * (max_height - min_height);
				
						// The following is a hack to make the middle row and column of buildings higher
						// on average than the other buildings. 
						// This only works properly when there are three rows and columns of buildings
				
						if (r == 1 || r == num_rows - 2 || c == 1 || c == num_columns - 2)
							height *= 1.5;
				
						float xmax = xc + width / 2.0;
						float ymax = height;
						float zmax = zc + length / 2.0;
				
						Box* building_ptr = new  Box(Point3D(xmin, ymin, zmin), Point3D(xmax, ymax, zmax));
						building_ptr->set_material(matte_ptr);
						grid_ptr->add_object(building_ptr);
					}
				}
		
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
	
			// render the park with small green checkers
	
			Checker3D* checker3D_ptr1 = new Checker3D;
			checker3D_ptr1->set_size(5); 
			checker3D_ptr1->set_color1(0.35, 0.75, 0.35);  
			checker3D_ptr1->set_color2(0.3, 0.5, 0.3);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.3);
			sv_matte_ptr1->set_kd(0.50);  
			sv_matte_ptr1->set_cd(checker3D_ptr1);
											
			Box* park_ptr = new Box( 	Point3D(-a * num_park_rows / 2, 0.0, -b * num_park_columns / 2), 
										Point3D(a * num_park_rows / 2, 0.1, b * num_park_columns / 2)  );										
			park_ptr->set_material(sv_matte_ptr1);
			add_object(park_ptr);
											
	
			// ground plane with checker:
	
			Checker3D* checker3D_ptr2 = new Checker3D;
			checker3D_ptr2->set_size(50); 
			checker3D_ptr2->set_color1(RGBColor(0.7));  
			checker3D_ptr2->set_color2(RGBColor(1));
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.30);
			sv_matte_ptr2->set_kd(0.40);  
			sv_matte_ptr2->set_cd(checker3D_ptr2);
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr2);
			add_object(plane_ptr);

	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"MorningSky.ppm").toLatin1().data());	
	
			SphericalMap* spherical_map_ptr = new SphericalMap; 
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(spherical_map_ptr); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85); 
			sv_matte_ptr->set_cd(image_texture_ptr);
		
			Instance* sphere_ptr = new Instance(new Sphere); 
			sphere_ptr->scale(1000000);
			sphere_ptr->set_material(sv_matte_ptr);
			sphere_ptr->set_shadows(false);    // reguired for ambient occlusion to work
			add_object(sphere_ptr);
			break;
		}
	case 61:
		{
			//14p1
			int num_samples = 1;

			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_pixel_size(0.5);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10000);
			pinhole_ptr->set_lookat(0.0);   
			pinhole_ptr->set_view_distance(15000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(100, 100, 200);
			light_ptr->scale_radiance(3.0); 			
			add_light(light_ptr);
	
	
			// colors

			RGBColour yellow(1, 1, 0);										// yellow
			RGBColour brown(0.71, 0.40, 0.16);								// brown
			RGBColour dark_green(0.0, 0.41, 0.41);							// dark_green
			RGBColour orange(1, 0.75, 0);									// orange
			RGBColour green(0, 0.6, 0.3);									// green
			RGBColour light_green(0.65, 1, 0.30);							// light green
			RGBColour dark_yellow(0.61, 0.61, 0);							// dark yellow
			RGBColour light_purple(0.65, 0.3, 1);							// light purple
			RGBColour dark_purple(0.5, 0, 1);								// dark purple
	
	
			// Matt material reflection coefficients
	
			float ka = 0.25;
			float kd = 0.75;
	
	
			// spheres
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(ka);	
			matte_ptr1->set_kd(kd);
			matte_ptr1->set_cd(yellow);				
			Sphere*	sphere_ptr1 = new Sphere(Point3D(5, 3, 0), 30); 
			sphere_ptr1->set_material(matte_ptr1);	   							// yellow
			add_object(sphere_ptr1);
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(ka);	
			matte_ptr2->set_kd(kd);
			matte_ptr2->set_cd(brown);
			Sphere*	sphere_ptr2 = new Sphere(Point3D(45, -7, -60), 20); 
			sphere_ptr2->set_material(matte_ptr2);								// brown
			add_object(sphere_ptr2);
	

			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(ka);	
			matte_ptr3->set_kd(kd);
			matte_ptr3->set_cd(dark_green);	
			Sphere*	sphere_ptr3 = new Sphere(Point3D(40, 43, -100), 17); 
			sphere_ptr3->set_material(matte_ptr3);								// dark green
			add_object(sphere_ptr3);
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(ka);	
			matte_ptr4->set_kd(kd);
			matte_ptr4->set_cd(orange);
			Sphere*	sphere_ptr4 = new Sphere(Point3D(-20, 28, -15), 20); 
			sphere_ptr4->set_material(matte_ptr4);								// orange
			add_object(sphere_ptr4);
	
			Matte* matte_ptr5 = new Matte;
			matte_ptr5->set_ka(ka);	
			matte_ptr5->set_kd(kd);
			matte_ptr5->set_cd(green);
			Sphere*	sphere_ptr5 = new Sphere(Point3D(-25, -7, -35), 27); 			
			sphere_ptr5->set_material(matte_ptr5);								// green
			add_object(sphere_ptr5);
	
			Matte* matte_ptr6 = new Matte;
			matte_ptr6->set_ka(ka);	
			matte_ptr6->set_kd(kd);
			matte_ptr6->set_cd(light_green);
			Sphere*	sphere_ptr6 = new Sphere(Point3D(20, -27, -35), 25); 
			sphere_ptr6->set_material(matte_ptr6);								// light green
			add_object(sphere_ptr6);
	
			Matte* matte_ptr7 = new Matte;
			matte_ptr7->set_ka(ka);	
			matte_ptr7->set_kd(kd);
			matte_ptr7->set_cd(green);
			Sphere*	sphere_ptr7 = new Sphere(Point3D(35, 18, -35), 22); 
			sphere_ptr7->set_material(matte_ptr7);   							// green
			add_object(sphere_ptr7);
	
			Matte* matte_ptr8 = new Matte;
			matte_ptr8->set_ka(ka);	
			matte_ptr8->set_kd(kd);
			matte_ptr8->set_cd(brown);
			Sphere*	sphere_ptr8 = new Sphere(Point3D(-57, -17, -50), 15);  
			sphere_ptr8->set_material(matte_ptr8);								// brown
			add_object(sphere_ptr8);
	
			Matte* matte_ptr9 = new Matte;
			matte_ptr9->set_ka(ka);	
			matte_ptr9->set_kd(kd);
			matte_ptr9->set_cd(light_green);
			Sphere*	sphere_ptr9 = new Sphere(Point3D(-47, 16, -80), 23); 
			sphere_ptr9->set_material(matte_ptr9);								// light green
			add_object(sphere_ptr9);
		
			Matte* matte_ptr10 = new Matte;
			matte_ptr10->set_ka(ka);	
			matte_ptr10->set_kd(kd);
			matte_ptr10->set_cd(dark_green);	
			Sphere*	sphere_ptr10 = new Sphere(Point3D(-15, -32, -60), 22); 
			sphere_ptr10->set_material(matte_ptr10);     						// dark green
			add_object(sphere_ptr10);
	
			Matte* matte_ptr11 = new Matte;
			matte_ptr11->set_ka(ka);	
			matte_ptr11->set_kd(kd);
			matte_ptr11->set_cd(dark_yellow);
			Sphere*	sphere_ptr11 = new Sphere(Point3D(-35, -37, -80), 22); 
			sphere_ptr11->set_material(matte_ptr11);							// dark yellow
			add_object(sphere_ptr11);
	
			Matte* matte_ptr12 = new Matte;
			matte_ptr12->set_ka(ka);	
			matte_ptr12->set_kd(kd);
			matte_ptr12->set_cd(dark_yellow);
			Sphere*	sphere_ptr12 = new Sphere(Point3D(10, 43, -80), 22); 
			sphere_ptr12->set_material(matte_ptr12);							// dark yellow
			add_object(sphere_ptr12);
	
			Matte* matte_ptr13 = new Matte;
			matte_ptr13->set_ka(ka);	
			matte_ptr13->set_kd(kd);
			matte_ptr13->set_cd(dark_yellow);		
			Sphere*	sphere_ptr13 = new Sphere(Point3D(30, -7, -80), 10); 
			sphere_ptr13->set_material(matte_ptr13);
			add_object(sphere_ptr13);											// dark yellow (hidden)
	
			Matte* matte_ptr14 = new Matte;
			matte_ptr14->set_ka(ka);	
			matte_ptr14->set_kd(kd);
			matte_ptr14->set_cd(dark_green);	
			Sphere*	sphere_ptr14 = new Sphere(Point3D(-40, 48, -110), 18); 
			sphere_ptr14->set_material(matte_ptr14); 							// dark green
			add_object(sphere_ptr14);
	
			Matte* matte_ptr15 = new Matte;
			matte_ptr15->set_ka(ka);	
			matte_ptr15->set_kd(kd);
			matte_ptr15->set_cd(brown);	
			Sphere*	sphere_ptr15 = new Sphere(Point3D(-10, 53, -120), 18); 
			sphere_ptr15->set_material(matte_ptr15); 							// brown
			add_object(sphere_ptr15);
	
			Matte* matte_ptr16 = new Matte;
			matte_ptr16->set_ka(ka);	
			matte_ptr16->set_kd(kd);
			matte_ptr16->set_cd(light_purple);
			Sphere*	sphere_ptr16 = new Sphere(Point3D(-55, -52, -100), 10); 
			sphere_ptr16->set_material(matte_ptr16);							// light purple
			add_object(sphere_ptr16);
	
			Matte* matte_ptr17 = new Matte;
			matte_ptr17->set_ka(ka);	
			matte_ptr17->set_kd(kd);
			matte_ptr17->set_cd(brown);
			Sphere*	sphere_ptr17 = new Sphere(Point3D(5, -52, -100), 15); 		
			sphere_ptr17->set_material(matte_ptr17);							// browm
			add_object(sphere_ptr17);
	
			Matte* matte_ptr18 = new Matte;
			matte_ptr18->set_ka(ka);	
			matte_ptr18->set_kd(kd);
			matte_ptr18->set_cd(dark_purple);
			Sphere*	sphere_ptr18 = new Sphere(Point3D(-20, -57, -120), 15); 
			sphere_ptr18->set_material(matte_ptr18);							// dark purple
			add_object(sphere_ptr18);
	
			Matte* matte_ptr19 = new Matte;
			matte_ptr19->set_ka(ka);	
			matte_ptr19->set_kd(kd);
			matte_ptr19->set_cd(dark_green);
			Sphere*	sphere_ptr19 = new Sphere(Point3D(55, -27, -100), 17); 
			sphere_ptr19->set_material(matte_ptr19);							// dark green
			add_object(sphere_ptr19);

			Matte* matte_ptr20 = new Matte;
			matte_ptr20->set_ka(ka);	
			matte_ptr20->set_kd(kd);
			matte_ptr20->set_cd(brown);
			Sphere*	sphere_ptr20 = new Sphere(Point3D(50, -47, -120), 15); 
			sphere_ptr20->set_material(matte_ptr20);							// browm
			add_object(sphere_ptr20);
	 
			Matte* matte_ptr21 = new Matte;
			matte_ptr21->set_ka(ka);	
			matte_ptr21->set_kd(kd);
			matte_ptr21->set_cd(light_purple); 	
			Sphere*	sphere_ptr21 = new Sphere(Point3D(70, -42, -150), 10); 
			sphere_ptr21->set_material(matte_ptr21);							// light purple
			add_object(sphere_ptr21);
	
			Matte* matte_ptr22 = new Matte;
			matte_ptr22->set_ka(ka);	
			matte_ptr22->set_kd(kd);
			matte_ptr22->set_cd(light_purple);
			Sphere*	sphere_ptr22 = new Sphere(Point3D(5, 73, -130), 12); 
			sphere_ptr22->set_material(matte_ptr22);							// light purple
			add_object(sphere_ptr22);
	
			Matte* matte_ptr23 = new Matte;
			matte_ptr23->set_ka(ka);	
			matte_ptr23->set_kd(kd);
			matte_ptr23->set_cd(dark_purple);
			Sphere*	sphere_ptr23 = new Sphere(Point3D(66, 21, -130), 13); 			
			sphere_ptr23->set_material(matte_ptr23);							// dark purple
			add_object(sphere_ptr23);	
	
			Matte* matte_ptr24 = new Matte;
			matte_ptr24->set_ka(ka);	
			matte_ptr24->set_kd(kd);
			matte_ptr24->set_cd(light_purple);  
			Sphere*	sphere_ptr24 = new Sphere(Point3D(72, -12, -140), 12); 
			sphere_ptr24->set_material(matte_ptr24);							// light purple
			add_object(sphere_ptr24);
	
			Matte* matte_ptr25 = new Matte;
			matte_ptr25->set_ka(ka);	
			matte_ptr25->set_kd(kd);
			matte_ptr25->set_cd(green);
			Sphere*	sphere_ptr25 = new Sphere(Point3D(64, 5, -160), 11); 			
			sphere_ptr25->set_material(matte_ptr25);					 		// green
			add_object(sphere_ptr25);
	  
			Matte* matte_ptr26 = new Matte;
			matte_ptr26->set_ka(ka);	
			matte_ptr26->set_kd(kd);
			matte_ptr26->set_cd(light_purple);
			Sphere*	sphere_ptr26 = new Sphere(Point3D(55, 38, -160), 12); 		
			sphere_ptr26->set_material(matte_ptr26);							// light purple
			add_object(sphere_ptr26);
	
			Matte* matte_ptr27 = new Matte;
			matte_ptr27->set_ka(ka);	
			matte_ptr27->set_kd(kd);
			matte_ptr27->set_cd(light_purple);
			Sphere*	sphere_ptr27 = new Sphere(Point3D(-73, -2, -160), 12); 		
			sphere_ptr27->set_material(matte_ptr27);							// light purple
			add_object(sphere_ptr27);
	 
			Matte* matte_ptr28 = new Matte;
			matte_ptr28->set_ka(ka);	
			matte_ptr28->set_kd(kd);
			matte_ptr28->set_cd(dark_purple);
			Sphere*	sphere_ptr28 = new Sphere(Point3D(30, -62, -140), 15); 
			sphere_ptr28->set_material(matte_ptr28); 							// dark purple
			add_object(sphere_ptr28);
	
			Matte* matte_ptr29 = new Matte;
			matte_ptr29->set_ka(ka);	
			matte_ptr29->set_kd(kd);
			matte_ptr29->set_cd(dark_purple);
			Sphere*	sphere_ptr29 = new Sphere(Point3D(25, 63, -140), 15); 
			sphere_ptr29->set_material(matte_ptr29);							// dark purple
			add_object(sphere_ptr29);
	
			Matte* matte_ptr30 = new Matte;
			matte_ptr30->set_ka(ka);	
			matte_ptr30->set_kd(kd);
			matte_ptr30->set_cd(dark_purple);
			Sphere*	sphere_ptr30 = new Sphere(Point3D(-60, 46, -140), 15);  
			sphere_ptr30->set_material(matte_ptr30); 							// dark purple
			add_object(sphere_ptr30);
	
			Matte* matte_ptr31 = new Matte;
			matte_ptr31->set_ka(ka);	
			matte_ptr31->set_kd(kd);
			matte_ptr31->set_cd(light_purple);
			Sphere*	sphere_ptr31 = new Sphere(Point3D(-30, 68, -130), 12); 
			sphere_ptr31->set_material(matte_ptr31); 							// light purple
			add_object(sphere_ptr31);
	
			Matte* matte_ptr32 = new Matte;
			matte_ptr32->set_ka(ka);	
			matte_ptr32->set_kd(kd);
			matte_ptr32->set_cd(green);
			Sphere*	sphere_ptr32 = new Sphere(Point3D(58, 56, -180), 11);   
			sphere_ptr32->set_material(matte_ptr32);							//  green
			add_object(sphere_ptr32);
	
			Matte* matte_ptr33 = new Matte;
			matte_ptr33->set_ka(ka);	
			matte_ptr33->set_kd(kd);
			matte_ptr33->set_cd(green);
			Sphere*	sphere_ptr33 = new Sphere(Point3D(-63, -39, -180), 11); 
			sphere_ptr33->set_material(matte_ptr33);							// green 
			add_object(sphere_ptr33);
	
			Matte* matte_ptr34 = new Matte;
			matte_ptr34->set_ka(ka);	
			matte_ptr34->set_kd(kd);
			matte_ptr34->set_cd(light_purple);
			Sphere*	sphere_ptr34 = new Sphere(Point3D(46, 68, -200), 10); 	
			sphere_ptr34->set_material(matte_ptr34);							// light purple
			add_object(sphere_ptr34);
	
			Matte* matte_ptr35 = new Matte;
			matte_ptr35->set_ka(ka);	
			matte_ptr35->set_kd(kd);
			matte_ptr35->set_cd(light_purple);
			Sphere*	sphere_ptr35 = new Sphere(Point3D(-3, -72, -130), 12); 
			sphere_ptr35->set_material(matte_ptr35);							// light purple
			add_object(sphere_ptr35);
			break;
		}
	case 62:
		{
			//14.05
			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			float a = 0.75;
			background_color = RGBColor(0.0, 0.3 * a, 0.25 * a);  // torquise
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7.5, 4, 10); 
			pinhole_ptr->set_lookat(-1, 3.7, 0);  
			pinhole_ptr->set_view_distance(340);		
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
		
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.25);
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.75, 0.75, 0);    	// dark yellow
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.45); 
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(0.75, 0.25, 0);  	 // orange
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(0.4); 
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(1, 0.5, 1);  		// mauve
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(0.25);				// here used ka which is undefined, we make it 0.25 instead 
			matte_ptr4->set_ka(0.15);
			matte_ptr4->set_kd(0.5);
			matte_ptr4->set_cd(0.75, 1.0, 0.75);   	// light green
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(0.20); 
			matte_ptr5->set_kd(0.97);	
			matte_ptr5->set_cd(white);  	
	
			// spheres
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(3.85, 2.3, -2.55), 2.3);
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-0.7, 1, 4.2), 2);
			sphere_ptr2->set_material(matte_ptr2);     
			add_object(sphere_ptr2);

			// cylinder 
	
			float bottom 	= 0.0;
			float top 		= 8.5;   
			float radius	= 2.2;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr3);
			add_object(cylinder_ptr);
	
			// box
		
			Box* box_ptr = new Box(Point3D(-3.5, 0, -11), Point3D(-2.5, 6, 6.5));
			box_ptr->set_material(matte_ptr4);
			add_object(box_ptr);
	
			// ground plane
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr5);
			add_object(plane_ptr);
			break;
		}
	case 63:
		{
			//14.07
			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			float a = 0.75;
			background_color = RGBColor(0.0, 0.3 * a, 0.25 * a);  // torquise
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7.5, 4, 10); 
			pinhole_ptr->set_lookat(-1, 3.7, 0);  
			pinhole_ptr->set_view_distance(340);		
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(15, 15, 2.5); 
			light_ptr->scale_radiance(2.0);	
			add_light(light_ptr);
		
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.25);
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.75, 0.75, 0);    	// dark yellow
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.45); 
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(0.75, 0.25, 0);  	 // orange
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(0.4); 
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(1, 0.5, 1);  		// mauve
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(0.25);
			matte_ptr4->set_ka(0.15);
			matte_ptr4->set_kd(0.5);
			matte_ptr4->set_cd(0.75, 1.0, 0.75);   	// light green
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(0.20); 
			matte_ptr5->set_kd(0.97);	
			matte_ptr5->set_cd(white);  
	
	
	
			// spheres
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(3.85, 2.3, -2.55), 2.3);
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-0.7, 1, 4.2), 2);
			sphere_ptr2->set_material(matte_ptr2);     
			add_object(sphere_ptr2);

			// cylinder 
	
			float bottom 	= 0.0;
			float top 		= 8.5;   
			float radius	= 2.2;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr3);
			add_object(cylinder_ptr);
	
			// box
		
			Box* box_ptr = new Box(Point3D(-3.5, 0, -11), Point3D(-2.5, 6, 6.5));
			box_ptr->set_material(matte_ptr4);
			add_object(box_ptr);
	
			// ground plane
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr5);
			add_object(plane_ptr);
			break;
		}
	case 64:
		{
			//14.10
			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			float a = 0.75;
			background_color = RGBColor(0.0, 0.3 * a, 0.25 * a);  // torquise
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7.5, 4, 10); 
			pinhole_ptr->set_lookat(-1, 3.7, 0);  
			pinhole_ptr->set_view_distance(340);		
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(15, 15, 2.5); 
			light_ptr->scale_radiance(2.0);	
			add_light(light_ptr);
		
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.25);
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.75, 0.75, 0);    	// dark yellow
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.45); 
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(0.75, 0.25, 0);  	 // orange
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(0.4); 
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(1, 0.5, 1);  		// mauve
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(0.25);
			matte_ptr4->set_ka(0.15);
			matte_ptr4->set_kd(0.5);
			matte_ptr4->set_cd(0.75, 1.0, 0.75);   	// light green
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(0.20); 
			matte_ptr5->set_kd(0.97);	
			matte_ptr5->set_cd(white);  
	
	
	
			// spheres
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(3.85, 2.3, -2.55), 2.3);
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-0.7, 1, 4.2), 2);
			sphere_ptr2->set_material(matte_ptr2);     
			add_object(sphere_ptr2);

			// cylinder 
	
			float bottom 	= 0.0;
			float top 		= 8.5;   
			float radius	= 2.2;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr3);
			add_object(cylinder_ptr);
	
			// box
		
			Box* box_ptr = new Box(Point3D(-3.5, 0, -11), Point3D(-2.5, 6, 6.5));
			box_ptr->set_material(matte_ptr4);
			add_object(box_ptr);
	
			// ground plane
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr5);
			add_object(plane_ptr);
			break;
		}
	case 65:
		{
			//14.11a
			int num_samples = 1;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			float a = 0.75;
			background_color = RGBColour(0.0, 0.3 * a, 0.25 * a);  // torquise
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(75, 30, 100);
			pinhole_ptr->set_lookat(-1, 3.7, 0); 
			pinhole_ptr->set_view_distance(800); 
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(15, 15, 2.5); 
			light_ptr1->scale_radiance(2.0);	
			add_light(light_ptr1);					// for Figure 14.11 (a) and (b)
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(15, 15, 2.5); 
			light_ptr2->scale_radiance(2.0);	
			//	add_light(light_ptr2);					// for Figure 14.11 (c)
	
	
			// a small emissive sphere at the location of the point light
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(white);		
			emissive_ptr->scale_radiance(1.0);  
	
			Sphere* sphere_ptr0 = new Sphere(Point3D(15, 15, 2.5), 0.75); 
			sphere_ptr0->set_material(emissive_ptr);
			add_object(sphere_ptr0);
		
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.25);
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.75, 0.75, 0);    	// dark yellow
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.45); 
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(0.75, 0.25, 0);  	 // orange
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(0.4); 
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(1, 0.5, 1);  		// mauve
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(0.25);
			matte_ptr4->set_ka(0.15);
			matte_ptr4->set_kd(0.5);
			matte_ptr4->set_cd(0.75, 1.0, 0.75);   	// light green
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(0.20); 
			matte_ptr5->set_kd(0.97);	
			matte_ptr5->set_cd(white);  

			// spheres
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(3.85, 2.3, -2.55), 2.3);
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-0.7, 1, 4.2), 2);
			sphere_ptr2->set_material(matte_ptr2);     
			add_object(sphere_ptr2);

			// cylinder 
	
			float bottom 	= 0.0;
			float top 		= 8.5;   
			float radius	= 2.2;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr3);
			add_object(cylinder_ptr);
	
			// box
		
			Box* box_ptr = new Box(Point3D(-3.5, 0, -11), Point3D(-2.5, 6, 6.5));
			box_ptr->set_material(matte_ptr4);
			add_object(box_ptr);
	
			// ground plane
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr5);
			add_object(plane_ptr);
			break;
		}
	case 66:
		{
			//14.11b
			int num_samples = 1;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			float a = 0.75;
			background_color = RGBColour(0.0, 0.3 * a, 0.25 * a);  // torquise
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(75, 30, 100);
			pinhole_ptr->set_lookat(-1, 3.7, 0); 
			pinhole_ptr->set_view_distance(800); 
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(15, 15, 2.5); 
			light_ptr1->scale_radiance(2.0);	
			add_light(light_ptr1);					// for Figure 14.11 (a) and (b)
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(15, 15, 2.5); 
			light_ptr2->scale_radiance(2.0);	
			//	add_light(light_ptr2);					// for Figure 14.11 (c)
	
	
			// a small emissive sphere at the location of the point light
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(white);		
			emissive_ptr->scale_radiance(1.0);  
	
			Sphere* sphere_ptr0 = new Sphere(Point3D(15, 15, 2.5), 0.75); 
			sphere_ptr0->set_material(emissive_ptr);
			add_object(sphere_ptr0);
		
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.25);
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.75, 0.75, 0);    	// dark yellow
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.45); 
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(0.75, 0.25, 0);  	 // orange
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(0.4); 
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(1, 0.5, 1);  		// mauve
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(0.25);
			matte_ptr4->set_ka(0.15);
			matte_ptr4->set_kd(0.5);
			matte_ptr4->set_cd(0.75, 1.0, 0.75);   	// light green
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(0.40); 
			matte_ptr5->set_kd(0.97);	
			matte_ptr5->set_cd(white);  

			// spheres
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(3.85, 2.3, -2.55), 2.3);
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-0.7, 1, 4.2), 2);
			sphere_ptr2->set_material(matte_ptr2);     
			add_object(sphere_ptr2);

			// cylinder 
	
			float bottom 	= 0.0;
			float top 		= 8.5;   
			float radius	= 2.2;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr3);
			add_object(cylinder_ptr);
	
			// box
		
			Box* box_ptr = new Box(Point3D(-3.5, 0, -11), Point3D(-2.5, 6, 6.5));
			box_ptr->set_material(matte_ptr4);
			add_object(box_ptr);
	
			// ground plane
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr5);
			add_object(plane_ptr);
			break;
		}
	case 67:
		{
			//14.11c
			int num_samples = 1;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			float a = 0.75;
			background_color = RGBColour(0.0, 0.3 * a, 0.25 * a);  // torquise
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(75, 30, 100);
			pinhole_ptr->set_lookat(-1, 3.7, 0); 
			pinhole_ptr->set_view_distance(800); 
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(15, 15, 2.5); 
			light_ptr1->scale_radiance(2.0);	
			//add_light(light_ptr1);					// for Figure 14.11 (a) and (b)
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(15, 15, 2.5); 
			light_ptr2->scale_radiance(2.0);	
			add_light(light_ptr2);					// for Figure 14.11 (c)
	
	
			// a small emissive sphere at the location of the point light
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(white);		
			emissive_ptr->scale_radiance(1.0);  
	
			Sphere* sphere_ptr0 = new Sphere(Point3D(15, 15, 2.5), 0.75); 
			sphere_ptr0->set_material(emissive_ptr);
			add_object(sphere_ptr0);
		
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.25);
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.75, 0.75, 0);    	// dark yellow
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.45); 
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(0.75, 0.25, 0);  	 // orange
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(0.4); 
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(1, 0.5, 1);  		// mauve
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(0.25);
			matte_ptr4->set_ka(0.15);
			matte_ptr4->set_kd(0.5);
			matte_ptr4->set_cd(0.75, 1.0, 0.75);   	// light green
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(0.20); 
			matte_ptr5->set_kd(0.97);	
			matte_ptr5->set_cd(white);  

			// spheres
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(3.85, 2.3, -2.55), 2.3);
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-0.7, 1, 4.2), 2);
			sphere_ptr2->set_material(matte_ptr2);     
			add_object(sphere_ptr2);

			// cylinder 
	
			float bottom 	= 0.0;
			float top 		= 8.5;   
			float radius	= 2.2;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr3);
			add_object(cylinder_ptr);
	
			// box
		
			Box* box_ptr = new Box(Point3D(-3.5, 0, -11), Point3D(-2.5, 6, 6.5));
			box_ptr->set_material(matte_ptr4);
			add_object(box_ptr);
	
			// ground plane
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr5);
			add_object(plane_ptr);
			break;
		}
	case 68:
		{
			//14.15
			int num_samples = 1;
	
			vp.set_hres(650);	  		
			vp.set_vres(300);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0, 0, 0);
			pinhole_ptr->set_view_distance(6000); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(20, 0, 20);
			light_ptr2->scale_radiance(3.0);
			add_light(light_ptr2);
	
			// beveled cylinder
	
			float bottom 		= -2.0;
			float top 			= 2.0;
			float radius 		= 1.0;
			float bevel_radius 	= 0.2;
	
			BeveledCylinder* cylinder_ptr1 = new BeveledCylinder(bottom, top, radius, bevel_radius);
	
			for (int j = 0; j < 4; j++) {
	
				Matte* matte_ptr = new Matte;
				matte_ptr->set_ka(0.25); 					
				matte_ptr->set_kd(0.1 + 0.3 * j);
				matte_ptr->set_cd(0.5);
	
				Instance* cylinder_ptr2 = new Instance(cylinder_ptr1);
				cylinder_ptr2->translate(-3.75 + 2.5 * j, 0, 0);
				cylinder_ptr2->set_material(matte_ptr);
				add_object(cylinder_ptr2);
			}
			break;
		}
	case 69:
		{
			//14.21
			int num_samples = 16;

			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_pixel_size(0.5);
			vp.set_samples(num_samples); 
	
			tracer_ptr = new RayCast(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(1.0);
			set_ambient_light(ambient_ptr);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 500);
			pinhole_ptr->set_lookat(-5, 0, 0); 
			pinhole_ptr->set_vpd(850.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(100, 50, 150);
			light_ptr2->scale_radiance(3.0); 
			add_light(light_ptr2);

			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.25);	
			matte_ptr1->set_kd(0.65);
			matte_ptr1->set_cd(1, 1, 0);	  				// yellow	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(10, -5, 0), 27); 
			sphere_ptr1->set_material(matte_ptr1);	   							
			add_object(sphere_ptr1);
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(0.15);	
			matte_ptr2->set_kd(0.85);
			matte_ptr2->set_cd(0.71, 0.40, 0.16);   		// brown
			Sphere*	sphere_ptr2 = new Sphere(Point3D(-25, 10, -35), 27); 			
			sphere_ptr2->set_material(matte_ptr2);							
			add_object(sphere_ptr2);
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.15);	
			matte_ptr3->set_kd(0.5);
			matte_ptr3->set_cd(0, 0.4, 0.2);				// dark green
			Plane* plane_ptr = new Plane(Point3D(0, 0, -50), Normal(0, 0, 1)); 
			plane_ptr->set_material(matte_ptr3);								
			add_object(plane_ptr);
			break;
		}
	case 70:
		{
			//14.22a
			int num_samples = 16;

			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_pixel_size(0.5);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10000);
			pinhole_ptr->set_lookat(0.0);   
			pinhole_ptr->set_view_distance(15000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(100, 100, 200);
			light_ptr->set_color(1.0, 1.0, 1.0); 	
			light_ptr->scale_radiance(3.0);        	// for Figure 14.22 (a)
		//	light_ptr->scale_radiance(4.5); 	  	// for Figure 14.22 (b)		
			add_light(light_ptr);
	
	
			// colors

			RGBColour yellow(1, 1, 0);										// yellow
			RGBColour brown(0.71, 0.40, 0.16);								// brown
			RGBColour dark_green(0.0, 0.41, 0.41);							// dark_green
			RGBColour orange(1, 0.75, 0);									// orange
			RGBColour green(0, 0.6, 0.3);									// green
			RGBColour light_green(0.65, 1, 0.30);							// light green
			RGBColour dark_yellow(0.61, 0.61, 0);							// dark yellow
			RGBColour light_purple(0.65, 0.3, 1);							// light purple
			RGBColour dark_purple(0.5, 0, 1);								// dark purple
	
	
			// Matt material reflection coefficients
	
			float ka = 0.25;
			float kd = 0.75;
	
	
			// spheres
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(ka);	
			matte_ptr1->set_kd(kd);
			matte_ptr1->set_cd(yellow);				
			Sphere*	sphere_ptr1 = new Sphere(Point3D(5, 3, 0), 30); 
			sphere_ptr1->set_material(matte_ptr1);	   							// yellow
			add_object(sphere_ptr1);
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(ka);	
			matte_ptr2->set_kd(kd);
			matte_ptr2->set_cd(brown);
			Sphere*	sphere_ptr2 = new Sphere(Point3D(45, -7, -60), 20); 
			sphere_ptr2->set_material(matte_ptr2);								// brown
			add_object(sphere_ptr2);
	

			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(ka);	
			matte_ptr3->set_kd(kd);
			matte_ptr3->set_cd(dark_green);	
			Sphere*	sphere_ptr3 = new Sphere(Point3D(40, 43, -100), 17); 
			sphere_ptr3->set_material(matte_ptr3);								// dark green
			add_object(sphere_ptr3);
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(ka);	
			matte_ptr4->set_kd(kd);
			matte_ptr4->set_cd(orange);
			Sphere*	sphere_ptr4 = new Sphere(Point3D(-20, 28, -15), 20); 
			sphere_ptr4->set_material(matte_ptr4);								// orange
			add_object(sphere_ptr4);
	
			Matte* matte_ptr5 = new Matte;
			matte_ptr5->set_ka(ka);	
			matte_ptr5->set_kd(kd);
			matte_ptr5->set_cd(green);
			Sphere*	sphere_ptr5 = new Sphere(Point3D(-25, -7, -35), 27); 			
			sphere_ptr5->set_material(matte_ptr5);								// green
			add_object(sphere_ptr5);
	
			Matte* matte_ptr6 = new Matte;
			matte_ptr6->set_ka(ka);	
			matte_ptr6->set_kd(kd);
			matte_ptr6->set_cd(light_green);
			Sphere*	sphere_ptr6 = new Sphere(Point3D(20, -27, -35), 25); 
			sphere_ptr6->set_material(matte_ptr6);								// light green
			add_object(sphere_ptr6);
	
			Matte* matte_ptr7 = new Matte;
			matte_ptr7->set_ka(ka);	
			matte_ptr7->set_kd(kd);
			matte_ptr7->set_cd(green);
			Sphere*	sphere_ptr7 = new Sphere(Point3D(35, 18, -35), 22); 
			sphere_ptr7->set_material(matte_ptr7);   							// green
			add_object(sphere_ptr7);
	
			Matte* matte_ptr8 = new Matte;
			matte_ptr8->set_ka(ka);	
			matte_ptr8->set_kd(kd);
			matte_ptr8->set_cd(brown);
			Sphere*	sphere_ptr8 = new Sphere(Point3D(-57, -17, -50), 15);  
			sphere_ptr8->set_material(matte_ptr8);								// brown
			add_object(sphere_ptr8);
	
			Matte* matte_ptr9 = new Matte;
			matte_ptr9->set_ka(ka);	
			matte_ptr9->set_kd(kd);
			matte_ptr9->set_cd(light_green);
			Sphere*	sphere_ptr9 = new Sphere(Point3D(-47, 16, -80), 23); 
			sphere_ptr9->set_material(matte_ptr9);								// light green
			add_object(sphere_ptr9);
		
			Matte* matte_ptr10 = new Matte;
			matte_ptr10->set_ka(ka);	
			matte_ptr10->set_kd(kd);
			matte_ptr10->set_cd(dark_green);	
			Sphere*	sphere_ptr10 = new Sphere(Point3D(-15, -32, -60), 22); 
			sphere_ptr10->set_material(matte_ptr10);     						// dark green
			add_object(sphere_ptr10);
	
			Matte* matte_ptr11 = new Matte;
			matte_ptr11->set_ka(ka);	
			matte_ptr11->set_kd(kd);
			matte_ptr11->set_cd(dark_yellow);
			Sphere*	sphere_ptr11 = new Sphere(Point3D(-35, -37, -80), 22); 
			sphere_ptr11->set_material(matte_ptr11);							// dark yellow
			add_object(sphere_ptr11);
	
			Matte* matte_ptr12 = new Matte;
			matte_ptr12->set_ka(ka);	
			matte_ptr12->set_kd(kd);
			matte_ptr12->set_cd(dark_yellow);
			Sphere*	sphere_ptr12 = new Sphere(Point3D(10, 43, -80), 22); 
			sphere_ptr12->set_material(matte_ptr12);							// dark yellow
			add_object(sphere_ptr12);
	
			Matte* matte_ptr13 = new Matte;
			matte_ptr13->set_ka(ka);	
			matte_ptr13->set_kd(kd);
			matte_ptr13->set_cd(dark_yellow);		
			Sphere*	sphere_ptr13 = new Sphere(Point3D(30, -7, -80), 10); 
			sphere_ptr13->set_material(matte_ptr13);
			add_object(sphere_ptr13);											// dark yellow (hidden)
	
			Matte* matte_ptr14 = new Matte;
			matte_ptr14->set_ka(ka);	
			matte_ptr14->set_kd(kd);
			matte_ptr14->set_cd(dark_green);	
			Sphere*	sphere_ptr14 = new Sphere(Point3D(-40, 48, -110), 18); 
			sphere_ptr14->set_material(matte_ptr14); 							// dark green
			add_object(sphere_ptr14);
	
			Matte* matte_ptr15 = new Matte;
			matte_ptr15->set_ka(ka);	
			matte_ptr15->set_kd(kd);
			matte_ptr15->set_cd(brown);	
			Sphere*	sphere_ptr15 = new Sphere(Point3D(-10, 53, -120), 18); 
			sphere_ptr15->set_material(matte_ptr15); 							// brown
			add_object(sphere_ptr15);
	
			Matte* matte_ptr16 = new Matte;
			matte_ptr16->set_ka(ka);	
			matte_ptr16->set_kd(kd);
			matte_ptr16->set_cd(light_purple);
			Sphere*	sphere_ptr16 = new Sphere(Point3D(-55, -52, -100), 10); 
			sphere_ptr16->set_material(matte_ptr16);							// light purple
			add_object(sphere_ptr16);
	
			Matte* matte_ptr17 = new Matte;
			matte_ptr17->set_ka(ka);	
			matte_ptr17->set_kd(kd);
			matte_ptr17->set_cd(brown);
			Sphere*	sphere_ptr17 = new Sphere(Point3D(5, -52, -100), 15); 		
			sphere_ptr17->set_material(matte_ptr17);							// browm
			add_object(sphere_ptr17);
	
			Matte* matte_ptr18 = new Matte;
			matte_ptr18->set_ka(ka);	
			matte_ptr18->set_kd(kd);
			matte_ptr18->set_cd(dark_purple);
			Sphere*	sphere_ptr18 = new Sphere(Point3D(-20, -57, -120), 15); 
			sphere_ptr18->set_material(matte_ptr18);							// dark purple
			add_object(sphere_ptr18);
	
			Matte* matte_ptr19 = new Matte;
			matte_ptr19->set_ka(ka);	
			matte_ptr19->set_kd(kd);
			matte_ptr19->set_cd(dark_green);
			Sphere*	sphere_ptr19 = new Sphere(Point3D(55, -27, -100), 17); 
			sphere_ptr19->set_material(matte_ptr19);							// dark green
			add_object(sphere_ptr19);

			Matte* matte_ptr20 = new Matte;
			matte_ptr20->set_ka(ka);	
			matte_ptr20->set_kd(kd);
			matte_ptr20->set_cd(brown);
			Sphere*	sphere_ptr20 = new Sphere(Point3D(50, -47, -120), 15); 
			sphere_ptr20->set_material(matte_ptr20);							// browm
			add_object(sphere_ptr20);
	 
			Matte* matte_ptr21 = new Matte;
			matte_ptr21->set_ka(ka);	
			matte_ptr21->set_kd(kd);
			matte_ptr21->set_cd(light_purple); 	
			Sphere*	sphere_ptr21 = new Sphere(Point3D(70, -42, -150), 10); 
			sphere_ptr21->set_material(matte_ptr21);							// light purple
			add_object(sphere_ptr21);
	
			Matte* matte_ptr22 = new Matte;
			matte_ptr22->set_ka(ka);	
			matte_ptr22->set_kd(kd);
			matte_ptr22->set_cd(light_purple);
			Sphere*	sphere_ptr22 = new Sphere(Point3D(5, 73, -130), 12); 
			sphere_ptr22->set_material(matte_ptr22);							// light purple
			add_object(sphere_ptr22);
	
			Matte* matte_ptr23 = new Matte;
			matte_ptr23->set_ka(ka);	
			matte_ptr23->set_kd(kd);
			matte_ptr23->set_cd(dark_purple);
			Sphere*	sphere_ptr23 = new Sphere(Point3D(66, 21, -130), 13); 			
			sphere_ptr23->set_material(matte_ptr23);							// dark purple
			add_object(sphere_ptr23);	
	
			Matte* matte_ptr24 = new Matte;
			matte_ptr24->set_ka(ka);	
			matte_ptr24->set_kd(kd);
			matte_ptr24->set_cd(light_purple);  
			Sphere*	sphere_ptr24 = new Sphere(Point3D(72, -12, -140), 12); 
			sphere_ptr24->set_material(matte_ptr24);							// light purple
			add_object(sphere_ptr24);
	
			Matte* matte_ptr25 = new Matte;
			matte_ptr25->set_ka(ka);	
			matte_ptr25->set_kd(kd);
			matte_ptr25->set_cd(green);
			Sphere*	sphere_ptr25 = new Sphere(Point3D(64, 5, -160), 11); 			
			sphere_ptr25->set_material(matte_ptr25);					 		// green
			add_object(sphere_ptr25);
	  
			Matte* matte_ptr26 = new Matte;
			matte_ptr26->set_ka(ka);	
			matte_ptr26->set_kd(kd);
			matte_ptr26->set_cd(light_purple);
			Sphere*	sphere_ptr26 = new Sphere(Point3D(55, 38, -160), 12); 		
			sphere_ptr26->set_material(matte_ptr26);							// light purple
			add_object(sphere_ptr26);
	
			Matte* matte_ptr27 = new Matte;
			matte_ptr27->set_ka(ka);	
			matte_ptr27->set_kd(kd);
			matte_ptr27->set_cd(light_purple);
			Sphere*	sphere_ptr27 = new Sphere(Point3D(-73, -2, -160), 12); 		
			sphere_ptr27->set_material(matte_ptr27);							// light purple
			add_object(sphere_ptr27);
	 
			Matte* matte_ptr28 = new Matte;
			matte_ptr28->set_ka(ka);	
			matte_ptr28->set_kd(kd);
			matte_ptr28->set_cd(dark_purple);
			Sphere*	sphere_ptr28 = new Sphere(Point3D(30, -62, -140), 15); 
			sphere_ptr28->set_material(matte_ptr28); 							// dark purple
			add_object(sphere_ptr28);
	
			Matte* matte_ptr29 = new Matte;
			matte_ptr29->set_ka(ka);	
			matte_ptr29->set_kd(kd);
			matte_ptr29->set_cd(dark_purple);
			Sphere*	sphere_ptr29 = new Sphere(Point3D(25, 63, -140), 15); 
			sphere_ptr29->set_material(matte_ptr29);							// dark purple
			add_object(sphere_ptr29);
	
			Matte* matte_ptr30 = new Matte;
			matte_ptr30->set_ka(ka);	
			matte_ptr30->set_kd(kd);
			matte_ptr30->set_cd(dark_purple);
			Sphere*	sphere_ptr30 = new Sphere(Point3D(-60, 46, -140), 15);  
			sphere_ptr30->set_material(matte_ptr30); 							// dark purple
			add_object(sphere_ptr30);
	
			Matte* matte_ptr31 = new Matte;
			matte_ptr31->set_ka(ka);	
			matte_ptr31->set_kd(kd);
			matte_ptr31->set_cd(light_purple);
			Sphere*	sphere_ptr31 = new Sphere(Point3D(-30, 68, -130), 12); 
			sphere_ptr31->set_material(matte_ptr31); 							// light purple
			add_object(sphere_ptr31);
	
			Matte* matte_ptr32 = new Matte;
			matte_ptr32->set_ka(ka);	
			matte_ptr32->set_kd(kd);
			matte_ptr32->set_cd(green);
			Sphere*	sphere_ptr32 = new Sphere(Point3D(58, 56, -180), 11);   
			sphere_ptr32->set_material(matte_ptr32);							//  green
			add_object(sphere_ptr32);
	
			Matte* matte_ptr33 = new Matte;
			matte_ptr33->set_ka(ka);	
			matte_ptr33->set_kd(kd);
			matte_ptr33->set_cd(green);
			Sphere*	sphere_ptr33 = new Sphere(Point3D(-63, -39, -180), 11); 
			sphere_ptr33->set_material(matte_ptr33);							// green 
			add_object(sphere_ptr33);
	
			Matte* matte_ptr34 = new Matte;
			matte_ptr34->set_ka(ka);	
			matte_ptr34->set_kd(kd);
			matte_ptr34->set_cd(light_purple);
			Sphere*	sphere_ptr34 = new Sphere(Point3D(46, 68, -200), 10); 	
			sphere_ptr34->set_material(matte_ptr34);							// light purple
			add_object(sphere_ptr34);
	
			Matte* matte_ptr35 = new Matte;
			matte_ptr35->set_ka(ka);	
			matte_ptr35->set_kd(kd);
			matte_ptr35->set_cd(light_purple);
			Sphere*	sphere_ptr35 = new Sphere(Point3D(-3, -72, -130), 12); 
			sphere_ptr35->set_material(matte_ptr35);							// light purple
			add_object(sphere_ptr35);
			break;
		}
	case 71:
		{
			//14.22b
			int num_samples = 16;

			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_pixel_size(0.5);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10000);
			pinhole_ptr->set_lookat(0.0);   
			pinhole_ptr->set_view_distance(15000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(100, 100, 200);
			light_ptr->set_color(1.0, 1.0, 1.0); 	
		//	light_ptr->scale_radiance(3.0);        	// for Figure 14.22 (a)
			light_ptr->scale_radiance(4.5); 	  	// for Figure 14.22 (b)		
			add_light(light_ptr);
	
	
			// colors

			RGBColour yellow(1, 1, 0);										// yellow
			RGBColour brown(0.71, 0.40, 0.16);								// brown
			RGBColour dark_green(0.0, 0.41, 0.41);							// dark_green
			RGBColour orange(1, 0.75, 0);									// orange
			RGBColour green(0, 0.6, 0.3);									// green
			RGBColour light_green(0.65, 1, 0.30);							// light green
			RGBColour dark_yellow(0.61, 0.61, 0);							// dark yellow
			RGBColour light_purple(0.65, 0.3, 1);							// light purple
			RGBColour dark_purple(0.5, 0, 1);								// dark purple
	
	
			// Matt material reflection coefficients
	
			float ka = 0.25;
			float kd = 0.75;
	
	
			// spheres
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(ka);	
			matte_ptr1->set_kd(kd);
			matte_ptr1->set_cd(yellow);				
			Sphere*	sphere_ptr1 = new Sphere(Point3D(5, 3, 0), 30); 
			sphere_ptr1->set_material(matte_ptr1);	   							// yellow
			add_object(sphere_ptr1);
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(ka);	
			matte_ptr2->set_kd(kd);
			matte_ptr2->set_cd(brown);
			Sphere*	sphere_ptr2 = new Sphere(Point3D(45, -7, -60), 20); 
			sphere_ptr2->set_material(matte_ptr2);								// brown
			add_object(sphere_ptr2);
	

			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(ka);	
			matte_ptr3->set_kd(kd);
			matte_ptr3->set_cd(dark_green);	
			Sphere*	sphere_ptr3 = new Sphere(Point3D(40, 43, -100), 17); 
			sphere_ptr3->set_material(matte_ptr3);								// dark green
			add_object(sphere_ptr3);
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(ka);	
			matte_ptr4->set_kd(kd);
			matte_ptr4->set_cd(orange);
			Sphere*	sphere_ptr4 = new Sphere(Point3D(-20, 28, -15), 20); 
			sphere_ptr4->set_material(matte_ptr4);								// orange
			add_object(sphere_ptr4);
	
			Matte* matte_ptr5 = new Matte;
			matte_ptr5->set_ka(ka);	
			matte_ptr5->set_kd(kd);
			matte_ptr5->set_cd(green);
			Sphere*	sphere_ptr5 = new Sphere(Point3D(-25, -7, -35), 27); 			
			sphere_ptr5->set_material(matte_ptr5);								// green
			add_object(sphere_ptr5);
	
			Matte* matte_ptr6 = new Matte;
			matte_ptr6->set_ka(ka);	
			matte_ptr6->set_kd(kd);
			matte_ptr6->set_cd(light_green);
			Sphere*	sphere_ptr6 = new Sphere(Point3D(20, -27, -35), 25); 
			sphere_ptr6->set_material(matte_ptr6);								// light green
			add_object(sphere_ptr6);
	
			Matte* matte_ptr7 = new Matte;
			matte_ptr7->set_ka(ka);	
			matte_ptr7->set_kd(kd);
			matte_ptr7->set_cd(green);
			Sphere*	sphere_ptr7 = new Sphere(Point3D(35, 18, -35), 22); 
			sphere_ptr7->set_material(matte_ptr7);   							// green
			add_object(sphere_ptr7);
	
			Matte* matte_ptr8 = new Matte;
			matte_ptr8->set_ka(ka);	
			matte_ptr8->set_kd(kd);
			matte_ptr8->set_cd(brown);
			Sphere*	sphere_ptr8 = new Sphere(Point3D(-57, -17, -50), 15);  
			sphere_ptr8->set_material(matte_ptr8);								// brown
			add_object(sphere_ptr8);
	
			Matte* matte_ptr9 = new Matte;
			matte_ptr9->set_ka(ka);	
			matte_ptr9->set_kd(kd);
			matte_ptr9->set_cd(light_green);
			Sphere*	sphere_ptr9 = new Sphere(Point3D(-47, 16, -80), 23); 
			sphere_ptr9->set_material(matte_ptr9);								// light green
			add_object(sphere_ptr9);
		
			Matte* matte_ptr10 = new Matte;
			matte_ptr10->set_ka(ka);	
			matte_ptr10->set_kd(kd);
			matte_ptr10->set_cd(dark_green);	
			Sphere*	sphere_ptr10 = new Sphere(Point3D(-15, -32, -60), 22); 
			sphere_ptr10->set_material(matte_ptr10);     						// dark green
			add_object(sphere_ptr10);
	
			Matte* matte_ptr11 = new Matte;
			matte_ptr11->set_ka(ka);	
			matte_ptr11->set_kd(kd);
			matte_ptr11->set_cd(dark_yellow);
			Sphere*	sphere_ptr11 = new Sphere(Point3D(-35, -37, -80), 22); 
			sphere_ptr11->set_material(matte_ptr11);							// dark yellow
			add_object(sphere_ptr11);
	
			Matte* matte_ptr12 = new Matte;
			matte_ptr12->set_ka(ka);	
			matte_ptr12->set_kd(kd);
			matte_ptr12->set_cd(dark_yellow);
			Sphere*	sphere_ptr12 = new Sphere(Point3D(10, 43, -80), 22); 
			sphere_ptr12->set_material(matte_ptr12);							// dark yellow
			add_object(sphere_ptr12);
	
			Matte* matte_ptr13 = new Matte;
			matte_ptr13->set_ka(ka);	
			matte_ptr13->set_kd(kd);
			matte_ptr13->set_cd(dark_yellow);		
			Sphere*	sphere_ptr13 = new Sphere(Point3D(30, -7, -80), 10); 
			sphere_ptr13->set_material(matte_ptr13);
			add_object(sphere_ptr13);											// dark yellow (hidden)
	
			Matte* matte_ptr14 = new Matte;
			matte_ptr14->set_ka(ka);	
			matte_ptr14->set_kd(kd);
			matte_ptr14->set_cd(dark_green);	
			Sphere*	sphere_ptr14 = new Sphere(Point3D(-40, 48, -110), 18); 
			sphere_ptr14->set_material(matte_ptr14); 							// dark green
			add_object(sphere_ptr14);
	
			Matte* matte_ptr15 = new Matte;
			matte_ptr15->set_ka(ka);	
			matte_ptr15->set_kd(kd);
			matte_ptr15->set_cd(brown);	
			Sphere*	sphere_ptr15 = new Sphere(Point3D(-10, 53, -120), 18); 
			sphere_ptr15->set_material(matte_ptr15); 							// brown
			add_object(sphere_ptr15);
	
			Matte* matte_ptr16 = new Matte;
			matte_ptr16->set_ka(ka);	
			matte_ptr16->set_kd(kd);
			matte_ptr16->set_cd(light_purple);
			Sphere*	sphere_ptr16 = new Sphere(Point3D(-55, -52, -100), 10); 
			sphere_ptr16->set_material(matte_ptr16);							// light purple
			add_object(sphere_ptr16);
	
			Matte* matte_ptr17 = new Matte;
			matte_ptr17->set_ka(ka);	
			matte_ptr17->set_kd(kd);
			matte_ptr17->set_cd(brown);
			Sphere*	sphere_ptr17 = new Sphere(Point3D(5, -52, -100), 15); 		
			sphere_ptr17->set_material(matte_ptr17);							// browm
			add_object(sphere_ptr17);
	
			Matte* matte_ptr18 = new Matte;
			matte_ptr18->set_ka(ka);	
			matte_ptr18->set_kd(kd);
			matte_ptr18->set_cd(dark_purple);
			Sphere*	sphere_ptr18 = new Sphere(Point3D(-20, -57, -120), 15); 
			sphere_ptr18->set_material(matte_ptr18);							// dark purple
			add_object(sphere_ptr18);
	
			Matte* matte_ptr19 = new Matte;
			matte_ptr19->set_ka(ka);	
			matte_ptr19->set_kd(kd);
			matte_ptr19->set_cd(dark_green);
			Sphere*	sphere_ptr19 = new Sphere(Point3D(55, -27, -100), 17); 
			sphere_ptr19->set_material(matte_ptr19);							// dark green
			add_object(sphere_ptr19);

			Matte* matte_ptr20 = new Matte;
			matte_ptr20->set_ka(ka);	
			matte_ptr20->set_kd(kd);
			matte_ptr20->set_cd(brown);
			Sphere*	sphere_ptr20 = new Sphere(Point3D(50, -47, -120), 15); 
			sphere_ptr20->set_material(matte_ptr20);							// browm
			add_object(sphere_ptr20);
	 
			Matte* matte_ptr21 = new Matte;
			matte_ptr21->set_ka(ka);	
			matte_ptr21->set_kd(kd);
			matte_ptr21->set_cd(light_purple); 	
			Sphere*	sphere_ptr21 = new Sphere(Point3D(70, -42, -150), 10); 
			sphere_ptr21->set_material(matte_ptr21);							// light purple
			add_object(sphere_ptr21);
	
			Matte* matte_ptr22 = new Matte;
			matte_ptr22->set_ka(ka);	
			matte_ptr22->set_kd(kd);
			matte_ptr22->set_cd(light_purple);
			Sphere*	sphere_ptr22 = new Sphere(Point3D(5, 73, -130), 12); 
			sphere_ptr22->set_material(matte_ptr22);							// light purple
			add_object(sphere_ptr22);
	
			Matte* matte_ptr23 = new Matte;
			matte_ptr23->set_ka(ka);	
			matte_ptr23->set_kd(kd);
			matte_ptr23->set_cd(dark_purple);
			Sphere*	sphere_ptr23 = new Sphere(Point3D(66, 21, -130), 13); 			
			sphere_ptr23->set_material(matte_ptr23);							// dark purple
			add_object(sphere_ptr23);	
	
			Matte* matte_ptr24 = new Matte;
			matte_ptr24->set_ka(ka);	
			matte_ptr24->set_kd(kd);
			matte_ptr24->set_cd(light_purple);  
			Sphere*	sphere_ptr24 = new Sphere(Point3D(72, -12, -140), 12); 
			sphere_ptr24->set_material(matte_ptr24);							// light purple
			add_object(sphere_ptr24);
	
			Matte* matte_ptr25 = new Matte;
			matte_ptr25->set_ka(ka);	
			matte_ptr25->set_kd(kd);
			matte_ptr25->set_cd(green);
			Sphere*	sphere_ptr25 = new Sphere(Point3D(64, 5, -160), 11); 			
			sphere_ptr25->set_material(matte_ptr25);					 		// green
			add_object(sphere_ptr25);
	  
			Matte* matte_ptr26 = new Matte;
			matte_ptr26->set_ka(ka);	
			matte_ptr26->set_kd(kd);
			matte_ptr26->set_cd(light_purple);
			Sphere*	sphere_ptr26 = new Sphere(Point3D(55, 38, -160), 12); 		
			sphere_ptr26->set_material(matte_ptr26);							// light purple
			add_object(sphere_ptr26);
	
			Matte* matte_ptr27 = new Matte;
			matte_ptr27->set_ka(ka);	
			matte_ptr27->set_kd(kd);
			matte_ptr27->set_cd(light_purple);
			Sphere*	sphere_ptr27 = new Sphere(Point3D(-73, -2, -160), 12); 		
			sphere_ptr27->set_material(matte_ptr27);							// light purple
			add_object(sphere_ptr27);
	 
			Matte* matte_ptr28 = new Matte;
			matte_ptr28->set_ka(ka);	
			matte_ptr28->set_kd(kd);
			matte_ptr28->set_cd(dark_purple);
			Sphere*	sphere_ptr28 = new Sphere(Point3D(30, -62, -140), 15); 
			sphere_ptr28->set_material(matte_ptr28); 							// dark purple
			add_object(sphere_ptr28);
	
			Matte* matte_ptr29 = new Matte;
			matte_ptr29->set_ka(ka);	
			matte_ptr29->set_kd(kd);
			matte_ptr29->set_cd(dark_purple);
			Sphere*	sphere_ptr29 = new Sphere(Point3D(25, 63, -140), 15); 
			sphere_ptr29->set_material(matte_ptr29);							// dark purple
			add_object(sphere_ptr29);
	
			Matte* matte_ptr30 = new Matte;
			matte_ptr30->set_ka(ka);	
			matte_ptr30->set_kd(kd);
			matte_ptr30->set_cd(dark_purple);
			Sphere*	sphere_ptr30 = new Sphere(Point3D(-60, 46, -140), 15);  
			sphere_ptr30->set_material(matte_ptr30); 							// dark purple
			add_object(sphere_ptr30);
	
			Matte* matte_ptr31 = new Matte;
			matte_ptr31->set_ka(ka);	
			matte_ptr31->set_kd(kd);
			matte_ptr31->set_cd(light_purple);
			Sphere*	sphere_ptr31 = new Sphere(Point3D(-30, 68, -130), 12); 
			sphere_ptr31->set_material(matte_ptr31); 							// light purple
			add_object(sphere_ptr31);
	
			Matte* matte_ptr32 = new Matte;
			matte_ptr32->set_ka(ka);	
			matte_ptr32->set_kd(kd);
			matte_ptr32->set_cd(green);
			Sphere*	sphere_ptr32 = new Sphere(Point3D(58, 56, -180), 11);   
			sphere_ptr32->set_material(matte_ptr32);							//  green
			add_object(sphere_ptr32);
	
			Matte* matte_ptr33 = new Matte;
			matte_ptr33->set_ka(ka);	
			matte_ptr33->set_kd(kd);
			matte_ptr33->set_cd(green);
			Sphere*	sphere_ptr33 = new Sphere(Point3D(-63, -39, -180), 11); 
			sphere_ptr33->set_material(matte_ptr33);							// green 
			add_object(sphere_ptr33);
	
			Matte* matte_ptr34 = new Matte;
			matte_ptr34->set_ka(ka);	
			matte_ptr34->set_kd(kd);
			matte_ptr34->set_cd(light_purple);
			Sphere*	sphere_ptr34 = new Sphere(Point3D(46, 68, -200), 10); 	
			sphere_ptr34->set_material(matte_ptr34);							// light purple
			add_object(sphere_ptr34);
	
			Matte* matte_ptr35 = new Matte;
			matte_ptr35->set_ka(ka);	
			matte_ptr35->set_kd(kd);
			matte_ptr35->set_cd(light_purple);
			Sphere*	sphere_ptr35 = new Sphere(Point3D(-3, -72, -130), 12); 
			sphere_ptr35->set_material(matte_ptr35);							// light purple
			add_object(sphere_ptr35);
			break;
		}
	case 72:
		{
			//14.23a
			int num_samples = 16;

			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_pixel_size(0.5);
			vp.set_samples(num_samples);  
		//	vp.set_gamut_display(true);        // for Figure 14.23(b)
	
			tracer_ptr = new RayCast(this);	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10000);
			pinhole_ptr->set_lookat(0.0);   
			pinhole_ptr->set_view_distance(15000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(100, 100, 200);
			light_ptr->set_color(1.0, 1.0, 1.0); 	
			light_ptr->scale_radiance(4.5); 	  		
			add_light(light_ptr);
	
	
			// colors

			RGBColour yellow(1, 1, 0);										// yellow
			RGBColour brown(0.71, 0.40, 0.16);								// brown
			RGBColour dark_green(0.0, 0.41, 0.41);							// dark_green
			RGBColour orange(1, 0.75, 0);									// orange
			RGBColour green(0, 0.6, 0.3);									// green
			RGBColour light_green(0.65, 1, 0.30);							// light green
			RGBColour dark_yellow(0.61, 0.61, 0);							// dark yellow
			RGBColour light_purple(0.65, 0.3, 1);							// light purple
			RGBColour dark_purple(0.5, 0, 1);								// dark purple
	
	
			// Matt material reflection coefficients
	
			float ka = 0.25;
			float kd = 0.75;
	
	
			// spheres
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(ka);	
			matte_ptr1->set_kd(kd);
			matte_ptr1->set_cd(yellow);				
			Sphere*	sphere_ptr1 = new Sphere(Point3D(5, 3, 0), 30); 
			sphere_ptr1->set_material(matte_ptr1);	   							// yellow
			add_object(sphere_ptr1);
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(ka);	
			matte_ptr2->set_kd(kd);
			matte_ptr2->set_cd(brown);
			Sphere*	sphere_ptr2 = new Sphere(Point3D(45, -7, -60), 20); 
			sphere_ptr2->set_material(matte_ptr2);								// brown
			add_object(sphere_ptr2);
	

			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(ka);	
			matte_ptr3->set_kd(kd);
			matte_ptr3->set_cd(dark_green);	
			Sphere*	sphere_ptr3 = new Sphere(Point3D(40, 43, -100), 17); 
			sphere_ptr3->set_material(matte_ptr3);								// dark green
			add_object(sphere_ptr3);
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(ka);	
			matte_ptr4->set_kd(kd);
			matte_ptr4->set_cd(orange);
			Sphere*	sphere_ptr4 = new Sphere(Point3D(-20, 28, -15), 20); 
			sphere_ptr4->set_material(matte_ptr4);								// orange
			add_object(sphere_ptr4);
	
			Matte* matte_ptr5 = new Matte;
			matte_ptr5->set_ka(ka);	
			matte_ptr5->set_kd(kd);
			matte_ptr5->set_cd(green);
			Sphere*	sphere_ptr5 = new Sphere(Point3D(-25, -7, -35), 27); 			
			sphere_ptr5->set_material(matte_ptr5);								// green
			add_object(sphere_ptr5);
	
			Matte* matte_ptr6 = new Matte;
			matte_ptr6->set_ka(ka);	
			matte_ptr6->set_kd(kd);
			matte_ptr6->set_cd(light_green);
			Sphere*	sphere_ptr6 = new Sphere(Point3D(20, -27, -35), 25); 
			sphere_ptr6->set_material(matte_ptr6);								// light green
			add_object(sphere_ptr6);
	
			Matte* matte_ptr7 = new Matte;
			matte_ptr7->set_ka(ka);	
			matte_ptr7->set_kd(kd);
			matte_ptr7->set_cd(green);
			Sphere*	sphere_ptr7 = new Sphere(Point3D(35, 18, -35), 22); 
			sphere_ptr7->set_material(matte_ptr7);   							// green
			add_object(sphere_ptr7);
	
			Matte* matte_ptr8 = new Matte;
			matte_ptr8->set_ka(ka);	
			matte_ptr8->set_kd(kd);
			matte_ptr8->set_cd(brown);
			Sphere*	sphere_ptr8 = new Sphere(Point3D(-57, -17, -50), 15);  
			sphere_ptr8->set_material(matte_ptr8);								// brown
			add_object(sphere_ptr8);
	
			Matte* matte_ptr9 = new Matte;
			matte_ptr9->set_ka(ka);	
			matte_ptr9->set_kd(kd);
			matte_ptr9->set_cd(light_green);
			Sphere*	sphere_ptr9 = new Sphere(Point3D(-47, 16, -80), 23); 
			sphere_ptr9->set_material(matte_ptr9);								// light green
			add_object(sphere_ptr9);
		
			Matte* matte_ptr10 = new Matte;
			matte_ptr10->set_ka(ka);	
			matte_ptr10->set_kd(kd);
			matte_ptr10->set_cd(dark_green);	
			Sphere*	sphere_ptr10 = new Sphere(Point3D(-15, -32, -60), 22); 
			sphere_ptr10->set_material(matte_ptr10);     						// dark green
			add_object(sphere_ptr10);
	
			Matte* matte_ptr11 = new Matte;
			matte_ptr11->set_ka(ka);	
			matte_ptr11->set_kd(kd);
			matte_ptr11->set_cd(dark_yellow);
			Sphere*	sphere_ptr11 = new Sphere(Point3D(-35, -37, -80), 22); 
			sphere_ptr11->set_material(matte_ptr11);							// dark yellow
			add_object(sphere_ptr11);
	
			Matte* matte_ptr12 = new Matte;
			matte_ptr12->set_ka(ka);	
			matte_ptr12->set_kd(kd);
			matte_ptr12->set_cd(dark_yellow);
			Sphere*	sphere_ptr12 = new Sphere(Point3D(10, 43, -80), 22); 
			sphere_ptr12->set_material(matte_ptr12);							// dark yellow
			add_object(sphere_ptr12);
	
			Matte* matte_ptr13 = new Matte;
			matte_ptr13->set_ka(ka);	
			matte_ptr13->set_kd(kd);
			matte_ptr13->set_cd(dark_yellow);		
			Sphere*	sphere_ptr13 = new Sphere(Point3D(30, -7, -80), 10); 
			sphere_ptr13->set_material(matte_ptr13);
			add_object(sphere_ptr13);											// dark yellow (hidden)
	
			Matte* matte_ptr14 = new Matte;
			matte_ptr14->set_ka(ka);	
			matte_ptr14->set_kd(kd);
			matte_ptr14->set_cd(dark_green);	
			Sphere*	sphere_ptr14 = new Sphere(Point3D(-40, 48, -110), 18); 
			sphere_ptr14->set_material(matte_ptr14); 							// dark green
			add_object(sphere_ptr14);
	
			Matte* matte_ptr15 = new Matte;
			matte_ptr15->set_ka(ka);	
			matte_ptr15->set_kd(kd);
			matte_ptr15->set_cd(brown);	
			Sphere*	sphere_ptr15 = new Sphere(Point3D(-10, 53, -120), 18); 
			sphere_ptr15->set_material(matte_ptr15); 							// brown
			add_object(sphere_ptr15);
	
			Matte* matte_ptr16 = new Matte;
			matte_ptr16->set_ka(ka);	
			matte_ptr16->set_kd(kd);
			matte_ptr16->set_cd(light_purple);
			Sphere*	sphere_ptr16 = new Sphere(Point3D(-55, -52, -100), 10); 
			sphere_ptr16->set_material(matte_ptr16);							// light purple
			add_object(sphere_ptr16);
	
			Matte* matte_ptr17 = new Matte;
			matte_ptr17->set_ka(ka);	
			matte_ptr17->set_kd(kd);
			matte_ptr17->set_cd(brown);
			Sphere*	sphere_ptr17 = new Sphere(Point3D(5, -52, -100), 15); 		
			sphere_ptr17->set_material(matte_ptr17);							// browm
			add_object(sphere_ptr17);
	
			Matte* matte_ptr18 = new Matte;
			matte_ptr18->set_ka(ka);	
			matte_ptr18->set_kd(kd);
			matte_ptr18->set_cd(dark_purple);
			Sphere*	sphere_ptr18 = new Sphere(Point3D(-20, -57, -120), 15); 
			sphere_ptr18->set_material(matte_ptr18);							// dark purple
			add_object(sphere_ptr18);
	
			Matte* matte_ptr19 = new Matte;
			matte_ptr19->set_ka(ka);	
			matte_ptr19->set_kd(kd);
			matte_ptr19->set_cd(dark_green);
			Sphere*	sphere_ptr19 = new Sphere(Point3D(55, -27, -100), 17); 
			sphere_ptr19->set_material(matte_ptr19);							// dark green
			add_object(sphere_ptr19);

			Matte* matte_ptr20 = new Matte;
			matte_ptr20->set_ka(ka);	
			matte_ptr20->set_kd(kd);
			matte_ptr20->set_cd(brown);
			Sphere*	sphere_ptr20 = new Sphere(Point3D(50, -47, -120), 15); 
			sphere_ptr20->set_material(matte_ptr20);							// browm
			add_object(sphere_ptr20);
	 
			Matte* matte_ptr21 = new Matte;
			matte_ptr21->set_ka(ka);	
			matte_ptr21->set_kd(kd);
			matte_ptr21->set_cd(light_purple); 	
			Sphere*	sphere_ptr21 = new Sphere(Point3D(70, -42, -150), 10); 
			sphere_ptr21->set_material(matte_ptr21);							// light purple
			add_object(sphere_ptr21);
	
			Matte* matte_ptr22 = new Matte;
			matte_ptr22->set_ka(ka);	
			matte_ptr22->set_kd(kd);
			matte_ptr22->set_cd(light_purple);
			Sphere*	sphere_ptr22 = new Sphere(Point3D(5, 73, -130), 12); 
			sphere_ptr22->set_material(matte_ptr22);							// light purple
			add_object(sphere_ptr22);
	
			Matte* matte_ptr23 = new Matte;
			matte_ptr23->set_ka(ka);	
			matte_ptr23->set_kd(kd);
			matte_ptr23->set_cd(dark_purple);
			Sphere*	sphere_ptr23 = new Sphere(Point3D(66, 21, -130), 13); 			
			sphere_ptr23->set_material(matte_ptr23);							// dark purple
			add_object(sphere_ptr23);	
	
			Matte* matte_ptr24 = new Matte;
			matte_ptr24->set_ka(ka);	
			matte_ptr24->set_kd(kd);
			matte_ptr24->set_cd(light_purple);  
			Sphere*	sphere_ptr24 = new Sphere(Point3D(72, -12, -140), 12); 
			sphere_ptr24->set_material(matte_ptr24);							// light purple
			add_object(sphere_ptr24);
	
			Matte* matte_ptr25 = new Matte;
			matte_ptr25->set_ka(ka);	
			matte_ptr25->set_kd(kd);
			matte_ptr25->set_cd(green);
			Sphere*	sphere_ptr25 = new Sphere(Point3D(64, 5, -160), 11); 			
			sphere_ptr25->set_material(matte_ptr25);					 		// green
			add_object(sphere_ptr25);
	  
			Matte* matte_ptr26 = new Matte;
			matte_ptr26->set_ka(ka);	
			matte_ptr26->set_kd(kd);
			matte_ptr26->set_cd(light_purple);
			Sphere*	sphere_ptr26 = new Sphere(Point3D(55, 38, -160), 12); 		
			sphere_ptr26->set_material(matte_ptr26);							// light purple
			add_object(sphere_ptr26);
	
			Matte* matte_ptr27 = new Matte;
			matte_ptr27->set_ka(ka);	
			matte_ptr27->set_kd(kd);
			matte_ptr27->set_cd(light_purple);
			Sphere*	sphere_ptr27 = new Sphere(Point3D(-73, -2, -160), 12); 		
			sphere_ptr27->set_material(matte_ptr27);							// light purple
			add_object(sphere_ptr27);
	 
			Matte* matte_ptr28 = new Matte;
			matte_ptr28->set_ka(ka);	
			matte_ptr28->set_kd(kd);
			matte_ptr28->set_cd(dark_purple);
			Sphere*	sphere_ptr28 = new Sphere(Point3D(30, -62, -140), 15); 
			sphere_ptr28->set_material(matte_ptr28); 							// dark purple
			add_object(sphere_ptr28);
	
			Matte* matte_ptr29 = new Matte;
			matte_ptr29->set_ka(ka);	
			matte_ptr29->set_kd(kd);
			matte_ptr29->set_cd(dark_purple);
			Sphere*	sphere_ptr29 = new Sphere(Point3D(25, 63, -140), 15); 
			sphere_ptr29->set_material(matte_ptr29);							// dark purple
			add_object(sphere_ptr29);
	
			Matte* matte_ptr30 = new Matte;
			matte_ptr30->set_ka(ka);	
			matte_ptr30->set_kd(kd);
			matte_ptr30->set_cd(dark_purple);
			Sphere*	sphere_ptr30 = new Sphere(Point3D(-60, 46, -140), 15);  
			sphere_ptr30->set_material(matte_ptr30); 							// dark purple
			add_object(sphere_ptr30);
	
			Matte* matte_ptr31 = new Matte;
			matte_ptr31->set_ka(ka);	
			matte_ptr31->set_kd(kd);
			matte_ptr31->set_cd(light_purple);
			Sphere*	sphere_ptr31 = new Sphere(Point3D(-30, 68, -130), 12); 
			sphere_ptr31->set_material(matte_ptr31); 							// light purple
			add_object(sphere_ptr31);
	
			Matte* matte_ptr32 = new Matte;
			matte_ptr32->set_ka(ka);	
			matte_ptr32->set_kd(kd);
			matte_ptr32->set_cd(green);
			Sphere*	sphere_ptr32 = new Sphere(Point3D(58, 56, -180), 11);   
			sphere_ptr32->set_material(matte_ptr32);							//  green
			add_object(sphere_ptr32);
	
			Matte* matte_ptr33 = new Matte;
			matte_ptr33->set_ka(ka);	
			matte_ptr33->set_kd(kd);
			matte_ptr33->set_cd(green);
			Sphere*	sphere_ptr33 = new Sphere(Point3D(-63, -39, -180), 11); 
			sphere_ptr33->set_material(matte_ptr33);							// green 
			add_object(sphere_ptr33);
	
			Matte* matte_ptr34 = new Matte;
			matte_ptr34->set_ka(ka);	
			matte_ptr34->set_kd(kd);
			matte_ptr34->set_cd(light_purple);
			Sphere*	sphere_ptr34 = new Sphere(Point3D(46, 68, -200), 10); 	
			sphere_ptr34->set_material(matte_ptr34);							// light purple
			add_object(sphere_ptr34);
	
			Matte* matte_ptr35 = new Matte;
			matte_ptr35->set_ka(ka);	
			matte_ptr35->set_kd(kd);
			matte_ptr35->set_cd(light_purple);
			Sphere*	sphere_ptr35 = new Sphere(Point3D(-3, -72, -130), 12); 
			sphere_ptr35->set_material(matte_ptr35);							// light purple
			add_object(sphere_ptr35);
			break;
		}
	case 73:
		{
			//14.23b
			int num_samples = 16;

			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_pixel_size(0.5);
			vp.set_samples(num_samples);  
			vp.set_gamut_display(true);        // for Figure 14.23(b)
	
			tracer_ptr = new RayCast(this);	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10000);
			pinhole_ptr->set_lookat(0.0);   
			pinhole_ptr->set_view_distance(15000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(100, 100, 200);
			light_ptr->set_color(1.0, 1.0, 1.0); 	
			light_ptr->scale_radiance(4.5); 	  		
			add_light(light_ptr);
	
	
			// colors

			RGBColour yellow(1, 1, 0);										// yellow
			RGBColour brown(0.71, 0.40, 0.16);								// brown
			RGBColour dark_green(0.0, 0.41, 0.41);							// dark_green
			RGBColour orange(1, 0.75, 0);									// orange
			RGBColour green(0, 0.6, 0.3);									// green
			RGBColour light_green(0.65, 1, 0.30);							// light green
			RGBColour dark_yellow(0.61, 0.61, 0);							// dark yellow
			RGBColour light_purple(0.65, 0.3, 1);							// light purple
			RGBColour dark_purple(0.5, 0, 1);								// dark purple
	
	
			// Matt material reflection coefficients
	
			float ka = 0.25;
			float kd = 0.75;
	
	
			// spheres
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(ka);	
			matte_ptr1->set_kd(kd);
			matte_ptr1->set_cd(yellow);				
			Sphere*	sphere_ptr1 = new Sphere(Point3D(5, 3, 0), 30); 
			sphere_ptr1->set_material(matte_ptr1);	   							// yellow
			add_object(sphere_ptr1);
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(ka);	
			matte_ptr2->set_kd(kd);
			matte_ptr2->set_cd(brown);
			Sphere*	sphere_ptr2 = new Sphere(Point3D(45, -7, -60), 20); 
			sphere_ptr2->set_material(matte_ptr2);								// brown
			add_object(sphere_ptr2);
	

			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(ka);	
			matte_ptr3->set_kd(kd);
			matte_ptr3->set_cd(dark_green);	
			Sphere*	sphere_ptr3 = new Sphere(Point3D(40, 43, -100), 17); 
			sphere_ptr3->set_material(matte_ptr3);								// dark green
			add_object(sphere_ptr3);
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(ka);	
			matte_ptr4->set_kd(kd);
			matte_ptr4->set_cd(orange);
			Sphere*	sphere_ptr4 = new Sphere(Point3D(-20, 28, -15), 20); 
			sphere_ptr4->set_material(matte_ptr4);								// orange
			add_object(sphere_ptr4);
	
			Matte* matte_ptr5 = new Matte;
			matte_ptr5->set_ka(ka);	
			matte_ptr5->set_kd(kd);
			matte_ptr5->set_cd(green);
			Sphere*	sphere_ptr5 = new Sphere(Point3D(-25, -7, -35), 27); 			
			sphere_ptr5->set_material(matte_ptr5);								// green
			add_object(sphere_ptr5);
	
			Matte* matte_ptr6 = new Matte;
			matte_ptr6->set_ka(ka);	
			matte_ptr6->set_kd(kd);
			matte_ptr6->set_cd(light_green);
			Sphere*	sphere_ptr6 = new Sphere(Point3D(20, -27, -35), 25); 
			sphere_ptr6->set_material(matte_ptr6);								// light green
			add_object(sphere_ptr6);
	
			Matte* matte_ptr7 = new Matte;
			matte_ptr7->set_ka(ka);	
			matte_ptr7->set_kd(kd);
			matte_ptr7->set_cd(green);
			Sphere*	sphere_ptr7 = new Sphere(Point3D(35, 18, -35), 22); 
			sphere_ptr7->set_material(matte_ptr7);   							// green
			add_object(sphere_ptr7);
	
			Matte* matte_ptr8 = new Matte;
			matte_ptr8->set_ka(ka);	
			matte_ptr8->set_kd(kd);
			matte_ptr8->set_cd(brown);
			Sphere*	sphere_ptr8 = new Sphere(Point3D(-57, -17, -50), 15);  
			sphere_ptr8->set_material(matte_ptr8);								// brown
			add_object(sphere_ptr8);
	
			Matte* matte_ptr9 = new Matte;
			matte_ptr9->set_ka(ka);	
			matte_ptr9->set_kd(kd);
			matte_ptr9->set_cd(light_green);
			Sphere*	sphere_ptr9 = new Sphere(Point3D(-47, 16, -80), 23); 
			sphere_ptr9->set_material(matte_ptr9);								// light green
			add_object(sphere_ptr9);
		
			Matte* matte_ptr10 = new Matte;
			matte_ptr10->set_ka(ka);	
			matte_ptr10->set_kd(kd);
			matte_ptr10->set_cd(dark_green);	
			Sphere*	sphere_ptr10 = new Sphere(Point3D(-15, -32, -60), 22); 
			sphere_ptr10->set_material(matte_ptr10);     						// dark green
			add_object(sphere_ptr10);
	
			Matte* matte_ptr11 = new Matte;
			matte_ptr11->set_ka(ka);	
			matte_ptr11->set_kd(kd);
			matte_ptr11->set_cd(dark_yellow);
			Sphere*	sphere_ptr11 = new Sphere(Point3D(-35, -37, -80), 22); 
			sphere_ptr11->set_material(matte_ptr11);							// dark yellow
			add_object(sphere_ptr11);
	
			Matte* matte_ptr12 = new Matte;
			matte_ptr12->set_ka(ka);	
			matte_ptr12->set_kd(kd);
			matte_ptr12->set_cd(dark_yellow);
			Sphere*	sphere_ptr12 = new Sphere(Point3D(10, 43, -80), 22); 
			sphere_ptr12->set_material(matte_ptr12);							// dark yellow
			add_object(sphere_ptr12);
	
			Matte* matte_ptr13 = new Matte;
			matte_ptr13->set_ka(ka);	
			matte_ptr13->set_kd(kd);
			matte_ptr13->set_cd(dark_yellow);		
			Sphere*	sphere_ptr13 = new Sphere(Point3D(30, -7, -80), 10); 
			sphere_ptr13->set_material(matte_ptr13);
			add_object(sphere_ptr13);											// dark yellow (hidden)
	
			Matte* matte_ptr14 = new Matte;
			matte_ptr14->set_ka(ka);	
			matte_ptr14->set_kd(kd);
			matte_ptr14->set_cd(dark_green);	
			Sphere*	sphere_ptr14 = new Sphere(Point3D(-40, 48, -110), 18); 
			sphere_ptr14->set_material(matte_ptr14); 							// dark green
			add_object(sphere_ptr14);
	
			Matte* matte_ptr15 = new Matte;
			matte_ptr15->set_ka(ka);	
			matte_ptr15->set_kd(kd);
			matte_ptr15->set_cd(brown);	
			Sphere*	sphere_ptr15 = new Sphere(Point3D(-10, 53, -120), 18); 
			sphere_ptr15->set_material(matte_ptr15); 							// brown
			add_object(sphere_ptr15);
	
			Matte* matte_ptr16 = new Matte;
			matte_ptr16->set_ka(ka);	
			matte_ptr16->set_kd(kd);
			matte_ptr16->set_cd(light_purple);
			Sphere*	sphere_ptr16 = new Sphere(Point3D(-55, -52, -100), 10); 
			sphere_ptr16->set_material(matte_ptr16);							// light purple
			add_object(sphere_ptr16);
	
			Matte* matte_ptr17 = new Matte;
			matte_ptr17->set_ka(ka);	
			matte_ptr17->set_kd(kd);
			matte_ptr17->set_cd(brown);
			Sphere*	sphere_ptr17 = new Sphere(Point3D(5, -52, -100), 15); 		
			sphere_ptr17->set_material(matte_ptr17);							// browm
			add_object(sphere_ptr17);
	
			Matte* matte_ptr18 = new Matte;
			matte_ptr18->set_ka(ka);	
			matte_ptr18->set_kd(kd);
			matte_ptr18->set_cd(dark_purple);
			Sphere*	sphere_ptr18 = new Sphere(Point3D(-20, -57, -120), 15); 
			sphere_ptr18->set_material(matte_ptr18);							// dark purple
			add_object(sphere_ptr18);
	
			Matte* matte_ptr19 = new Matte;
			matte_ptr19->set_ka(ka);	
			matte_ptr19->set_kd(kd);
			matte_ptr19->set_cd(dark_green);
			Sphere*	sphere_ptr19 = new Sphere(Point3D(55, -27, -100), 17); 
			sphere_ptr19->set_material(matte_ptr19);							// dark green
			add_object(sphere_ptr19);

			Matte* matte_ptr20 = new Matte;
			matte_ptr20->set_ka(ka);	
			matte_ptr20->set_kd(kd);
			matte_ptr20->set_cd(brown);
			Sphere*	sphere_ptr20 = new Sphere(Point3D(50, -47, -120), 15); 
			sphere_ptr20->set_material(matte_ptr20);							// browm
			add_object(sphere_ptr20);
	 
			Matte* matte_ptr21 = new Matte;
			matte_ptr21->set_ka(ka);	
			matte_ptr21->set_kd(kd);
			matte_ptr21->set_cd(light_purple); 	
			Sphere*	sphere_ptr21 = new Sphere(Point3D(70, -42, -150), 10); 
			sphere_ptr21->set_material(matte_ptr21);							// light purple
			add_object(sphere_ptr21);
	
			Matte* matte_ptr22 = new Matte;
			matte_ptr22->set_ka(ka);	
			matte_ptr22->set_kd(kd);
			matte_ptr22->set_cd(light_purple);
			Sphere*	sphere_ptr22 = new Sphere(Point3D(5, 73, -130), 12); 
			sphere_ptr22->set_material(matte_ptr22);							// light purple
			add_object(sphere_ptr22);
	
			Matte* matte_ptr23 = new Matte;
			matte_ptr23->set_ka(ka);	
			matte_ptr23->set_kd(kd);
			matte_ptr23->set_cd(dark_purple);
			Sphere*	sphere_ptr23 = new Sphere(Point3D(66, 21, -130), 13); 			
			sphere_ptr23->set_material(matte_ptr23);							// dark purple
			add_object(sphere_ptr23);	
	
			Matte* matte_ptr24 = new Matte;
			matte_ptr24->set_ka(ka);	
			matte_ptr24->set_kd(kd);
			matte_ptr24->set_cd(light_purple);  
			Sphere*	sphere_ptr24 = new Sphere(Point3D(72, -12, -140), 12); 
			sphere_ptr24->set_material(matte_ptr24);							// light purple
			add_object(sphere_ptr24);
	
			Matte* matte_ptr25 = new Matte;
			matte_ptr25->set_ka(ka);	
			matte_ptr25->set_kd(kd);
			matte_ptr25->set_cd(green);
			Sphere*	sphere_ptr25 = new Sphere(Point3D(64, 5, -160), 11); 			
			sphere_ptr25->set_material(matte_ptr25);					 		// green
			add_object(sphere_ptr25);
	  
			Matte* matte_ptr26 = new Matte;
			matte_ptr26->set_ka(ka);	
			matte_ptr26->set_kd(kd);
			matte_ptr26->set_cd(light_purple);
			Sphere*	sphere_ptr26 = new Sphere(Point3D(55, 38, -160), 12); 		
			sphere_ptr26->set_material(matte_ptr26);							// light purple
			add_object(sphere_ptr26);
	
			Matte* matte_ptr27 = new Matte;
			matte_ptr27->set_ka(ka);	
			matte_ptr27->set_kd(kd);
			matte_ptr27->set_cd(light_purple);
			Sphere*	sphere_ptr27 = new Sphere(Point3D(-73, -2, -160), 12); 		
			sphere_ptr27->set_material(matte_ptr27);							// light purple
			add_object(sphere_ptr27);
	 
			Matte* matte_ptr28 = new Matte;
			matte_ptr28->set_ka(ka);	
			matte_ptr28->set_kd(kd);
			matte_ptr28->set_cd(dark_purple);
			Sphere*	sphere_ptr28 = new Sphere(Point3D(30, -62, -140), 15); 
			sphere_ptr28->set_material(matte_ptr28); 							// dark purple
			add_object(sphere_ptr28);
	
			Matte* matte_ptr29 = new Matte;
			matte_ptr29->set_ka(ka);	
			matte_ptr29->set_kd(kd);
			matte_ptr29->set_cd(dark_purple);
			Sphere*	sphere_ptr29 = new Sphere(Point3D(25, 63, -140), 15); 
			sphere_ptr29->set_material(matte_ptr29);							// dark purple
			add_object(sphere_ptr29);
	
			Matte* matte_ptr30 = new Matte;
			matte_ptr30->set_ka(ka);	
			matte_ptr30->set_kd(kd);
			matte_ptr30->set_cd(dark_purple);
			Sphere*	sphere_ptr30 = new Sphere(Point3D(-60, 46, -140), 15);  
			sphere_ptr30->set_material(matte_ptr30); 							// dark purple
			add_object(sphere_ptr30);
	
			Matte* matte_ptr31 = new Matte;
			matte_ptr31->set_ka(ka);	
			matte_ptr31->set_kd(kd);
			matte_ptr31->set_cd(light_purple);
			Sphere*	sphere_ptr31 = new Sphere(Point3D(-30, 68, -130), 12); 
			sphere_ptr31->set_material(matte_ptr31); 							// light purple
			add_object(sphere_ptr31);
	
			Matte* matte_ptr32 = new Matte;
			matte_ptr32->set_ka(ka);	
			matte_ptr32->set_kd(kd);
			matte_ptr32->set_cd(green);
			Sphere*	sphere_ptr32 = new Sphere(Point3D(58, 56, -180), 11);   
			sphere_ptr32->set_material(matte_ptr32);							//  green
			add_object(sphere_ptr32);
	
			Matte* matte_ptr33 = new Matte;
			matte_ptr33->set_ka(ka);	
			matte_ptr33->set_kd(kd);
			matte_ptr33->set_cd(green);
			Sphere*	sphere_ptr33 = new Sphere(Point3D(-63, -39, -180), 11); 
			sphere_ptr33->set_material(matte_ptr33);							// green 
			add_object(sphere_ptr33);
	
			Matte* matte_ptr34 = new Matte;
			matte_ptr34->set_ka(ka);	
			matte_ptr34->set_kd(kd);
			matte_ptr34->set_cd(light_purple);
			Sphere*	sphere_ptr34 = new Sphere(Point3D(46, 68, -200), 10); 	
			sphere_ptr34->set_material(matte_ptr34);							// light purple
			add_object(sphere_ptr34);
	
			Matte* matte_ptr35 = new Matte;
			matte_ptr35->set_ka(ka);	
			matte_ptr35->set_kd(kd);
			matte_ptr35->set_cd(light_purple);
			Sphere*	sphere_ptr35 = new Sphere(Point3D(-3, -72, -130), 12); 
			sphere_ptr35->set_material(matte_ptr35);							// light purple
			add_object(sphere_ptr35);
			break;
		}
	case 74:
		{
			//14.24a
			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(300);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 25, 100);  
			pinhole_ptr->set_lookat(0);   
			pinhole_ptr->set_view_distance(6500);	 
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(200, 250, 300);  
			light_ptr->set_color(white);  			// for Figure 14.24(a)
		//	light_ptr->set_color(0, 0, 1);  		// for Figure 14.24(b)
			light_ptr->scale_radiance(3.0);			
			light_ptr->set_shadows(true);    // see Chapter 16
			add_light(light_ptr);
	
	
			// four spheres centered on the x axis
	
			float radius = 1.0;
			float gap = 0.2;	 // gap between spheres
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.0); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(1, 0, 0);		// red
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(-3.0 * radius - 1.5 * gap, 0.0, 0.0), radius);
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.0); 
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(1, 0.5, 0);		// orange
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-radius - 0.5 * gap, 0.0, 0.0), radius);
			sphere_ptr2->set_material(matte_ptr2);
			add_object(sphere_ptr2);
	
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(0.0); 
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(1, 1, 0);		// yellow
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(radius + 0.5 * gap, 0.0, 0.0), radius);
			sphere_ptr3->set_material(matte_ptr3);
			add_object(sphere_ptr3);
	
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(0.0); 
			matte_ptr4->set_kd(0.75);
			matte_ptr4->set_cd(0, 1, 0);		// green
	
			Sphere* sphere_ptr4 = new Sphere(Point3D(3.0 * radius + 1.5 * gap, 0.0, 0.0), radius);
			sphere_ptr4->set_material(matte_ptr4);
			add_object(sphere_ptr4);
		
	
			// ground plane
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(0.25); 
			matte_ptr5->set_kd(0.5);	
			matte_ptr5->set_cd(1.0);    
	
			Plane* plane_ptr = new Plane(Point3D(0, -1, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr5);
			add_object(plane_ptr);
			break;
		}
	case 75:
		{
			//14.24b
			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(300);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 25, 100);  
			pinhole_ptr->set_lookat(0);   
			pinhole_ptr->set_view_distance(6500);	 
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(200, 250, 300);  
		//	light_ptr->set_color(white);  			// for Figure 14.24(a)
			light_ptr->set_color(0, 0, 1);  		// for Figure 14.24(b)
			light_ptr->scale_radiance(3.0);			
			light_ptr->set_shadows(true);    // see Chapter 16
			add_light(light_ptr);
	
	
			// four spheres centered on the x axis
	
			float radius = 1.0;
			float gap = 0.2;	 // gap between spheres
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.0); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(1, 0, 0);		// red
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(-3.0 * radius - 1.5 * gap, 0.0, 0.0), radius);
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.0); 
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(1, 0.5, 0);		// orange
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-radius - 0.5 * gap, 0.0, 0.0), radius);
			sphere_ptr2->set_material(matte_ptr2);
			add_object(sphere_ptr2);
	
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(0.0); 
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(1, 1, 0);		// yellow
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(radius + 0.5 * gap, 0.0, 0.0), radius);
			sphere_ptr3->set_material(matte_ptr3);
			add_object(sphere_ptr3);
	
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(0.0); 
			matte_ptr4->set_kd(0.75);
			matte_ptr4->set_cd(0, 1, 0);		// green
	
			Sphere* sphere_ptr4 = new Sphere(Point3D(3.0 * radius + 1.5 * gap, 0.0, 0.0), radius);
			sphere_ptr4->set_material(matte_ptr4);
			add_object(sphere_ptr4);
		
	
			// ground plane
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(0.25); 
			matte_ptr5->set_kd(0.5);	
			matte_ptr5->set_cd(1.0);    
	
			Plane* plane_ptr = new Plane(Point3D(0, -1, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr5);
			add_object(plane_ptr);
			break;
		}
	case 76:
		{
			//14.26
			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(300);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 25, 100);  
			pinhole_ptr->set_lookat(0);   
			pinhole_ptr->set_view_distance(6500);	 
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(200, 250, 300);  
			light_ptr->set_color(1.0, 0.5, 0.0);  	// orange
			light_ptr->scale_radiance(3.0);			
			light_ptr->set_shadows(true);    // see Chapter 16
			add_light(light_ptr);
	
	
			// four spheres centered on the x axis
	
			float radius = 1.0;
			float gap = 0.2;	 // gap between spheres
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.0); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(1, 0, 0);		// red
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(-3.0 * radius - 1.5 * gap, 0.0, 0.0), radius);
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.0); 
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(1, 0.5, 0);		// orange
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-radius - 0.5 * gap, 0.0, 0.0), radius);
			sphere_ptr2->set_material(matte_ptr2);
			add_object(sphere_ptr2);
	
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(0.0); 
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(1, 1, 0);		// yellow
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(radius + 0.5 * gap, 0.0, 0.0), radius);
			sphere_ptr3->set_material(matte_ptr3);
			add_object(sphere_ptr3);
	
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(0.0); 
			matte_ptr4->set_kd(0.75);
			matte_ptr4->set_cd(0, 1, 0);		// green
	
			Sphere* sphere_ptr4 = new Sphere(Point3D(3.0 * radius + 1.5 * gap, 0.0, 0.0), radius);
			sphere_ptr4->set_material(matte_ptr4);
			add_object(sphere_ptr4);
		
	
			// ground plane
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(0.25); 
			matte_ptr5->set_kd(0.5);	
			matte_ptr5->set_cd(1.0);    
	
			Plane* plane_ptr = new Plane(Point3D(0, -1, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr5);
			add_object(plane_ptr);
			break;
		}
	case 77:
		{
			//15p1
			int num_samples = 1;
	  
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_pixel_size(0.5);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10000);
			pinhole_ptr->set_lookat(0.0);   
			pinhole_ptr->set_view_distance(15000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(100, 100, 200);
			light_ptr->scale_radiance(3.0); 			
			add_light(light_ptr);
	
		
			// colors

			float a = 0.75;  // scaling factor for yellow, orange, and light green
	
			RGBColour yellow(a * 1, a * 1, 0);								// yellow
			RGBColour brown(0.71, 0.40, 0.16);								// brown
			RGBColour dark_green(0.0, 0.41, 0.41);							// dark_green
			RGBColour orange(a * 1, a * 0.75, 0);							// orange
			RGBColour green(0, 0.6, 0.3);									// green
			RGBColour light_green(a * 0.65, a * 1, a * 0.30);				// light green
			RGBColour dark_yellow(0.61, 0.61, 0);							// dark yellow
			RGBColour light_purple(0.65, 0.3, 1);							// light purple
			RGBColour dark_purple(0.5, 0, 1);								// dark purple
	
	
			// Phong materials' reflection coefficients
	
			float ka 	= 0.25;
			float kd 	= 0.75;
			float ks 	= 0.1;
			float exp 	= 10;
		
			// spheres
	
			Phong* phong_ptr1 = new Phong;
			phong_ptr1->set_ka(ka);	
			phong_ptr1->set_kd(kd);
			phong_ptr1->set_ks(ks);
			phong_ptr1->set_exp(exp);
			phong_ptr1->set_cd(yellow);
					
			Sphere*	sphere_ptr1 = new Sphere(Point3D(5, 3, 0), 30); 
			sphere_ptr1->set_material(phong_ptr1);	   							// yellow
			add_object(sphere_ptr1);
	
	
			Phong* phong_ptr2 = new Phong;
			phong_ptr2->set_ka(ka);	
			phong_ptr2->set_kd(kd);
			phong_ptr2->set_ks(ks);
			phong_ptr2->set_exp(exp);
			phong_ptr2->set_cd(brown);
	
			Sphere*	sphere_ptr2 = new Sphere(Point3D(45, -7, -60), 20); 
			sphere_ptr2->set_material(phong_ptr2);								// brown
			add_object(sphere_ptr2);
	

			Phong* phong_ptr3 = new Phong;
			phong_ptr3->set_ka(ka);	
			phong_ptr3->set_kd(kd);
			phong_ptr3->set_ks(ks);
			phong_ptr3->set_exp(exp);
			phong_ptr3->set_cd(dark_green);
		
			Sphere*	sphere_ptr3 = new Sphere(Point3D(40, 43, -100), 17); 
			sphere_ptr3->set_material(phong_ptr3);								// dark green
			add_object(sphere_ptr3);
	
	
			Phong* phong_ptr4 = new Phong;
			phong_ptr4->set_ka(ka);	
			phong_ptr4->set_kd(kd);
			phong_ptr4->set_ks(ks);
			phong_ptr4->set_exp(exp);
			phong_ptr4->set_cd(orange);
	
			Sphere*	sphere_ptr4 = new Sphere(Point3D(-20, 28, -15), 20); 
			sphere_ptr4->set_material(phong_ptr4);								// orange
			add_object(sphere_ptr4);
	
	
			Phong* phong_ptr5 = new Phong;
			phong_ptr5->set_ka(ka);	
			phong_ptr5->set_kd(kd);
			phong_ptr5->set_ks(ks);
			phong_ptr5->set_exp(exp);
			phong_ptr5->set_cd(green);
	
			Sphere*	sphere_ptr5 = new Sphere(Point3D(-25, -7, -35), 27); 			
			sphere_ptr5->set_material(phong_ptr5);								// green
			add_object(sphere_ptr5);
	
	
			Phong* phong_ptr6 = new Phong;
			phong_ptr6->set_ka(ka);	
			phong_ptr6->set_kd(kd);
			phong_ptr6->set_ks(ks);
			phong_ptr6->set_exp(exp);
			phong_ptr6->set_cd(light_green);
	
			Sphere*	sphere_ptr6 = new Sphere(Point3D(20, -27, -35), 25); 
			sphere_ptr6->set_material(phong_ptr6);								// light green
			add_object(sphere_ptr6);
	
	
			Phong* phong_ptr7 = new Phong;
			phong_ptr7->set_ka(ka);	
			phong_ptr7->set_kd(kd);
			phong_ptr7->set_ks(ks);
			phong_ptr7->set_exp(exp);
			phong_ptr7->set_cd(green);
	
			Sphere*	sphere_ptr7 = new Sphere(Point3D(35, 18, -35), 22); 
			sphere_ptr7->set_material(phong_ptr7);   							// green
			add_object(sphere_ptr7);
	
	
			Phong* phong_ptr8 = new Phong;
			phong_ptr8->set_ka(ka);	
			phong_ptr8->set_kd(kd);
			phong_ptr8->set_ks(ks);
			phong_ptr8->set_exp(exp);
			phong_ptr8->set_cd(brown);
	
			Sphere*	sphere_ptr8 = new Sphere(Point3D(-57, -17, -50), 15);  
			sphere_ptr8->set_material(phong_ptr8);								// brown
			add_object(sphere_ptr8);
	
	
			Phong* phong_ptr9 = new Phong;
			phong_ptr9->set_ka(ka);	
			phong_ptr9->set_kd(kd);
			phong_ptr9->set_ks(ks);
			phong_ptr9->set_exp(exp);
			phong_ptr9->set_cd(light_green);
	
			Sphere*	sphere_ptr9 = new Sphere(Point3D(-47, 16, -80), 23); 
			sphere_ptr9->set_material(phong_ptr9);								// light green
			add_object(sphere_ptr9);
	
	
			Phong* phong_ptr10 = new Phong;
			phong_ptr10->set_ka(ka);	
			phong_ptr10->set_kd(kd);
			phong_ptr10->set_ks(ks);
			phong_ptr10->set_exp(exp);
			phong_ptr10->set_cd(dark_green);
			
			Sphere*	sphere_ptr10 = new Sphere(Point3D(-15, -32, -60), 22); 
			sphere_ptr10->set_material(phong_ptr10);     						// dark green
			add_object(sphere_ptr10);
	
	
			Phong* phong_ptr11 = new Phong;
			phong_ptr11->set_ka(ka);	
			phong_ptr11->set_kd(kd);
			phong_ptr11->set_ks(ks);
			phong_ptr11->set_exp(exp);
			phong_ptr11->set_cd(dark_yellow);
	
			Sphere*	sphere_ptr11 = new Sphere(Point3D(-35, -37, -80), 22); 
			sphere_ptr11->set_material(phong_ptr11);							// dark yellow
			add_object(sphere_ptr11);
	
	
			Phong* phong_ptr12 = new Phong;
			phong_ptr12->set_ka(ka);	
			phong_ptr12->set_kd(kd);
			phong_ptr12->set_ks(ks);
			phong_ptr12->set_exp(exp);
			phong_ptr12->set_cd(dark_yellow);
	
			Sphere*	sphere_ptr12 = new Sphere(Point3D(10, 43, -80), 22); 
			sphere_ptr12->set_material(phong_ptr12);							// dark yellow
			add_object(sphere_ptr12);
	
	
			Phong* phong_ptr13 = new Phong;
			phong_ptr13->set_ka(ka);	
			phong_ptr13->set_kd(kd);
			phong_ptr13->set_ks(ks);
			phong_ptr13->set_exp(exp);
			phong_ptr13->set_cd(dark_yellow);
			
			Sphere*	sphere_ptr13 = new Sphere(Point3D(30, -7, -80), 10); 
			sphere_ptr13->set_material(phong_ptr13);
			add_object(sphere_ptr13);											// dark yellow (hidden)
	
	
			Phong* phong_ptr14 = new Phong;
			phong_ptr14->set_ka(ka);	
			phong_ptr14->set_kd(kd);
			phong_ptr14->set_ks(ks);
			phong_ptr14->set_exp(exp);
			phong_ptr14->set_cd(dark_green);
		
			Sphere*	sphere_ptr14 = new Sphere(Point3D(-40, 48, -110), 18); 
			sphere_ptr14->set_material(phong_ptr14); 							// dark green
			add_object(sphere_ptr14);
	
	
			Phong* phong_ptr15 = new Phong;
			phong_ptr15->set_ka(ka);	
			phong_ptr15->set_kd(kd);
			phong_ptr15->set_ks(ks);
			phong_ptr15->set_exp(exp);
			phong_ptr15->set_cd(brown);
		
			Sphere*	sphere_ptr15 = new Sphere(Point3D(-10, 53, -120), 18); 
			sphere_ptr15->set_material(phong_ptr15); 							// brown
			add_object(sphere_ptr15);
	
	
			Phong* phong_ptr16 = new Phong;
			phong_ptr16->set_ka(ka);	
			phong_ptr16->set_kd(kd);
			phong_ptr16->set_ks(ks);
			phong_ptr16->set_exp(exp);
			phong_ptr16->set_cd(light_purple);
	
			Sphere*	sphere_ptr16 = new Sphere(Point3D(-55, -52, -100), 10); 
			sphere_ptr16->set_material(phong_ptr16);							// light purple
			add_object(sphere_ptr16);
	
	
			Phong* phong_ptr17 = new Phong;
			phong_ptr17->set_ka(ka);	
			phong_ptr17->set_kd(kd);
			phong_ptr17->set_ks(ks);
			phong_ptr17->set_exp(exp);
			phong_ptr17->set_cd(brown);
	
			Sphere*	sphere_ptr17 = new Sphere(Point3D(5, -52, -100), 15); 		
			sphere_ptr17->set_material(phong_ptr17);							// browm
			add_object(sphere_ptr17);
	
	
			Phong* phong_ptr18 = new Phong;
			phong_ptr18->set_ka(ka);	
			phong_ptr18->set_kd(kd);
			phong_ptr18->set_ks(ks);
			phong_ptr18->set_exp(exp);
			phong_ptr18->set_cd(dark_purple);
	
			Sphere*	sphere_ptr18 = new Sphere(Point3D(-20, -57, -120), 15); 
			sphere_ptr18->set_material(phong_ptr18);							// dark purple
			add_object(sphere_ptr18);
	
	
			Phong* phong_ptr19 = new Phong;
			phong_ptr19->set_ka(ka);	
			phong_ptr19->set_kd(kd);
			phong_ptr19->set_ks(ks);
			phong_ptr19->set_exp(exp);
			phong_ptr19->set_cd(dark_green);
	
			Sphere*	sphere_ptr19 = new Sphere(Point3D(55, -27, -100), 17); 
			sphere_ptr19->set_material(phong_ptr19);							// dark green
			add_object(sphere_ptr19);
	
	
			Phong* phong_ptr20 = new Phong;
			phong_ptr20->set_ka(ka);	
			phong_ptr20->set_kd(kd);
			phong_ptr20->set_ks(ks);
			phong_ptr20->set_exp(exp);
			phong_ptr20->set_cd(brown);

			Sphere*	sphere_ptr20 = new Sphere(Point3D(50, -47, -120), 15); 
			sphere_ptr20->set_material(phong_ptr20);							// browm
			add_object(sphere_ptr20);
	
	
			Phong* phong_ptr21 = new Phong;
			phong_ptr21->set_ka(ka);	
			phong_ptr21->set_kd(kd);
			phong_ptr21->set_ks(ks);
			phong_ptr21->set_exp(exp);
			phong_ptr21->set_cd(light_purple);
	 	
			Sphere*	sphere_ptr21 = new Sphere(Point3D(70, -42, -150), 10); 
			sphere_ptr21->set_material(phong_ptr21);							// light purple
			add_object(sphere_ptr21);
	
	
			Phong* phong_ptr22 = new Phong;
			phong_ptr22->set_ka(ka);	
			phong_ptr22->set_kd(kd);
			phong_ptr22->set_ks(ks);
			phong_ptr22->set_exp(exp);
			phong_ptr22->set_cd(light_purple);
	
			Sphere*	sphere_ptr22 = new Sphere(Point3D(5, 73, -130), 12); 
			sphere_ptr22->set_material(phong_ptr22);							// light purple
			add_object(sphere_ptr22);
	
	
			Phong* phong_ptr23 = new Phong;
			phong_ptr23->set_ka(ka);	
			phong_ptr23->set_kd(kd);
			phong_ptr23->set_ks(ks);
			phong_ptr23->set_exp(exp);
			phong_ptr23->set_cd(dark_purple);
	
			Sphere*	sphere_ptr23 = new Sphere(Point3D(66, 21, -130), 13); 			
			sphere_ptr23->set_material(phong_ptr23);							// dark purple
			add_object(sphere_ptr23);	
	
	
			Phong* phong_ptr24 = new Phong;
			phong_ptr24->set_ka(ka);	
			phong_ptr24->set_kd(kd);
			phong_ptr24->set_ks(ks);
			phong_ptr24->set_exp(exp);
			phong_ptr24->set_cd(light_purple);
	 
			Sphere*	sphere_ptr24 = new Sphere(Point3D(72, -12, -140), 12); 
			sphere_ptr24->set_material(phong_ptr24);							// light purple
			add_object(sphere_ptr24);
	
	
			Phong* phong_ptr25 = new Phong;
			phong_ptr25->set_ka(ka);	
			phong_ptr25->set_kd(kd);
			phong_ptr25->set_ks(ks);
			phong_ptr25->set_exp(exp);
			phong_ptr25->set_cd(green);
	
			Sphere*	sphere_ptr25 = new Sphere(Point3D(64, 5, -160), 11); 			
			sphere_ptr25->set_material(phong_ptr25);					 		// green
			add_object(sphere_ptr25);
	
	
			Phong* phong_ptr26 = new Phong;
			phong_ptr26->set_ka(ka);	
			phong_ptr26->set_kd(kd);
			phong_ptr26->set_ks(ks);
			phong_ptr26->set_exp(exp);
			phong_ptr26->set_cd(light_purple);
	  
			Sphere*	sphere_ptr26 = new Sphere(Point3D(55, 38, -160), 12); 		
			sphere_ptr26->set_material(phong_ptr26);							// light purple
			add_object(sphere_ptr26);
	
	
			Phong* phong_ptr27 = new Phong;
			phong_ptr27->set_ka(ka);	
			phong_ptr27->set_kd(kd);
			phong_ptr27->set_ks(ks);
			phong_ptr27->set_exp(exp);
			phong_ptr27->set_cd(light_purple);
	
			Sphere*	sphere_ptr27 = new Sphere(Point3D(-73, -2, -160), 12); 		
			sphere_ptr27->set_material(phong_ptr27);							// light purple
			add_object(sphere_ptr27);
	
		
			Phong* phong_ptr28 = new Phong;
			phong_ptr28->set_ka(ka);	
			phong_ptr28->set_kd(kd);
			phong_ptr28->set_ks(ks);
			phong_ptr28->set_exp(exp);
			phong_ptr28->set_cd(dark_purple);
	 
			Sphere*	sphere_ptr28 = new Sphere(Point3D(30, -62, -140), 15); 
			sphere_ptr28->set_material(phong_ptr28); 							// dark purple
			add_object(sphere_ptr28);
	
	
	
			Phong* phong_ptr29 = new Phong;
			phong_ptr29->set_ka(ka);	
			phong_ptr29->set_kd(kd);
			phong_ptr29->set_ks(ks);
			phong_ptr29->set_exp(exp);
			phong_ptr29->set_cd(dark_purple);
	
			Sphere*	sphere_ptr29 = new Sphere(Point3D(25, 63, -140), 15); 
			sphere_ptr29->set_material(phong_ptr29);							// dark purple
			add_object(sphere_ptr29);
	
	
			Phong* phong_ptr30 = new Phong;
			phong_ptr30->set_ka(ka);	
			phong_ptr30->set_kd(kd);
			phong_ptr30->set_ks(ks);
			phong_ptr30->set_exp(exp);
			phong_ptr30->set_cd(dark_purple);
	
			Sphere*	sphere_ptr30 = new Sphere(Point3D(-60, 46, -140), 15);  
			sphere_ptr30->set_material(phong_ptr30); 							// dark purple
			add_object(sphere_ptr30);
	
	
			Phong* phong_ptr31 = new Phong;
			phong_ptr31->set_ka(ka);	
			phong_ptr31->set_kd(kd);
			phong_ptr31->set_ks(ks);
			phong_ptr31->set_exp(exp);
			phong_ptr31->set_cd(light_purple);
	
			Sphere*	sphere_ptr31 = new Sphere(Point3D(-30, 68, -130), 12); 
			sphere_ptr31->set_material(phong_ptr31); 							// light purple
			add_object(sphere_ptr31);
	
		
			Phong* phong_ptr32 = new Phong;
			phong_ptr32->set_ka(ka);	
			phong_ptr32->set_kd(kd);
			phong_ptr32->set_ks(ks);
			phong_ptr32->set_exp(exp);
			phong_ptr32->set_cd(green);
	
			Sphere*	sphere_ptr32 = new Sphere(Point3D(58, 56, -180), 11);   
			sphere_ptr32->set_material(phong_ptr32);							//  green
			add_object(sphere_ptr32);
	
	
			Phong* phong_ptr33 = new Phong;
			phong_ptr33->set_ka(ka);	
			phong_ptr33->set_kd(kd);
			phong_ptr33->set_ks(ks);
			phong_ptr33->set_exp(exp);
			phong_ptr33->set_cd(green);
	
			Sphere*	sphere_ptr33 = new Sphere(Point3D(-63, -39, -180), 11); 
			sphere_ptr33->set_material(phong_ptr33);							// green 
			add_object(sphere_ptr33);
	
	
			Phong* phong_ptr34 = new Phong;
			phong_ptr34->set_ka(ka);	
			phong_ptr34->set_kd(kd);
			phong_ptr34->set_ks(ks);
			phong_ptr34->set_exp(exp);
			phong_ptr34->set_cd(light_purple);
	
			Sphere*	sphere_ptr34 = new Sphere(Point3D(46, 68, -200), 10); 	
			sphere_ptr34->set_material(phong_ptr34);							// light purple
			add_object(sphere_ptr34);
	
	
			Phong* phong_ptr35 = new Phong;
			phong_ptr35->set_ka(ka);	
			phong_ptr35->set_kd(kd);
			phong_ptr35->set_ks(ks);
			phong_ptr35->set_exp(exp);
			phong_ptr35->set_cd(light_purple);
	
			Sphere*	sphere_ptr35 = new Sphere(Point3D(-3, -72, -130), 12); 
			sphere_ptr35->set_material(phong_ptr35);							// light purple
			add_object(sphere_ptr35);
			break;
		}
	case 78:
		{
			//15.07
			int num_samples = 1;
	
			vp.set_hres(650);	  		
			vp.set_vres(300);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0, 0, 0);
			pinhole_ptr->set_view_distance(6000); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(20, 0, 20);
			light_ptr2->scale_radiance(3.0);
			add_light(light_ptr2);
		
	
			// beveled cylinder
	
			float bottom 		= -2.0;
			float top 			= 2.0;
			float radius 		= 1.0;
			float bevel_radius 	= 0.2;
	
			BeveledCylinder* cylinder_ptr1 = new BeveledCylinder(bottom, top, radius, bevel_radius);
	
			for (int j = 0; j < 4; j++) {
				float exp;
	
				if (j == 0) exp = 5;
				if (j == 1) exp = 20;
				if (j == 2) exp = 100;
				if (j == 3) exp = 1000;
	
				Phong* phong_ptr = new Phong;
				phong_ptr->set_ka(0.25); 					
				phong_ptr->set_kd(0.6);
				phong_ptr->set_cd(0.5);
				phong_ptr->set_ks(0.2);
				phong_ptr->set_exp(exp);
	
				Instance* cylinder_ptr2 = new Instance(cylinder_ptr1);
				cylinder_ptr2->translate(-3.75 + 2.5 * j, 0, 0);
				cylinder_ptr2->set_material(phong_ptr);
				add_object(cylinder_ptr2);
			}
			break;
		}
	case 79:
		{
			//15.08a
			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			float a = 0.75;
			background_color = RGBColor(0.0, 0.3 * a, 0.25 * a);  // torquise
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7.5, 4, 10); 
			pinhole_ptr->set_lookat(-1, 3.7, 0);  
			pinhole_ptr->set_view_distance(340);		
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
			Directional* light_ptr1 = new Directional;	// for Figure 15.8(a)
			light_ptr1->set_direction(15, 15, 2.5); 
			light_ptr1->scale_radiance(2.0);	
			add_light(light_ptr1);
	
			PointLight* light_ptr2 = new PointLight;	// for Figure 15.8(b)
			light_ptr2->set_location(15, 15, 2.5); 
			light_ptr2->scale_radiance(2.0);	
		//	add_light(light_ptr2);
	
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(0.25); 
			phong_ptr1->set_kd(0.75);
			phong_ptr1->set_cd(0.75, 0.75, 0);  	// dark yellow
			phong_ptr1->set_ks(0.25);
			phong_ptr1->set_exp(50);
	
			Phong* phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(0.45); 
			phong_ptr2->set_kd(0.75);
			phong_ptr2->set_cd(0.75, 0.25, 0);   	// orange
			phong_ptr2->set_ks(0.25);
			phong_ptr2->set_exp(500);
	
			Phong* phong_ptr3 = new Phong;			
			phong_ptr3->set_ka(0.4); 
			phong_ptr3->set_kd(0.75);
			phong_ptr3->set_cd(1, 0.5, 1);			// mauve
			phong_ptr3->set_ks(0.25);
			phong_ptr3->set_exp(4);
	
			Phong* phong_ptr4 = new Phong;			
			phong_ptr4->set_ka(0.15); 
			phong_ptr4->set_kd(0.5);
			phong_ptr4->set_cd(0.75, 1.0, 0.75);   	// light green
			phong_ptr4->set_ks(0.5);
			phong_ptr4->set_exp(3);
		
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(0.20); 
			matte_ptr5->set_kd(0.97);	
			matte_ptr5->set_cd(white);  
	
	
			// spheres
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(3.85, 2.3, -2.55), 2.3);
			sphere_ptr1->set_material(phong_ptr1);
			add_object(sphere_ptr1);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-0.7, 1, 4.2), 2);
			sphere_ptr2->set_material(phong_ptr2);     
			add_object(sphere_ptr2);

			// cylinder 
	
			float bottom 	= 0.0;
			float top 		= 8.5;   
			float radius	= 2.2;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(phong_ptr3);
			add_object(cylinder_ptr);
	
			// box
		
			Box* box_ptr = new Box(Point3D(-3.5, 0, -11), Point3D(-2.5, 6, 6.5));
			box_ptr->set_material(phong_ptr4);
			add_object(box_ptr);
	
			// ground plane
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr5);
			add_object(plane_ptr);
			break;
		}
	case 80:
		{
			//15.08b
			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			float a = 0.75;
			background_color = RGBColor(0.0, 0.3 * a, 0.25 * a);  // torquise
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7.5, 4, 10); 
			pinhole_ptr->set_lookat(-1, 3.7, 0);  
			pinhole_ptr->set_view_distance(340);		
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
			Directional* light_ptr1 = new Directional;	// for Figure 15.8(a)
			light_ptr1->set_direction(15, 15, 2.5); 
			light_ptr1->scale_radiance(2.0);	
		//	add_light(light_ptr1);
	
			PointLight* light_ptr2 = new PointLight;	// for Figure 15.8(b)
			light_ptr2->set_location(15, 15, 2.5); 
			light_ptr2->scale_radiance(2.0);	
			add_light(light_ptr2);
	
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(0.25); 
			phong_ptr1->set_kd(0.75);
			phong_ptr1->set_cd(0.75, 0.75, 0);  	// dark yellow
			phong_ptr1->set_ks(0.25);
			phong_ptr1->set_exp(50);
	
			Phong* phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(0.45); 
			phong_ptr2->set_kd(0.75);
			phong_ptr2->set_cd(0.75, 0.25, 0);   	// orange
			phong_ptr2->set_ks(0.25);
			phong_ptr2->set_exp(500);
	
			Phong* phong_ptr3 = new Phong;			
			phong_ptr3->set_ka(0.4); 
			phong_ptr3->set_kd(0.75);
			phong_ptr3->set_cd(1, 0.5, 1);			// mauve
			phong_ptr3->set_ks(0.25);
			phong_ptr3->set_exp(4);
	
			Phong* phong_ptr4 = new Phong;			
			phong_ptr4->set_ka(0.15); 
			phong_ptr4->set_kd(0.5);
			phong_ptr4->set_cd(0.75, 1.0, 0.75);   	// light green
			phong_ptr4->set_ks(0.5);
			phong_ptr4->set_exp(3);
		
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(0.20); 
			matte_ptr5->set_kd(0.97);	
			matte_ptr5->set_cd(white);  
	
	
			// spheres
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(3.85, 2.3, -2.55), 2.3);
			sphere_ptr1->set_material(phong_ptr1);
			add_object(sphere_ptr1);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-0.7, 1, 4.2), 2);
			sphere_ptr2->set_material(phong_ptr2);     
			add_object(sphere_ptr2);

			// cylinder 
	
			float bottom 	= 0.0;
			float top 		= 8.5;   
			float radius	= 2.2;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(phong_ptr3);
			add_object(cylinder_ptr);
	
			// box
		
			Box* box_ptr = new Box(Point3D(-3.5, 0, -11), Point3D(-2.5, 6, 6.5));
			box_ptr->set_material(phong_ptr4);
			add_object(box_ptr);
	
			// ground plane
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr5);
			add_object(plane_ptr);
			break;
		}
	case 81:
		{
			//15.15
			int num_samples = 1;
	  
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_pixel_size(0.5);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10000);
			pinhole_ptr->set_lookat(0.0);   
			pinhole_ptr->set_view_distance(15000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(100, 100, 200);
			light_ptr->scale_radiance(3.0); 			
			add_light(light_ptr);
	
		
			// colors

			float a = 0.75;  // scaling factor for yellow, orange, and light green
	
			RGBColour yellow(a * 1, a * 1, 0);								// yellow
			RGBColour brown(0.71, 0.40, 0.16);								// brown
			RGBColour dark_green(0.0, 0.41, 0.41);							// dark_green
			RGBColour orange(a * 1, a * 0.75, 0);							// orange
			RGBColour green(0, 0.6, 0.3);									// green
			RGBColour light_green(a * 0.65, a * 1, a * 0.30);				// light green
			RGBColour dark_yellow(0.61, 0.61, 0);							// dark yellow
			RGBColour light_purple(0.65, 0.3, 1);							// light purple
			RGBColour dark_purple(0.5, 0, 1);								// dark purple
	
	
			// Phong materials reflection coefficients
	
			float ka 	= 0.25;
			float kd 	= 0.75;
			float ks 	= 0.1;
			float exp 	= 0.25;
	
	
			// spheres
	
			Phong* phong_ptr1 = new Phong;
			phong_ptr1->set_ka(ka);	
			phong_ptr1->set_kd(kd);
			phong_ptr1->set_ks(ks);
			phong_ptr1->set_exp(exp);
			phong_ptr1->set_cd(yellow);
					
			Sphere*	sphere_ptr1 = new Sphere(Point3D(5, 3, 0), 30); 
			sphere_ptr1->set_material(phong_ptr1);	   							// yellow
			add_object(sphere_ptr1);
	
	
			Phong* phong_ptr2 = new Phong;
			phong_ptr2->set_ka(ka);	
			phong_ptr2->set_kd(kd);
			phong_ptr2->set_ks(ks);
			phong_ptr2->set_exp(exp);
			phong_ptr2->set_cd(brown);
	
			Sphere*	sphere_ptr2 = new Sphere(Point3D(45, -7, -60), 20); 
			sphere_ptr2->set_material(phong_ptr2);								// brown
			add_object(sphere_ptr2);
	

			Phong* phong_ptr3 = new Phong;
			phong_ptr3->set_ka(ka);	
			phong_ptr3->set_kd(kd);
			phong_ptr3->set_ks(ks);
			phong_ptr3->set_exp(exp);
			phong_ptr3->set_cd(dark_green);
		
			Sphere*	sphere_ptr3 = new Sphere(Point3D(40, 43, -100), 17); 
			sphere_ptr3->set_material(phong_ptr3);								// dark green
			add_object(sphere_ptr3);
	
	
			Phong* phong_ptr4 = new Phong;
			phong_ptr4->set_ka(ka);	
			phong_ptr4->set_kd(kd);
			phong_ptr4->set_ks(ks);
			phong_ptr4->set_exp(exp);
			phong_ptr4->set_cd(orange);
	
			Sphere*	sphere_ptr4 = new Sphere(Point3D(-20, 28, -15), 20); 
			sphere_ptr4->set_material(phong_ptr4);								// orange
			add_object(sphere_ptr4);
	
	
			Phong* phong_ptr5 = new Phong;
			phong_ptr5->set_ka(ka);	
			phong_ptr5->set_kd(kd);
			phong_ptr5->set_ks(ks);
			phong_ptr5->set_exp(exp);
			phong_ptr5->set_cd(green);
	
			Sphere*	sphere_ptr5 = new Sphere(Point3D(-25, -7, -35), 27); 			
			sphere_ptr5->set_material(phong_ptr5);								// green
			add_object(sphere_ptr5);
	
	
			Phong* phong_ptr6 = new Phong;
			phong_ptr6->set_ka(ka);	
			phong_ptr6->set_kd(kd);
			phong_ptr6->set_ks(ks);
			phong_ptr6->set_exp(exp);
			phong_ptr6->set_cd(light_green);
	
			Sphere*	sphere_ptr6 = new Sphere(Point3D(20, -27, -35), 25); 
			sphere_ptr6->set_material(phong_ptr6);								// light green
			add_object(sphere_ptr6);
	
	
			Phong* phong_ptr7 = new Phong;
			phong_ptr7->set_ka(ka);	
			phong_ptr7->set_kd(kd);
			phong_ptr7->set_ks(ks);
			phong_ptr7->set_exp(exp);
			phong_ptr7->set_cd(green);
	
			Sphere*	sphere_ptr7 = new Sphere(Point3D(35, 18, -35), 22); 
			sphere_ptr7->set_material(phong_ptr7);   							// green
			add_object(sphere_ptr7);
	
	
			Phong* phong_ptr8 = new Phong;
			phong_ptr8->set_ka(ka);	
			phong_ptr8->set_kd(kd);
			phong_ptr8->set_ks(ks);
			phong_ptr8->set_exp(exp);
			phong_ptr8->set_cd(brown);
	
			Sphere*	sphere_ptr8 = new Sphere(Point3D(-57, -17, -50), 15);  
			sphere_ptr8->set_material(phong_ptr8);								// brown
			add_object(sphere_ptr8);
	
	
			Phong* phong_ptr9 = new Phong;
			phong_ptr9->set_ka(ka);	
			phong_ptr9->set_kd(kd);
			phong_ptr9->set_ks(ks);
			phong_ptr9->set_exp(exp);
			phong_ptr9->set_cd(light_green);
	
			Sphere*	sphere_ptr9 = new Sphere(Point3D(-47, 16, -80), 23); 
			sphere_ptr9->set_material(phong_ptr9);								// light green
			add_object(sphere_ptr9);
	
	
			Phong* phong_ptr10 = new Phong;
			phong_ptr10->set_ka(ka);	
			phong_ptr10->set_kd(kd);
			phong_ptr10->set_ks(ks);
			phong_ptr10->set_exp(exp);
			phong_ptr10->set_cd(dark_green);
			
			Sphere*	sphere_ptr10 = new Sphere(Point3D(-15, -32, -60), 22); 
			sphere_ptr10->set_material(phong_ptr10);     						// dark green
			add_object(sphere_ptr10);
	
	
			Phong* phong_ptr11 = new Phong;
			phong_ptr11->set_ka(ka);	
			phong_ptr11->set_kd(kd);
			phong_ptr11->set_ks(ks);
			phong_ptr11->set_exp(exp);
			phong_ptr11->set_cd(dark_yellow);
	
			Sphere*	sphere_ptr11 = new Sphere(Point3D(-35, -37, -80), 22); 
			sphere_ptr11->set_material(phong_ptr11);							// dark yellow
			add_object(sphere_ptr11);
	
	
			Phong* phong_ptr12 = new Phong;
			phong_ptr12->set_ka(ka);	
			phong_ptr12->set_kd(kd);
			phong_ptr12->set_ks(ks);
			phong_ptr12->set_exp(exp);
			phong_ptr12->set_cd(dark_yellow);
	
			Sphere*	sphere_ptr12 = new Sphere(Point3D(10, 43, -80), 22); 
			sphere_ptr12->set_material(phong_ptr12);							// dark yellow
			add_object(sphere_ptr12);
	
	
			Phong* phong_ptr13 = new Phong;
			phong_ptr13->set_ka(ka);	
			phong_ptr13->set_kd(kd);
			phong_ptr13->set_ks(ks);
			phong_ptr13->set_exp(exp);
			phong_ptr13->set_cd(dark_yellow);
			
			Sphere*	sphere_ptr13 = new Sphere(Point3D(30, -7, -80), 10); 
			sphere_ptr13->set_material(phong_ptr13);
			add_object(sphere_ptr13);											// dark yellow (hidden)
	
	
			Phong* phong_ptr14 = new Phong;
			phong_ptr14->set_ka(ka);	
			phong_ptr14->set_kd(kd);
			phong_ptr14->set_ks(ks);
			phong_ptr14->set_exp(exp);
			phong_ptr14->set_cd(dark_green);
		
			Sphere*	sphere_ptr14 = new Sphere(Point3D(-40, 48, -110), 18); 
			sphere_ptr14->set_material(phong_ptr14); 							// dark green
			add_object(sphere_ptr14);
	
	
			Phong* phong_ptr15 = new Phong;
			phong_ptr15->set_ka(ka);	
			phong_ptr15->set_kd(kd);
			phong_ptr15->set_ks(ks);
			phong_ptr15->set_exp(exp);
			phong_ptr15->set_cd(brown);
		
			Sphere*	sphere_ptr15 = new Sphere(Point3D(-10, 53, -120), 18); 
			sphere_ptr15->set_material(phong_ptr15); 							// brown
			add_object(sphere_ptr15);
	
	
			Phong* phong_ptr16 = new Phong;
			phong_ptr16->set_ka(ka);	
			phong_ptr16->set_kd(kd);
			phong_ptr16->set_ks(ks);
			phong_ptr16->set_exp(exp);
			phong_ptr16->set_cd(light_purple);
	
			Sphere*	sphere_ptr16 = new Sphere(Point3D(-55, -52, -100), 10); 
			sphere_ptr16->set_material(phong_ptr16);							// light purple
			add_object(sphere_ptr16);
	
	
			Phong* phong_ptr17 = new Phong;
			phong_ptr17->set_ka(ka);	
			phong_ptr17->set_kd(kd);
			phong_ptr17->set_ks(ks);
			phong_ptr17->set_exp(exp);
			phong_ptr17->set_cd(brown);
	
			Sphere*	sphere_ptr17 = new Sphere(Point3D(5, -52, -100), 15); 		
			sphere_ptr17->set_material(phong_ptr17);							// browm
			add_object(sphere_ptr17);
	
	
			Phong* phong_ptr18 = new Phong;
			phong_ptr18->set_ka(ka);	
			phong_ptr18->set_kd(kd);
			phong_ptr18->set_ks(ks);
			phong_ptr18->set_exp(exp);
			phong_ptr18->set_cd(dark_purple);
	
			Sphere*	sphere_ptr18 = new Sphere(Point3D(-20, -57, -120), 15); 
			sphere_ptr18->set_material(phong_ptr18);							// dark purple
			add_object(sphere_ptr18);
	
	
			Phong* phong_ptr19 = new Phong;
			phong_ptr19->set_ka(ka);	
			phong_ptr19->set_kd(kd);
			phong_ptr19->set_ks(ks);
			phong_ptr19->set_exp(exp);
			phong_ptr19->set_cd(dark_green);
	
			Sphere*	sphere_ptr19 = new Sphere(Point3D(55, -27, -100), 17); 
			sphere_ptr19->set_material(phong_ptr19);							// dark green
			add_object(sphere_ptr19);
	
	
			Phong* phong_ptr20 = new Phong;
			phong_ptr20->set_ka(ka);	
			phong_ptr20->set_kd(kd);
			phong_ptr20->set_ks(ks);
			phong_ptr20->set_exp(exp);
			phong_ptr20->set_cd(brown);

			Sphere*	sphere_ptr20 = new Sphere(Point3D(50, -47, -120), 15); 
			sphere_ptr20->set_material(phong_ptr20);							// browm
			add_object(sphere_ptr20);
	
	
			Phong* phong_ptr21 = new Phong;
			phong_ptr21->set_ka(ka);	
			phong_ptr21->set_kd(kd);
			phong_ptr21->set_ks(ks);
			phong_ptr21->set_exp(exp);
			phong_ptr21->set_cd(light_purple);
	 	
			Sphere*	sphere_ptr21 = new Sphere(Point3D(70, -42, -150), 10); 
			sphere_ptr21->set_material(phong_ptr21);							// light purple
			add_object(sphere_ptr21);
	
	
			Phong* phong_ptr22 = new Phong;
			phong_ptr22->set_ka(ka);	
			phong_ptr22->set_kd(kd);
			phong_ptr22->set_ks(ks);
			phong_ptr22->set_exp(exp);
			phong_ptr22->set_cd(light_purple);
	
			Sphere*	sphere_ptr22 = new Sphere(Point3D(5, 73, -130), 12); 
			sphere_ptr22->set_material(phong_ptr22);							// light purple
			add_object(sphere_ptr22);
	
	
			Phong* phong_ptr23 = new Phong;
			phong_ptr23->set_ka(ka);	
			phong_ptr23->set_kd(kd);
			phong_ptr23->set_ks(ks);
			phong_ptr23->set_exp(exp);
			phong_ptr23->set_cd(dark_purple);
	
			Sphere*	sphere_ptr23 = new Sphere(Point3D(66, 21, -130), 13); 			
			sphere_ptr23->set_material(phong_ptr23);							// dark purple
			add_object(sphere_ptr23);	
	
	
			Phong* phong_ptr24 = new Phong;
			phong_ptr24->set_ka(ka);	
			phong_ptr24->set_kd(kd);
			phong_ptr24->set_ks(ks);
			phong_ptr24->set_exp(exp);
			phong_ptr24->set_cd(light_purple);
	 
			Sphere*	sphere_ptr24 = new Sphere(Point3D(72, -12, -140), 12); 
			sphere_ptr24->set_material(phong_ptr24);							// light purple
			add_object(sphere_ptr24);
	
	
			Phong* phong_ptr25 = new Phong;
			phong_ptr25->set_ka(ka);	
			phong_ptr25->set_kd(kd);
			phong_ptr25->set_ks(ks);
			phong_ptr25->set_exp(exp);
			phong_ptr25->set_cd(green);
	
			Sphere*	sphere_ptr25 = new Sphere(Point3D(64, 5, -160), 11); 			
			sphere_ptr25->set_material(phong_ptr25);					 		// green
			add_object(sphere_ptr25);
	
	
			Phong* phong_ptr26 = new Phong;
			phong_ptr26->set_ka(ka);	
			phong_ptr26->set_kd(kd);
			phong_ptr26->set_ks(ks);
			phong_ptr26->set_exp(exp);
			phong_ptr26->set_cd(light_purple);
	  
			Sphere*	sphere_ptr26 = new Sphere(Point3D(55, 38, -160), 12); 		
			sphere_ptr26->set_material(phong_ptr26);							// light purple
			add_object(sphere_ptr26);
	
	
			Phong* phong_ptr27 = new Phong;
			phong_ptr27->set_ka(ka);	
			phong_ptr27->set_kd(kd);
			phong_ptr27->set_ks(ks);
			phong_ptr27->set_exp(exp);
			phong_ptr27->set_cd(light_purple);
	
			Sphere*	sphere_ptr27 = new Sphere(Point3D(-73, -2, -160), 12); 		
			sphere_ptr27->set_material(phong_ptr27);							// light purple
			add_object(sphere_ptr27);
	
		
			Phong* phong_ptr28 = new Phong;
			phong_ptr28->set_ka(ka);	
			phong_ptr28->set_kd(kd);
			phong_ptr28->set_ks(ks);
			phong_ptr28->set_exp(exp);
			phong_ptr28->set_cd(dark_purple);
	 
			Sphere*	sphere_ptr28 = new Sphere(Point3D(30, -62, -140), 15); 
			sphere_ptr28->set_material(phong_ptr28); 							// dark purple
			add_object(sphere_ptr28);
	
	
	
			Phong* phong_ptr29 = new Phong;
			phong_ptr29->set_ka(ka);	
			phong_ptr29->set_kd(kd);
			phong_ptr29->set_ks(ks);
			phong_ptr29->set_exp(exp);
			phong_ptr29->set_cd(dark_purple);
	
			Sphere*	sphere_ptr29 = new Sphere(Point3D(25, 63, -140), 15); 
			sphere_ptr29->set_material(phong_ptr29);							// dark purple
			add_object(sphere_ptr29);
	
	
			Phong* phong_ptr30 = new Phong;
			phong_ptr30->set_ka(ka);	
			phong_ptr30->set_kd(kd);
			phong_ptr30->set_ks(ks);
			phong_ptr30->set_exp(exp);
			phong_ptr30->set_cd(dark_purple);
	
			Sphere*	sphere_ptr30 = new Sphere(Point3D(-60, 46, -140), 15);  
			sphere_ptr30->set_material(phong_ptr30); 							// dark purple
			add_object(sphere_ptr30);
	
	
			Phong* phong_ptr31 = new Phong;
			phong_ptr31->set_ka(ka);	
			phong_ptr31->set_kd(kd);
			phong_ptr31->set_ks(ks);
			phong_ptr31->set_exp(exp);
			phong_ptr31->set_cd(light_purple);
	
			Sphere*	sphere_ptr31 = new Sphere(Point3D(-30, 68, -130), 12); 
			sphere_ptr31->set_material(phong_ptr31); 							// light purple
			add_object(sphere_ptr31);
	
		
			Phong* phong_ptr32 = new Phong;
			phong_ptr32->set_ka(ka);	
			phong_ptr32->set_kd(kd);
			phong_ptr32->set_ks(ks);
			phong_ptr32->set_exp(exp);
			phong_ptr32->set_cd(green);
	
			Sphere*	sphere_ptr32 = new Sphere(Point3D(58, 56, -180), 11);   
			sphere_ptr32->set_material(phong_ptr32);							//  green
			add_object(sphere_ptr32);
	
	
			Phong* phong_ptr33 = new Phong;
			phong_ptr33->set_ka(ka);	
			phong_ptr33->set_kd(kd);
			phong_ptr33->set_ks(ks);
			phong_ptr33->set_exp(exp);
			phong_ptr33->set_cd(green);
	
			Sphere*	sphere_ptr33 = new Sphere(Point3D(-63, -39, -180), 11); 
			sphere_ptr33->set_material(phong_ptr33);							// green 
			add_object(sphere_ptr33);
	
	
			Phong* phong_ptr34 = new Phong;
			phong_ptr34->set_ka(ka);	
			phong_ptr34->set_kd(kd);
			phong_ptr34->set_ks(ks);
			phong_ptr34->set_exp(exp);
			phong_ptr34->set_cd(light_purple);
	
			Sphere*	sphere_ptr34 = new Sphere(Point3D(46, 68, -200), 10); 	
			sphere_ptr34->set_material(phong_ptr34);							// light purple
			add_object(sphere_ptr34);
	
	
			Phong* phong_ptr35 = new Phong;
			phong_ptr35->set_ka(ka);	
			phong_ptr35->set_kd(kd);
			phong_ptr35->set_ks(ks);
			phong_ptr35->set_exp(exp);
			phong_ptr35->set_cd(light_purple);
	
			Sphere*	sphere_ptr35 = new Sphere(Point3D(-3, -72, -130), 12); 
			sphere_ptr35->set_material(phong_ptr35);							// light purple
			add_object(sphere_ptr35);
			break;
		}
	case 82:
		{
			//16p1
			int num_samples = 16;
	  
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_pixel_size(0.5);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10000);
			pinhole_ptr->set_lookat(0.0);   
			pinhole_ptr->set_view_distance(15000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(100, 100, 200);
			light_ptr->scale_radiance(3.0);
			light_ptr->set_shadows(true); 			
			add_light(light_ptr);
	
		
			// colors

			float a = 0.75;  // scaling factor for yellow, orange, and light green
	
			RGBColour yellow(a * 1, a * 1, 0);								// yellow
			RGBColour brown(0.71, 0.40, 0.16);								// brown
			RGBColour dark_green(0.0, 0.41, 0.41);							// dark_green
			RGBColour orange(a * 1, a * 0.75, 0);							// orange
			RGBColour green(0, 0.6, 0.3);									// green
			RGBColour light_green(a * 0.65, a * 1, a * 0.30);				// light green
			RGBColour dark_yellow(0.61, 0.61, 0);							// dark yellow
			RGBColour light_purple(0.65, 0.3, 1);							// light purple
			RGBColour dark_purple(0.5, 0, 1);								// dark purple
	
	
			// Phong materials' reflection coefficients
	
			float ka 	= 0.25;
			float kd 	= 0.75;
			float ks 	= 0.12;
			float exp 	= 20;
	
	
			// spheres
	
			Phong* phong_ptr1 = new Phong;
			phong_ptr1->set_ka(ka);	
			phong_ptr1->set_kd(kd);
			phong_ptr1->set_ks(ks);
			phong_ptr1->set_exp(exp);
			phong_ptr1->set_cd(yellow);
					
			Sphere*	sphere_ptr1 = new Sphere(Point3D(5, 3, 0), 30); 
			sphere_ptr1->set_material(phong_ptr1);	   							// yellow
			add_object(sphere_ptr1);
	
	
			Phong* phong_ptr2 = new Phong;
			phong_ptr2->set_ka(ka);	
			phong_ptr2->set_kd(kd);
			phong_ptr2->set_ks(ks);
			phong_ptr2->set_exp(exp);
			phong_ptr2->set_cd(brown);
	
			Sphere*	sphere_ptr2 = new Sphere(Point3D(45, -7, -60), 20); 
			sphere_ptr2->set_material(phong_ptr2);								// brown
			add_object(sphere_ptr2);
	

			Phong* phong_ptr3 = new Phong;
			phong_ptr3->set_ka(ka);	
			phong_ptr3->set_kd(kd);
			phong_ptr3->set_ks(ks);
			phong_ptr3->set_exp(exp);
			phong_ptr3->set_cd(dark_green);
		
			Sphere*	sphere_ptr3 = new Sphere(Point3D(40, 43, -100), 17); 
			sphere_ptr3->set_material(phong_ptr3);								// dark green
			add_object(sphere_ptr3);
	
	
			Phong* phong_ptr4 = new Phong;
			phong_ptr4->set_ka(ka);	
			phong_ptr4->set_kd(kd);
			phong_ptr4->set_ks(ks);
			phong_ptr4->set_exp(exp);
			phong_ptr4->set_cd(orange);
	
			Sphere*	sphere_ptr4 = new Sphere(Point3D(-20, 28, -15), 20); 
			sphere_ptr4->set_material(phong_ptr4);								// orange
			add_object(sphere_ptr4);
	
	
			Phong* phong_ptr5 = new Phong;
			phong_ptr5->set_ka(ka);	
			phong_ptr5->set_kd(kd);
			phong_ptr5->set_ks(ks);
			phong_ptr5->set_exp(exp);
			phong_ptr5->set_cd(green);
	
			Sphere*	sphere_ptr5 = new Sphere(Point3D(-25, -7, -35), 27); 			
			sphere_ptr5->set_material(phong_ptr5);								// green
			add_object(sphere_ptr5);
	
	
			Phong* phong_ptr6 = new Phong;
			phong_ptr6->set_ka(ka);	
			phong_ptr6->set_kd(kd);
			phong_ptr6->set_ks(ks);
			phong_ptr6->set_exp(exp);
			phong_ptr6->set_cd(light_green);
	
			Sphere*	sphere_ptr6 = new Sphere(Point3D(20, -27, -35), 25); 
			sphere_ptr6->set_material(phong_ptr6);								// light green
			add_object(sphere_ptr6);
	
	
			Phong* phong_ptr7 = new Phong;
			phong_ptr7->set_ka(ka);	
			phong_ptr7->set_kd(kd);
			phong_ptr7->set_ks(ks);
			phong_ptr7->set_exp(exp);
			phong_ptr7->set_cd(green);
	
			Sphere*	sphere_ptr7 = new Sphere(Point3D(35, 18, -35), 22); 
			sphere_ptr7->set_material(phong_ptr7);   							// green
			add_object(sphere_ptr7);
	
	
			Phong* phong_ptr8 = new Phong;
			phong_ptr8->set_ka(ka);	
			phong_ptr8->set_kd(kd);
			phong_ptr8->set_ks(ks);
			phong_ptr8->set_exp(exp);
			phong_ptr8->set_cd(brown);
	
			Sphere*	sphere_ptr8 = new Sphere(Point3D(-57, -17, -50), 15);  
			sphere_ptr8->set_material(phong_ptr8);								// brown
			add_object(sphere_ptr8);
	
	
			Phong* phong_ptr9 = new Phong;
			phong_ptr9->set_ka(ka);	
			phong_ptr9->set_kd(kd);
			phong_ptr9->set_ks(ks);
			phong_ptr9->set_exp(exp);
			phong_ptr9->set_cd(light_green);
	
			Sphere*	sphere_ptr9 = new Sphere(Point3D(-47, 16, -80), 23); 
			sphere_ptr9->set_material(phong_ptr9);								// light green
			add_object(sphere_ptr9);
	
	
			Phong* phong_ptr10 = new Phong;
			phong_ptr10->set_ka(ka);	
			phong_ptr10->set_kd(kd);
			phong_ptr10->set_ks(ks);
			phong_ptr10->set_exp(exp);
			phong_ptr10->set_cd(dark_green);
			
			Sphere*	sphere_ptr10 = new Sphere(Point3D(-15, -32, -60), 22); 
			sphere_ptr10->set_material(phong_ptr10);     						// dark green
			add_object(sphere_ptr10);
	
	
			Phong* phong_ptr11 = new Phong;
			phong_ptr11->set_ka(ka);	
			phong_ptr11->set_kd(kd);
			phong_ptr11->set_ks(ks);
			phong_ptr11->set_exp(exp);
			phong_ptr11->set_cd(dark_yellow);
	
			Sphere*	sphere_ptr11 = new Sphere(Point3D(-35, -37, -80), 22); 
			sphere_ptr11->set_material(phong_ptr11);							// dark yellow
			add_object(sphere_ptr11);
	
	
			Phong* phong_ptr12 = new Phong;
			phong_ptr12->set_ka(ka);	
			phong_ptr12->set_kd(kd);
			phong_ptr12->set_ks(ks);
			phong_ptr12->set_exp(exp);
			phong_ptr12->set_cd(dark_yellow);
	
			Sphere*	sphere_ptr12 = new Sphere(Point3D(10, 43, -80), 22); 
			sphere_ptr12->set_material(phong_ptr12);							// dark yellow
			add_object(sphere_ptr12);
	
	
			Phong* phong_ptr13 = new Phong;
			phong_ptr13->set_ka(ka);	
			phong_ptr13->set_kd(kd);
			phong_ptr13->set_ks(ks);
			phong_ptr13->set_exp(exp);
			phong_ptr13->set_cd(dark_yellow);
			
			Sphere*	sphere_ptr13 = new Sphere(Point3D(30, -7, -80), 10); 
			sphere_ptr13->set_material(phong_ptr13);
			add_object(sphere_ptr13);											// dark yellow (hidden)
	
	
			Phong* phong_ptr14 = new Phong;
			phong_ptr14->set_ka(ka);	
			phong_ptr14->set_kd(kd);
			phong_ptr14->set_ks(ks);
			phong_ptr14->set_exp(exp);
			phong_ptr14->set_cd(dark_green);
		
			Sphere*	sphere_ptr14 = new Sphere(Point3D(-40, 48, -110), 18); 
			sphere_ptr14->set_material(phong_ptr14); 							// dark green
			add_object(sphere_ptr14);
	
	
			Phong* phong_ptr15 = new Phong;
			phong_ptr15->set_ka(ka);	
			phong_ptr15->set_kd(kd);
			phong_ptr15->set_ks(ks);
			phong_ptr15->set_exp(exp);
			phong_ptr15->set_cd(brown);
		
			Sphere*	sphere_ptr15 = new Sphere(Point3D(-10, 53, -120), 18); 
			sphere_ptr15->set_material(phong_ptr15); 							// brown
			add_object(sphere_ptr15);
	
	
			Phong* phong_ptr16 = new Phong;
			phong_ptr16->set_ka(ka);	
			phong_ptr16->set_kd(kd);
			phong_ptr16->set_ks(ks);
			phong_ptr16->set_exp(exp);
			phong_ptr16->set_cd(light_purple);
	
			Sphere*	sphere_ptr16 = new Sphere(Point3D(-55, -52, -100), 10); 
			sphere_ptr16->set_material(phong_ptr16);							// light purple
			add_object(sphere_ptr16);
	
	
			Phong* phong_ptr17 = new Phong;
			phong_ptr17->set_ka(ka);	
			phong_ptr17->set_kd(kd);
			phong_ptr17->set_ks(ks);
			phong_ptr17->set_exp(exp);
			phong_ptr17->set_cd(brown);
	
			Sphere*	sphere_ptr17 = new Sphere(Point3D(5, -52, -100), 15); 		
			sphere_ptr17->set_material(phong_ptr17);							// browm
			add_object(sphere_ptr17);
	
	
			Phong* phong_ptr18 = new Phong;
			phong_ptr18->set_ka(ka);	
			phong_ptr18->set_kd(kd);
			phong_ptr18->set_ks(ks);
			phong_ptr18->set_exp(exp);
			phong_ptr18->set_cd(dark_purple);
	
			Sphere*	sphere_ptr18 = new Sphere(Point3D(-20, -57, -120), 15); 
			sphere_ptr18->set_material(phong_ptr18);							// dark purple
			add_object(sphere_ptr18);
	
	
			Phong* phong_ptr19 = new Phong;
			phong_ptr19->set_ka(ka);	
			phong_ptr19->set_kd(kd);
			phong_ptr19->set_ks(ks);
			phong_ptr19->set_exp(exp);
			phong_ptr19->set_cd(dark_green);
	
			Sphere*	sphere_ptr19 = new Sphere(Point3D(55, -27, -100), 17); 
			sphere_ptr19->set_material(phong_ptr19);							// dark green
			add_object(sphere_ptr19);
	
	
			Phong* phong_ptr20 = new Phong;
			phong_ptr20->set_ka(ka);	
			phong_ptr20->set_kd(kd);
			phong_ptr20->set_ks(ks);
			phong_ptr20->set_exp(exp);
			phong_ptr20->set_cd(brown);

			Sphere*	sphere_ptr20 = new Sphere(Point3D(50, -47, -120), 15); 
			sphere_ptr20->set_material(phong_ptr20);							// browm
			add_object(sphere_ptr20);
	
	
			Phong* phong_ptr21 = new Phong;
			phong_ptr21->set_ka(ka);	
			phong_ptr21->set_kd(kd);
			phong_ptr21->set_ks(ks);
			phong_ptr21->set_exp(exp);
			phong_ptr21->set_cd(light_purple);
	 	
			Sphere*	sphere_ptr21 = new Sphere(Point3D(70, -42, -150), 10); 
			sphere_ptr21->set_material(phong_ptr21);							// light purple
			add_object(sphere_ptr21);
	
	
			Phong* phong_ptr22 = new Phong;
			phong_ptr22->set_ka(ka);	
			phong_ptr22->set_kd(kd);
			phong_ptr22->set_ks(ks);
			phong_ptr22->set_exp(exp);
			phong_ptr22->set_cd(light_purple);
	
			Sphere*	sphere_ptr22 = new Sphere(Point3D(5, 73, -130), 12); 
			sphere_ptr22->set_material(phong_ptr22);							// light purple
			add_object(sphere_ptr22);
	
	
			Phong* phong_ptr23 = new Phong;
			phong_ptr23->set_ka(ka);	
			phong_ptr23->set_kd(kd);
			phong_ptr23->set_ks(ks);
			phong_ptr23->set_exp(exp);
			phong_ptr23->set_cd(dark_purple);
	
			Sphere*	sphere_ptr23 = new Sphere(Point3D(66, 21, -130), 13); 			
			sphere_ptr23->set_material(phong_ptr23);							// dark purple
			add_object(sphere_ptr23);	
	
	
			Phong* phong_ptr24 = new Phong;
			phong_ptr24->set_ka(ka);	
			phong_ptr24->set_kd(kd);
			phong_ptr24->set_ks(ks);
			phong_ptr24->set_exp(exp);
			phong_ptr24->set_cd(light_purple);
	 
			Sphere*	sphere_ptr24 = new Sphere(Point3D(72, -12, -140), 12); 
			sphere_ptr24->set_material(phong_ptr24);							// light purple
			add_object(sphere_ptr24);
	
	
			Phong* phong_ptr25 = new Phong;
			phong_ptr25->set_ka(ka);	
			phong_ptr25->set_kd(kd);
			phong_ptr25->set_ks(ks);
			phong_ptr25->set_exp(exp);
			phong_ptr25->set_cd(green);
	
			Sphere*	sphere_ptr25 = new Sphere(Point3D(64, 5, -160), 11); 			
			sphere_ptr25->set_material(phong_ptr25);					 		// green
			add_object(sphere_ptr25);
	
	
			Phong* phong_ptr26 = new Phong;
			phong_ptr26->set_ka(ka);	
			phong_ptr26->set_kd(kd);
			phong_ptr26->set_ks(ks);
			phong_ptr26->set_exp(exp);
			phong_ptr26->set_cd(light_purple);
	  
			Sphere*	sphere_ptr26 = new Sphere(Point3D(55, 38, -160), 12); 		
			sphere_ptr26->set_material(phong_ptr26);							// light purple
			add_object(sphere_ptr26);
	
	
			Phong* phong_ptr27 = new Phong;
			phong_ptr27->set_ka(ka);	
			phong_ptr27->set_kd(kd);
			phong_ptr27->set_ks(ks);
			phong_ptr27->set_exp(exp);
			phong_ptr27->set_cd(light_purple);
	
			Sphere*	sphere_ptr27 = new Sphere(Point3D(-73, -2, -160), 12); 		
			sphere_ptr27->set_material(phong_ptr27);							// light purple
			add_object(sphere_ptr27);
	
		
			Phong* phong_ptr28 = new Phong;
			phong_ptr28->set_ka(ka);	
			phong_ptr28->set_kd(kd);
			phong_ptr28->set_ks(ks);
			phong_ptr28->set_exp(exp);
			phong_ptr28->set_cd(dark_purple);
	 
			Sphere*	sphere_ptr28 = new Sphere(Point3D(30, -62, -140), 15); 
			sphere_ptr28->set_material(phong_ptr28); 							// dark purple
			add_object(sphere_ptr28);
	
	
	
			Phong* phong_ptr29 = new Phong;
			phong_ptr29->set_ka(ka);	
			phong_ptr29->set_kd(kd);
			phong_ptr29->set_ks(ks);
			phong_ptr29->set_exp(exp);
			phong_ptr29->set_cd(dark_purple);
	
			Sphere*	sphere_ptr29 = new Sphere(Point3D(25, 63, -140), 15); 
			sphere_ptr29->set_material(phong_ptr29);							// dark purple
			add_object(sphere_ptr29);
	
	
			Phong* phong_ptr30 = new Phong;
			phong_ptr30->set_ka(ka);	
			phong_ptr30->set_kd(kd);
			phong_ptr30->set_ks(ks);
			phong_ptr30->set_exp(exp);
			phong_ptr30->set_cd(dark_purple);
	
			Sphere*	sphere_ptr30 = new Sphere(Point3D(-60, 46, -140), 15);  
			sphere_ptr30->set_material(phong_ptr30); 							// dark purple
			add_object(sphere_ptr30);
	
	
			Phong* phong_ptr31 = new Phong;
			phong_ptr31->set_ka(ka);	
			phong_ptr31->set_kd(kd);
			phong_ptr31->set_ks(ks);
			phong_ptr31->set_exp(exp);
			phong_ptr31->set_cd(light_purple);
	
			Sphere*	sphere_ptr31 = new Sphere(Point3D(-30, 68, -130), 12); 
			sphere_ptr31->set_material(phong_ptr31); 							// light purple
			add_object(sphere_ptr31);
	
		
			Phong* phong_ptr32 = new Phong;
			phong_ptr32->set_ka(ka);	
			phong_ptr32->set_kd(kd);
			phong_ptr32->set_ks(ks);
			phong_ptr32->set_exp(exp);
			phong_ptr32->set_cd(green);
	
			Sphere*	sphere_ptr32 = new Sphere(Point3D(58, 56, -180), 11);   
			sphere_ptr32->set_material(phong_ptr32);							//  green
			add_object(sphere_ptr32);
	
	
			Phong* phong_ptr33 = new Phong;
			phong_ptr33->set_ka(ka);	
			phong_ptr33->set_kd(kd);
			phong_ptr33->set_ks(ks);
			phong_ptr33->set_exp(exp);
			phong_ptr33->set_cd(green);
	
			Sphere*	sphere_ptr33 = new Sphere(Point3D(-63, -39, -180), 11); 
			sphere_ptr33->set_material(phong_ptr33);							// green 
			add_object(sphere_ptr33);
	
	
			Phong* phong_ptr34 = new Phong;
			phong_ptr34->set_ka(ka);	
			phong_ptr34->set_kd(kd);
			phong_ptr34->set_ks(ks);
			phong_ptr34->set_exp(exp);
			phong_ptr34->set_cd(light_purple);
	
			Sphere*	sphere_ptr34 = new Sphere(Point3D(46, 68, -200), 10); 	
			sphere_ptr34->set_material(phong_ptr34);							// light purple
			add_object(sphere_ptr34);
	
	
			Phong* phong_ptr35 = new Phong;
			phong_ptr35->set_ka(ka);	
			phong_ptr35->set_kd(kd);
			phong_ptr35->set_ks(ks);
			phong_ptr35->set_exp(exp);
			phong_ptr35->set_cd(light_purple);
	
			Sphere*	sphere_ptr35 = new Sphere(Point3D(-3, -72, -130), 12); 
			sphere_ptr35->set_material(phong_ptr35);							// light purple
			add_object(sphere_ptr35);
			break;
		}
	case 83:
		{
			//16.01a
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			
			Pinhole* camera_ptr = new Pinhole;
			camera_ptr->set_eye(2, 2.5, 15);
			camera_ptr->set_lookat(0 + 3, 2.5, 0);
			camera_ptr->set_view_distance(700);    
			camera_ptr->compute_uvw(); 
			set_camera(camera_ptr);
	
			Directional* light_ptr1 = new Directional();
			light_ptr1->set_direction(200, 150, 125); 
			light_ptr1->scale_radiance(4.0);
		//	light_ptr1->set_shadows(true);				// for Figure 16.1(b)
			add_light(light_ptr1);
		
			PointLight* light_ptr2 = new PointLight();
			light_ptr2->set_location(-12, 15, 30); 
			light_ptr2->scale_radiance(4.0);
		//	light_ptr2->set_shadows(true);				// for Figure 16.1(b)
			add_light(light_ptr2);
		
			// sphere
	
			Matte* matte_ptr1 = new Matte();			
			matte_ptr1->set_ka(0.3); 
			matte_ptr1->set_kd(0.3);
			matte_ptr1->set_cd(0.5, 0.6, 0); 
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(0.0, 2.4, 0), 1.5); 
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);	
	
			// box
	
			Matte* matte_ptr2 = new Matte();			
			matte_ptr2->set_ka(0.2); 
			matte_ptr2->set_kd(0.3);
			matte_ptr2->set_cd(0.8,0.5,0);
							
			Box* box_ptr1 = new Box(Point3D(5.4, -0.5, -3), Point3D(7.5, 4.75, 0.60));
			box_ptr1->set_material(matte_ptr2);
			add_object(box_ptr1);
		
			// triangle
	
			Matte* matte_ptr3 = new Matte();			
			matte_ptr3->set_ka(0.35); 
			matte_ptr3->set_kd(0.50);
			matte_ptr3->set_cd(0, 0.5, 0.5);      // cyan

			Triangle* triangle_ptr1 = new Triangle(	Point3D(1.5, -0.5, 1.8), 		// front
													Point3D(7.5, -0.5, -9.00), 		// back
													Point3D(2.35, 5.8, 1.4));		// top									
			triangle_ptr1->set_material(matte_ptr3);        
			add_object(triangle_ptr1);
		
			// cylinder
	
			float bottom 	= -0.5;
			float top 		= 1.0;
			float radius 	= 1.0;

			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr2);
			add_object(cylinder_ptr);

			// ground plane

			Matte* matte_ptr4 = new Matte();			
			matte_ptr4->set_ka(0.1); 
			matte_ptr4->set_kd(0.2);
			matte_ptr4->set_cd(white);
	
			Plane* plane_ptr = new Plane(Point3D(0, -0.5, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr4);
			add_object(plane_ptr);
			break;
		}
	case 84:
		{
			//16.01b
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			
			Pinhole* camera_ptr = new Pinhole;
			camera_ptr->set_eye(2, 2.5, 15);
			camera_ptr->set_lookat(0 + 3, 2.5, 0);
			camera_ptr->set_view_distance(700);    
			camera_ptr->compute_uvw(); 
			set_camera(camera_ptr);
	
			Directional* light_ptr1 = new Directional();
			light_ptr1->set_direction(200, 150, 125); 
			light_ptr1->scale_radiance(4.0);
			light_ptr1->set_shadows(true);				// for Figure 16.1(b)
			add_light(light_ptr1);
		
			PointLight* light_ptr2 = new PointLight();
			light_ptr2->set_location(-12, 15, 30); 
			light_ptr2->scale_radiance(4.0);
			light_ptr2->set_shadows(true);				// for Figure 16.1(b)
			add_light(light_ptr2);
		
			// sphere
	
			Matte* matte_ptr1 = new Matte();			
			matte_ptr1->set_ka(0.3); 
			matte_ptr1->set_kd(0.3);
			matte_ptr1->set_cd(0.5, 0.6, 0); 
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(0.0, 2.4, 0), 1.5); 
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);	
	
			// box
	
			Matte* matte_ptr2 = new Matte();			
			matte_ptr2->set_ka(0.2); 
			matte_ptr2->set_kd(0.3);
			matte_ptr2->set_cd(0.8,0.5,0);
							
			Box* box_ptr1 = new Box(Point3D(5.4, -0.5, -3), Point3D(7.5, 4.75, 0.60));
			box_ptr1->set_material(matte_ptr2);
			add_object(box_ptr1);
		
			// triangle
	
			Matte* matte_ptr3 = new Matte();			
			matte_ptr3->set_ka(0.35); 
			matte_ptr3->set_kd(0.50);
			matte_ptr3->set_cd(0, 0.5, 0.5);      // cyan

			Triangle* triangle_ptr1 = new Triangle(	Point3D(1.5, -0.5, 1.8), 		// front
													Point3D(7.5, -0.5, -9.00), 		// back
													Point3D(2.35, 5.8, 1.4));		// top									
			triangle_ptr1->set_material(matte_ptr3);        
			add_object(triangle_ptr1);
		
			// cylinder
	
			float bottom 	= -0.5;
			float top 		= 1.0;
			float radius 	= 1.0;

			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr2);
			add_object(cylinder_ptr);

			// ground plane

			Matte* matte_ptr4 = new Matte();			
			matte_ptr4->set_ka(0.1); 
			matte_ptr4->set_kd(0.2);
			matte_ptr4->set_cd(white);
	
			Plane* plane_ptr = new Plane(Point3D(0, -0.5, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr4);
			add_object(plane_ptr);
			break;
		}
	case 85:
		{
			//16.05a
			int num_samples = 25;
	
			vp.set_hres(600);			
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			
			Pinhole* camera_ptr = new Pinhole;
	
			// for Figure 16.5(a)

			camera_ptr->set_eye(350, 1000, 500);   
			camera_ptr->set_lookat(-175, 550, -40);  
			camera_ptr->set_view_distance(350);
	
		/*
	
			// for Figure 16.5(b)
	
			camera_ptr->set_eye(1500, 750, 250);   
			camera_ptr->set_lookat(-50, 300, -600);  
			camera_ptr->set_view_distance(650);
	
		*/

			camera_ptr->compute_uvw(); 
			set_camera(camera_ptr);

	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(1500, 750, 250);   
			light_ptr->scale_radiance(4.5);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// box materials
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_cd(0, 0.5, 0.5);     // cyan
			matte_ptr1->set_ka(0.4); 
			matte_ptr1->set_kd(0.5); 
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_cd(1, 0, 0);     	  // red
			matte_ptr2->set_ka(0.4); 
			matte_ptr2->set_kd(0.5);  
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_cd(0.5, 0.6, 0);     // green
			matte_ptr3->set_ka(0.4); 
			matte_ptr3->set_kd(0.5); 
	
	
			// Construct rows of boxes stored in a grid
		
			Grid* grid_ptr = new Grid;
	
			// first row
	
			int num_boxes = 11;
			float wx = 50;
			float wz = 50;
			float h = 300;
			float s = 100;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx, 0, -(j + 1) * wz - j * s), 
										Point3D(0, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr1);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// second row
	
			h = 450;
	
			for (int j = 0; j <= num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx -wx - s, 0, -(j + 1) * wz - j * s), 
										Point3D(-wx - s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr2);
		//		add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
	
			// third row
	
			h = 600; 
	
			for (int j = 0; j <= num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx - 2 * wx - 2 * s, 0, -(j + 1) * wz - j * s), 
										Point3D(-2 * wx - 2 * s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr3);
		//		add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
	
			// ground plane with checker
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(wx); 
			checker_ptr->set_color1(0.7);  
			checker_ptr->set_color2(white);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.15);
			sv_matte_ptr1->set_kd(1.0); 
			sv_matte_ptr1->set_cd(checker_ptr);	
			Plane* plane_ptr = new Plane(Point3D(0, 1, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr1);
			add_object(plane_ptr);
			break;
		}
	case 86:
		{
			//16.05b
			int num_samples = 25;
	
			vp.set_hres(600);			
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			
			Pinhole* camera_ptr = new Pinhole;
	
			// for Figure 16.5(a)

		//	camera_ptr->set_eye(350, 1000, 500);   
		//	camera_ptr->set_lookat(-175, 550, -40);  
		//	camera_ptr->set_view_distance(350);
	
			// for Figure 16.5(b)
	
			camera_ptr->set_eye(1500, 750, 250);   
			camera_ptr->set_lookat(-50, 300, -600);  
			camera_ptr->set_view_distance(650);

			camera_ptr->compute_uvw(); 
			set_camera(camera_ptr);

	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(1500, 750, 250);   
			light_ptr->scale_radiance(4.5);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// box materials
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_cd(0, 0.5, 0.5);     // cyan
			matte_ptr1->set_ka(0.4); 
			matte_ptr1->set_kd(0.5); 
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_cd(1, 0, 0);     	  // red
			matte_ptr2->set_ka(0.4); 
			matte_ptr2->set_kd(0.5);  
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_cd(0.5, 0.6, 0);     // green
			matte_ptr3->set_ka(0.4); 
			matte_ptr3->set_kd(0.5); 
	
	
			// Construct rows of boxes stored in a grid
		
			Grid* grid_ptr = new Grid;
	
			// first row
	
			int num_boxes = 11;
			float wx = 50;
			float wz = 50;
			float h = 300;
			float s = 100;
	
			for (int j = 0; j < num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx, 0, -(j + 1) * wz - j * s), 
										Point3D(0, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr1);
			//	add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
			// second row
	
			h = 450;
	
			for (int j = 0; j <= num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx -wx - s, 0, -(j + 1) * wz - j * s), 
										Point3D(-wx - s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr2);
		//		add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
			// third row
	
			h = 600; 
	
			for (int j = 0; j <= num_boxes; j++) {
				Box* box_ptr = new Box(	Point3D(-wx - 2 * wx - 2 * s, 0, -(j + 1) * wz - j * s), 
										Point3D(-2 * wx - 2 * s, h, - j * wz - j * s));
				box_ptr->set_material(matte_ptr3);
		//		add_object(box_ptr);
				grid_ptr->add_object(box_ptr);
			}
	
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
			// ground plane with checker
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(wx); 
			checker_ptr->set_color1(0.7);  
			checker_ptr->set_color2(white);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.15);
			sv_matte_ptr1->set_kd(1.0); 
			sv_matte_ptr1->set_cd(checker_ptr);	
			Plane* plane_ptr = new Plane(Point3D(0, 1, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr1);
			add_object(plane_ptr);
			break;
		}
	case 87:
		{
			//16.09a
			int num_samples = 1;
	
			vp.set_hres(300);	  		
			vp.set_vres(200);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			
			Pinhole* camera_ptr = new Pinhole;
			camera_ptr->set_eye(2, 2.5, 15);
			camera_ptr->set_lookat(0 + 3, 2.5, 0);
			camera_ptr->set_view_distance(700);    
			camera_ptr->compute_uvw(); 
			set_camera(camera_ptr);
	
			Directional* light_ptr1 = new Directional();
			light_ptr1->set_direction(200, 150, 125); 
			light_ptr1->scale_radiance(4.0);
			light_ptr1->set_shadows(true);				// for Figure 16.1(b)
			add_light(light_ptr1);
		
			PointLight* light_ptr2 = new PointLight();
			light_ptr2->set_location(-12, 15, 30); 
			light_ptr2->scale_radiance(4.0);
			light_ptr2->set_shadows(true);				// for Figure 16.1(b)
			add_light(light_ptr2);
		
			// sphere
	
			Matte* matte_ptr1 = new Matte();			
			matte_ptr1->set_ka(0.3); 
			matte_ptr1->set_kd(0.3);
			matte_ptr1->set_cd(0.5, 0.6, 0); 
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(0.0, 2.4, 0), 1.5); 
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);	
	
			// box
	
			Matte* matte_ptr2 = new Matte();			
			matte_ptr2->set_ka(0.2); 
			matte_ptr2->set_kd(0.3);
			matte_ptr2->set_cd(0.8,0.5,0);
							
			Box* box_ptr1 = new Box(Point3D(5.4, -0.5, -3), Point3D(7.5, 4.75, 0.60));
			box_ptr1->set_material(matte_ptr2);
			add_object(box_ptr1);
		
			// triangle
	
			Matte* matte_ptr3 = new Matte();			
			matte_ptr3->set_ka(0.35); 
			matte_ptr3->set_kd(0.50);
			matte_ptr3->set_cd(0, 0.5, 0.5);      // cyan

			Triangle* triangle_ptr1 = new Triangle(	Point3D(1.5, -0.5, 1.8), 		// front
													Point3D(7.5, -0.5, -9.00), 		// back
													Point3D(2.35, 5.8, 1.4));		// top									
			triangle_ptr1->set_material(matte_ptr3);        
			add_object(triangle_ptr1);
		
			// cylinder

			float bottom 	= -0.5;
			float top 		= 1.0;
			float radius 	= 1.0;

			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr2);
			add_object(cylinder_ptr);

			// ground plane

			Matte* matte_ptr4 = new Matte();			
			matte_ptr4->set_ka(0.1); 
			matte_ptr4->set_kd(0.2);
			matte_ptr4->set_cd(white);
	
			Plane* plane_ptr = new Plane(Point3D(0, -0.5, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr4);
			add_object(plane_ptr);
			break;
		}
	case 88:
		{
			//16.10a
			int num_samples = 1;

			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_pixel_size(0.5);
			vp.set_samples(num_samples); 
	
			tracer_ptr = new RayCast(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(1.0);
			set_ambient_light(ambient_ptr);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 500);
			pinhole_ptr->set_lookat(-15, -10, 0);
			pinhole_ptr->set_vpd(850.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(100, 50, 150);
			light_ptr2->scale_radiance(3.0); 
			light_ptr2->set_shadows(true); 
			add_light(light_ptr2);

			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.25);	
			matte_ptr1->set_kd(0.65);
			matte_ptr1->set_cd(1, 1, 0);	  				// yellow	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(10, -5, 0), 27); 
			sphere_ptr1->set_material(matte_ptr1);	   							
			add_object(sphere_ptr1);
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(0.15);	
			matte_ptr2->set_kd(0.85);
			matte_ptr2->set_cd(0.71, 0.40, 0.16);   		// brown
			Sphere*	sphere_ptr2 = new Sphere(Point3D(-25, 10, -35), 27); 			
			sphere_ptr2->set_material(matte_ptr2);							
			add_object(sphere_ptr2);
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.15);	
			matte_ptr3->set_kd(0.5);
			matte_ptr3->set_cd(0, 0.4, 0.2);				// dark green
			Plane* plane_ptr = new Plane(Point3D(0, 0, -50), Normal(0, 0, 1)); 
			plane_ptr->set_material(matte_ptr3);								
			add_object(plane_ptr);
			break;
		}
	case 89:
		{
			//16.10b
			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			float a = 0.75;
			background_color = RGBColor(0.0, 0.3 * a, 0.25 * a);  // torquise
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7.5, 4, 10); 
			pinhole_ptr->set_lookat(-1, 3.7, 0);  
			pinhole_ptr->set_view_distance(340);		
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(15, 15, 2.5); 
			light_ptr->scale_radiance(2.0);
			light_ptr->set_shadows(true);	
			add_light(light_ptr);
	
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(0.25); 
			phong_ptr1->set_kd(0.75);
			phong_ptr1->set_cd(0.75, 0.75, 0);  	// dark yellow
			phong_ptr1->set_ks(0.25);
			phong_ptr1->set_exp(50);
	
			Phong* phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(0.45); 
			phong_ptr2->set_kd(0.75);
			phong_ptr2->set_cd(0.75, 0.25, 0);   	// orange
			phong_ptr2->set_ks(0.25);
			phong_ptr2->set_exp(500);
	
			Phong* phong_ptr3 = new Phong;			
			phong_ptr3->set_ka(0.4); 
			phong_ptr3->set_kd(0.75);
			phong_ptr3->set_cd(1, 0.5, 1);			// mauve
			phong_ptr3->set_ks(0.25);
			phong_ptr3->set_exp(4);
	
			Phong* phong_ptr4 = new Phong;			
			phong_ptr4->set_ka(0.15); 
			phong_ptr4->set_kd(0.5);
			phong_ptr4->set_cd(0.75, 1.0, 0.75);   	// light green
			phong_ptr4->set_ks(0.5);
			phong_ptr4->set_exp(3);
		
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(0.20); 
			matte_ptr5->set_kd(0.97);	
			matte_ptr5->set_cd(white);  
	
	
			// spheres
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(3.85, 2.3, -2.55), 2.3);
			sphere_ptr1->set_material(phong_ptr1);
			add_object(sphere_ptr1);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-0.7, 1, 4.2), 2);
			sphere_ptr2->set_material(phong_ptr2);     
			add_object(sphere_ptr2);

			// cylinder 
	
			float bottom 	= 0.0;
			float top 		= 8.5;   
			float radius	= 2.2;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(phong_ptr3);
			add_object(cylinder_ptr);
	
			// box
		
			Box* box_ptr = new Box(Point3D(-3.5, 0, -11), Point3D(-2.5, 6, 6.5));
			box_ptr->set_material(phong_ptr4);
			add_object(box_ptr);
	
			// ground plane
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr5);
			add_object(plane_ptr);
			break;
		}
	case 90:
		{
			//16.11b
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			
			Pinhole* camera_ptr = new Pinhole;
			camera_ptr->set_eye(0, 7, 10);
			camera_ptr->set_lookat(0, -1.5, 0);
			camera_ptr->set_view_distance(1200);     
			camera_ptr->compute_uvw(); 
			set_camera(camera_ptr);
		
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(3, 10, 2); 
			light_ptr1->set_color(1, 0, 0);				// red
			light_ptr1->scale_radiance(12.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-3, 10, 2); 
			light_ptr2->set_color(0, 1, 0);				// green
			light_ptr2->scale_radiance(12.0);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
			PointLight* light_ptr3 = new PointLight;
			light_ptr3->set_location(0, 10, -3); 
			light_ptr3->set_color(0, 0, 1);				// blue
			light_ptr3->scale_radiance(12.0);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
			// sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.6); 
			matte_ptr1->set_kd(0.2); 
			matte_ptr1->set_cd(0.5);
		
			Sphere*	sphere_ptr1 = new Sphere;  
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.0); 
			matte_ptr2->set_kd(0.35);
			matte_ptr2->set_cd(0.7); 	
	
			Plane* plane_ptr = new Plane(Point3D(0, -3, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);
			break;
		}
	case 91:
		{
			//17.03a
			int num_samples = 1;   // for Figure 17.3(a)
		//	int num_samples = 256;  // for Figure 17.3(b)
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);

			MultiJittered* sampler_ptr = new MultiJittered(num_samples); 

	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(1.0);
			set_ambient_light(ambient_ptr);					// for Figure 17.3(a)
	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
		//	set_ambient_light(occluder_ptr);				// for Figure 17.3(b)
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(25, 20, 45);
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(5000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			// sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.75);		
			matte_ptr1->set_kd(0);
			matte_ptr1->set_cd(1, 1, 0);   // yellow
		
			Sphere* sphere_ptr = new Sphere (Point3D(0, 1, 0), 1);  
			sphere_ptr->set_material(matte_ptr1);
			add_object(sphere_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.75);		
			matte_ptr2->set_kd(0);
			matte_ptr2->set_cd(white);       
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 92:
		{
			//17.03a
		//	int num_samples = 1;   // for Figure 17.3(a)
			int num_samples = 256;  // for Figure 17.3(b)
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);

			MultiJittered* sampler_ptr = new MultiJittered(num_samples); 

	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(1.0);
		//	set_ambient_light(ambient_ptr);					// for Figure 17.3(a)
	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
			set_ambient_light(occluder_ptr);				// for Figure 17.3(b)
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(25, 20, 45);
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(5000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			// sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.75);		
			matte_ptr1->set_kd(0);
			matte_ptr1->set_cd(1, 1, 0);   // yellow
		
			Sphere* sphere_ptr = new Sphere (Point3D(0, 1, 0), 1);  
			sphere_ptr->set_material(matte_ptr1);
			add_object(sphere_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.75);		
			matte_ptr2->set_kd(0);
			matte_ptr2->set_cd(white);       
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 93:
		{
			//17.04a
			int num_samples = 1;   	// for Figure 17.4(a)
		//	int num_samples = 16;  	// for Figure 17.4(b)
		//	int num_samples = 64;  	// for Figure 17.4(c)
		//	int num_samples = 256;	// for Figure 17.4(d)
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
		
			Regular* sampler_ptr = new Regular(num_samples);
	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
			set_ambient_light(occluder_ptr);	
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(25, 20, -45);
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(5000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			// sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.75);		
			matte_ptr1->set_kd(0);
			matte_ptr1->set_cd(1, 1, 0);   // yellow
		
			Sphere* sphere_ptr = new Sphere (Point3D(0, 1, 0), 1);  
			sphere_ptr->set_material(matte_ptr1);
			add_object(sphere_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.75);		
			matte_ptr2->set_kd(0);
			matte_ptr2->set_cd(white);        
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 94:
		{
			//17.04b
		//	int num_samples = 1;   	// for Figure 17.4(a)
			int num_samples = 16;  	// for Figure 17.4(b)
		//	int num_samples = 64;  	// for Figure 17.4(c)
		//	int num_samples = 256;	// for Figure 17.4(d)
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
		
			Regular* sampler_ptr = new Regular(num_samples);
	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
			set_ambient_light(occluder_ptr);	
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(25, 20, -45);
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(5000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			// sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.75);		
			matte_ptr1->set_kd(0);
			matte_ptr1->set_cd(1, 1, 0);   // yellow
		
			Sphere* sphere_ptr = new Sphere (Point3D(0, 1, 0), 1);  
			sphere_ptr->set_material(matte_ptr1);
			add_object(sphere_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.75);		
			matte_ptr2->set_kd(0);
			matte_ptr2->set_cd(white);        
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 95:
		{
			//17.04c
		//	int num_samples = 1;   	// for Figure 17.4(a)
		//	int num_samples = 16;  	// for Figure 17.4(b)
			int num_samples = 64;  	// for Figure 17.4(c)
		//	int num_samples = 256;	// for Figure 17.4(d)
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
		
			Regular* sampler_ptr = new Regular(num_samples);
	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
			set_ambient_light(occluder_ptr);	
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(25, 20, -45);
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(5000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			// sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.75);		
			matte_ptr1->set_kd(0);
			matte_ptr1->set_cd(1, 1, 0);   // yellow
		
			Sphere* sphere_ptr = new Sphere (Point3D(0, 1, 0), 1);  
			sphere_ptr->set_material(matte_ptr1);
			add_object(sphere_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.75);		
			matte_ptr2->set_kd(0);
			matte_ptr2->set_cd(white);        
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 96:
		{
			//17.04d
		//	int num_samples = 1;   	// for Figure 17.4(a)
		//	int num_samples = 16;  	// for Figure 17.4(b)
		//	int num_samples = 64;  	// for Figure 17.4(c)
			int num_samples = 256;	// for Figure 17.4(d)
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
		
			Regular* sampler_ptr = new Regular(num_samples);
	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
			set_ambient_light(occluder_ptr);	
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(25, 20, -45);
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(5000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			// sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.75);		
			matte_ptr1->set_kd(0);
			matte_ptr1->set_cd(1, 1, 0);   // yellow
		
			Sphere* sphere_ptr = new Sphere (Point3D(0, 1, 0), 1);  
			sphere_ptr->set_material(matte_ptr1);
			add_object(sphere_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.75);		
			matte_ptr2->set_kd(0);
			matte_ptr2->set_cd(white);        
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 97:
		{
			//17.06a
			int num_samples = 1;   	// for Figure 17.6(a)
		//	int num_samples = 16;  	// for Figure 17.6(b)
		//	int num_samples = 64;  	// for Figure 17.6(c)
		//	int num_samples = 256;	// for Figure 17.6(d)
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
		
			PureRandom* sampler_ptr = new PureRandom(num_samples);
	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
			set_ambient_light(occluder_ptr);		
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(25, 20, 45);
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(5000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			// sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.75);		
			matte_ptr1->set_kd(0);
			matte_ptr1->set_cd(1, 1, 0);   // yellow
		
			Sphere* sphere_ptr = new Sphere (Point3D(0, 1, 0), 1);  
			sphere_ptr->set_material(matte_ptr1);
			add_object(sphere_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.75);		
			matte_ptr2->set_kd(0);
			matte_ptr2->set_cd(white);      
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 98:
		{
			//17.06b
		//	int num_samples = 1;   	// for Figure 17.6(a)
			int num_samples = 16;  	// for Figure 17.6(b)
		//	int num_samples = 64;  	// for Figure 17.6(c)
		//	int num_samples = 256;	// for Figure 17.6(d)
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
		
			PureRandom* sampler_ptr = new PureRandom(num_samples);
	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
			set_ambient_light(occluder_ptr);		
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(25, 20, 45);
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(5000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			// sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.75);		
			matte_ptr1->set_kd(0);
			matte_ptr1->set_cd(1, 1, 0);   // yellow
		
			Sphere* sphere_ptr = new Sphere (Point3D(0, 1, 0), 1);  
			sphere_ptr->set_material(matte_ptr1);
			add_object(sphere_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.75);		
			matte_ptr2->set_kd(0);
			matte_ptr2->set_cd(white);      
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 99:
		{
			//17.06c
		//	int num_samples = 1;   	// for Figure 17.6(a)
		//	int num_samples = 16;  	// for Figure 17.6(b)
			int num_samples = 64;  	// for Figure 17.6(c)
		//	int num_samples = 256;	// for Figure 17.6(d)
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
		
			PureRandom* sampler_ptr = new PureRandom(num_samples);
	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
			set_ambient_light(occluder_ptr);		
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(25, 20, 45);
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(5000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			// sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.75);		
			matte_ptr1->set_kd(0);
			matte_ptr1->set_cd(1, 1, 0);   // yellow
		
			Sphere* sphere_ptr = new Sphere (Point3D(0, 1, 0), 1);  
			sphere_ptr->set_material(matte_ptr1);
			add_object(sphere_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.75);		
			matte_ptr2->set_kd(0);
			matte_ptr2->set_cd(white);      
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 100:
		{
			//17.06d
		//	int num_samples = 1;   	// for Figure 17.6(a)
		//	int num_samples = 16;  	// for Figure 17.6(b)
		//	int num_samples = 64;  	// for Figure 17.6(c)
			int num_samples = 256;	// for Figure 17.6(d)
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
		
			PureRandom* sampler_ptr = new PureRandom(num_samples);
	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
			set_ambient_light(occluder_ptr);		
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(25, 20, 45);
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(5000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			// sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.75);		
			matte_ptr1->set_kd(0);
			matte_ptr1->set_cd(1, 1, 0);   // yellow
		
			Sphere* sphere_ptr = new Sphere (Point3D(0, 1, 0), 1);  
			sphere_ptr->set_material(matte_ptr1);
			add_object(sphere_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.75);		
			matte_ptr2->set_kd(0);
			matte_ptr2->set_cd(white);      
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 101:
		{
			//17.07a
			int num_samples = 1;   	// for Figure 17.7(a)
		//	int num_samples = 16;  	// for Figure 17.7(b)
		//	int num_samples = 64;  	// for Figure 17.7(c)
		//	int num_samples = 256;	// for Figure 17.7(d)
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
		
			MultiJittered* sampler_ptr = new MultiJittered(num_samples); 
	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
			set_ambient_light(occluder_ptr);		
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(25, 20, 45);
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(5000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			// sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.75);		
			matte_ptr1->set_kd(0);
			matte_ptr1->set_cd(1, 1, 0);   // yellow
		
			Sphere* sphere_ptr = new Sphere (Point3D(0, 1, 0), 1);  
			sphere_ptr->set_material(matte_ptr1);
			add_object(sphere_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.75);		
			matte_ptr2->set_kd(0);
			matte_ptr2->set_cd(1);        // white
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 102:
		{
			//17.07b
		//	int num_samples = 1;   	// for Figure 17.7(a)
			int num_samples = 16;  	// for Figure 17.7(b)
		//	int num_samples = 64;  	// for Figure 17.7(c)
		//	int num_samples = 256;	// for Figure 17.7(d)
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
		
			MultiJittered* sampler_ptr = new MultiJittered(num_samples); 
	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
			set_ambient_light(occluder_ptr);		
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(25, 20, 45);
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(5000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			// sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.75);		
			matte_ptr1->set_kd(0);
			matte_ptr1->set_cd(1, 1, 0);   // yellow
		
			Sphere* sphere_ptr = new Sphere (Point3D(0, 1, 0), 1);  
			sphere_ptr->set_material(matte_ptr1);
			add_object(sphere_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.75);		
			matte_ptr2->set_kd(0);
			matte_ptr2->set_cd(1);        // white
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 103:
		{
			//17.07c
		//	int num_samples = 1;   	// for Figure 17.7(a)
		//	int num_samples = 16;  	// for Figure 17.7(b)
			int num_samples = 64;  	// for Figure 17.7(c)
		//	int num_samples = 256;	// for Figure 17.7(d)
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
		
			MultiJittered* sampler_ptr = new MultiJittered(num_samples); 
	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
			set_ambient_light(occluder_ptr);		
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(25, 20, 45);
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(5000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			// sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.75);		
			matte_ptr1->set_kd(0);
			matte_ptr1->set_cd(1, 1, 0);   // yellow
		
			Sphere* sphere_ptr = new Sphere (Point3D(0, 1, 0), 1);  
			sphere_ptr->set_material(matte_ptr1);
			add_object(sphere_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.75);		
			matte_ptr2->set_kd(0);
			matte_ptr2->set_cd(1);        // white
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 104:
		{
			//17.07d
		//	int num_samples = 1;   	// for Figure 17.7(a)
		//	int num_samples = 16;  	// for Figure 17.7(b)
		//	int num_samples = 64;  	// for Figure 17.7(c)
			int num_samples = 256;	// for Figure 17.7(d)
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
		
			MultiJittered* sampler_ptr = new MultiJittered(num_samples); 
	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
			set_ambient_light(occluder_ptr);		
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(25, 20, 45);
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(5000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			// sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.75);		
			matte_ptr1->set_kd(0);
			matte_ptr1->set_cd(1, 1, 0);   // yellow
		
			Sphere* sphere_ptr = new Sphere (Point3D(0, 1, 0), 1);  
			sphere_ptr->set_material(matte_ptr1);
			add_object(sphere_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.75);		
			matte_ptr2->set_kd(0);
			matte_ptr2->set_cd(1);        // white
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 105:
		{
			//17.08a
			int num_samples = 16;  	// for Figure 17.8(a)
		//	int num_samples = 256;	// for Figure 17.8(b)
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
		
			MultiJittered* sampler_ptr = new MultiJittered(num_samples); 
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(1.0);
			set_ambient_light(ambient_ptr);					// for Figure 17.8(a)
	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
		//	set_ambient_light(occluder_ptr);				// for Figure 17.8(b)
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(25, 20, 45);
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(5000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 150, 200);
			light_ptr->scale_radiance(1.5);  
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
			// sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.5);		
			matte_ptr1->set_kd(0.6);
			matte_ptr1->set_cd(1, 1, 0);   // yellow
		
			Sphere* sphere_ptr = new Sphere (Point3D(0, 1, 0), 1);  
			sphere_ptr->set_material(matte_ptr1);
			add_object(sphere_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.5);		
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(white);   
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 106:
		{
			//17.08b
		//	int num_samples = 16;  	// for Figure 17.8(a)
			int num_samples = 256;	// for Figure 17.8(b)
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
		
			MultiJittered* sampler_ptr = new MultiJittered(num_samples); 
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(1.0);
			set_ambient_light(ambient_ptr);					// for Figure 17.8(a)
	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
		//	set_ambient_light(occluder_ptr);				// for Figure 17.8(b)
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(25, 20, 45);
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(5000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 150, 200);
			light_ptr->scale_radiance(1.5);  
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
			// sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.5);		
			matte_ptr1->set_kd(0.6);
			matte_ptr1->set_cd(1, 1, 0);   // yellow
		
			Sphere* sphere_ptr = new Sphere (Point3D(0, 1, 0), 1);  
			sphere_ptr->set_material(matte_ptr1);
			add_object(sphere_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.5);		
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(white);   
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 107:
		{
			//17.09
			int num_samples = 256;
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
		
			MultiJittered* sampler_ptr = new MultiJittered(num_samples); 

	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
			set_ambient_light(occluder_ptr);			
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-5, 2, 10);
			pinhole_ptr->set_lookat(0.35, 0.45, 0); 
			pinhole_ptr->set_view_distance(2000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	

			// cylinder
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.85);		
			matte_ptr1->set_kd(0.6);
			matte_ptr1->set_cd(1, 0.5, 0); 
	
	
			float bottom	= 0;
			float top 		= 1;
			float radius 	= 1;
			float phi_min 	= 0;
			float phi_max 	= 180;
	
			ConvexPartCylinder* cylinder_ptr = new ConvexPartCylinder(	bottom, 
																		top, 
																		radius, 
																		phi_min, 
																		phi_max);
			cylinder_ptr->set_material(matte_ptr1);
			add_object(cylinder_ptr);	

			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.5);		
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(white);   
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 108:
		{
			//17.11a
			int num_samples = 256;
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
		
			MultiJittered* sampler_ptr = new MultiJittered(num_samples); 

	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
			set_ambient_light(occluder_ptr);			
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-5, 2, 10);
			pinhole_ptr->set_lookat(0.35, 0.45, 0); 
			pinhole_ptr->set_view_distance(2000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 150, 200);
			light_ptr->scale_radiance(1.5);  
			light_ptr->set_shadows(true);
			//	add_light(light_ptr);						// for Figure 17.11(b)
	
	
			// cylinder
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.85);		
			matte_ptr1->set_kd(0.6);
			matte_ptr1->set_cd(1, 0.5, 0); 
	
	
			float bottom	= 0;
			float top 		= 1;
			float radius 	= 1;
			float phi_min 	= 0;
			float phi_max 	= 180;
	
			OpenPartCylinder* cylinder_ptr = new OpenPartCylinder(	bottom, 
																	top, 
																	radius, 
																	phi_min, 
																	phi_max);
			cylinder_ptr->set_material(matte_ptr1);
			add_object(cylinder_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.5);		
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(white);   
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 109:
		{
			//17.11b
			int num_samples = 256;
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
		
			MultiJittered* sampler_ptr = new MultiJittered(num_samples); 

	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
			set_ambient_light(occluder_ptr);			
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-5, 2, 10);
			pinhole_ptr->set_lookat(0.35, 0.45, 0); 
			pinhole_ptr->set_view_distance(2000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 150, 200);
			light_ptr->scale_radiance(1.5);  
			light_ptr->set_shadows(true);
			add_light(light_ptr);						// for Figure 17.11(b)
	
	
			// cylinder
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.85);		
			matte_ptr1->set_kd(0.6);
			matte_ptr1->set_cd(1, 0.5, 0); 
	
	
			float bottom	= 0;
			float top 		= 1;
			float radius 	= 1;
			float phi_min 	= 0;
			float phi_max 	= 180;
	
			OpenPartCylinder* cylinder_ptr = new OpenPartCylinder(	bottom, 
																	top, 
																	radius, 
																	phi_min, 
																	phi_max);
			cylinder_ptr->set_material(matte_ptr1);
			add_object(cylinder_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.5);		
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(white);   
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 110:
		{
			//17.12a
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny10K.ply").toLatin1().data()))
				return;

			int num_samples = 256; 
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			MultiJittered* sampler_ptr = new MultiJittered(num_samples);
	
			AmbientOccluder* acl_ptr = new AmbientOccluder;
			acl_ptr->set_min_amount(1.0);    	// for Figure 17.12(a)
		//	acl_ptr->set_min_amount(0.25);		// for Figure 17.12(b)
		//	acl_ptr->set_min_amount(0.0);		// for Figure 17.12(c)
			acl_ptr->set_sampler(sampler_ptr);
			set_ambient_light(acl_ptr);
	
			Pinhole* pinhole_ptr = new Pinhole;
	
			// for regular view	
	
			pinhole_ptr->set_eye(20, 10, 40);
			pinhole_ptr->set_lookat(-0.025, 0.11, 0.0);  
			pinhole_ptr->set_view_distance(70000);	
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(20, 40, 20);
			light_ptr1->scale_radiance(1.5); 
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);

	
			float ka = 0.5;		// used for all materials

			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(ka);		
			matte_ptr1->set_kd(0.5);
			matte_ptr1->set_cd(0.5, 0.75, 1);   // pale blue for bunny
	
		//	char* file_name = "Bunny4K.ply"; 		// 4000 triangles
		//	char* file_name = ; 	// 10000 triangles - needs the normals reversed
		//	char* file_name = "Bunny16K.ply"; 	// 16000 triangles
		//	char* file_name = "Bunny69K.ply"; 	// 69000 triangles
	
			Grid* bunny_ptr = new Grid;
			bunny_ptr->reverse_mesh_normals();				// only required for the Bunny10K.ply file
		//	bunny_ptr->read_flat_triangles(file_name);		// read PLY file
			bunny_ptr->read_smooth_triangles(QString(plyfile+"Stanford Bunny\\Bunny10K.ply").toLatin1().data());	// read PLY file
			bunny_ptr->set_material(matte_ptr1);
			bunny_ptr->setup_cells();
	
			Instance* rotated_bunny_ptr = new Instance(bunny_ptr);
			rotated_bunny_ptr->set_material(matte_ptr1);
			rotated_bunny_ptr->rotate_y(40);
			add_object(rotated_bunny_ptr);
	
	
			// rectangle parameters
	
			Point3D p0(-0.13, 0.033, -0.1);  	// common corner
			float height = 0.25;  				// y direction
			float width = 0.45;  				// x direction	
			float depth = 0.45;   				// z direction	

			// horizontal rectangle 
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(ka);		
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(white);
	
			TRectangle* rectangle_ptr1 = new TRectangle(p0, Vector3D(0, 0,depth), Vector3D(width, 0, 0));
			rectangle_ptr1->set_material(matte_ptr2);
			add_object(rectangle_ptr1);	
	
			// rectangle perpendicular to x axis
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(ka);		
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(0.5, 1, 0.75);
	
			TRectangle* rectangle_ptr2 = new TRectangle(p0, Vector3D(0, height, 0), Vector3D(0, 0, depth));
			rectangle_ptr2->set_material(matte_ptr3);
			add_object(rectangle_ptr2);	
	
			// rectangle perpendicular to w axis
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(ka);		
			matte_ptr4->set_kd(0.5);
			matte_ptr4->set_cd(1, 1, 0.5);
	
			TRectangle* rectangle_ptr3 = new TRectangle(p0, Vector3D(width, 0, 0), Vector3D(0, height, 0));
			rectangle_ptr3->set_material(matte_ptr4);
			add_object(rectangle_ptr3);
			break;
		}
	case 111:
		{
			//17.12b
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny10K.ply").toLatin1().data()))
				return;

			int num_samples = 256; 
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			MultiJittered* sampler_ptr = new MultiJittered(num_samples);
	
			AmbientOccluder* acl_ptr = new AmbientOccluder;
		//	acl_ptr->set_min_amount(1.0);    	// for Figure 17.12(a)
			acl_ptr->set_min_amount(0.25);		// for Figure 17.12(b)
		//	acl_ptr->set_min_amount(0.0);		// for Figure 17.12(c)
			acl_ptr->set_sampler(sampler_ptr);
			set_ambient_light(acl_ptr);
	
			Pinhole* pinhole_ptr = new Pinhole;
	
			// for regular view	
	
			pinhole_ptr->set_eye(20, 10, 40);
			pinhole_ptr->set_lookat(-0.025, 0.11, 0.0);  
			pinhole_ptr->set_view_distance(70000);	
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(20, 40, 20);
			light_ptr1->scale_radiance(1.5); 
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);

	
			float ka = 0.5;		// used for all materials

			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(ka);		
			matte_ptr1->set_kd(0.5);
			matte_ptr1->set_cd(0.5, 0.75, 1);   // pale blue for bunny
	
		//	char* file_name = "Bunny4K.ply"; 		// 4000 triangles
		//	char* file_name = QString(plyfile+"Stanford Bunny\\Bunny10K.ply").toLatin1().data(); 	// 10000 triangles - needs the normals reversed
		//	char* file_name = "Bunny16K.ply"; 	// 16000 triangles
		//	char* file_name = "Bunny69K.ply"; 	// 69000 triangles
	
			Grid* bunny_ptr = new Grid;
			bunny_ptr->reverse_mesh_normals();				// only required for the Bunny10K.ply file
		//	bunny_ptr->read_flat_triangles(file_name);		// read PLY file
			bunny_ptr->read_smooth_triangles(QString(plyfile+"Stanford Bunny\\Bunny10K.ply").toLatin1().data());	// read PLY file
			bunny_ptr->set_material(matte_ptr1);
			bunny_ptr->setup_cells();
	
			Instance* rotated_bunny_ptr = new Instance(bunny_ptr);
			rotated_bunny_ptr->set_material(matte_ptr1);
			rotated_bunny_ptr->rotate_y(40);
			add_object(rotated_bunny_ptr);
	
	
			// rectangle parameters
	
			Point3D p0(-0.13, 0.033, -0.1);  	// common corner
			float height = 0.25;  				// y direction
			float width = 0.45;  				// x direction	
			float depth = 0.45;   				// z direction	

			// horizontal rectangle 
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(ka);		
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(white);
	
			TRectangle* rectangle_ptr1 = new TRectangle(p0, Vector3D(0, 0,depth), Vector3D(width, 0, 0));
			rectangle_ptr1->set_material(matte_ptr2);
			add_object(rectangle_ptr1);	
	
			// rectangle perpendicular to x axis
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(ka);		
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(0.5, 1, 0.75);
	
			TRectangle* rectangle_ptr2 = new TRectangle(p0, Vector3D(0, height, 0), Vector3D(0, 0, depth));
			rectangle_ptr2->set_material(matte_ptr3);
			add_object(rectangle_ptr2);	
	
			// rectangle perpendicular to w axis
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(ka);		
			matte_ptr4->set_kd(0.5);
			matte_ptr4->set_cd(1, 1, 0.5);
	
			TRectangle* rectangle_ptr3 = new TRectangle(p0, Vector3D(width, 0, 0), Vector3D(0, height, 0));
			rectangle_ptr3->set_material(matte_ptr4);
			add_object(rectangle_ptr3);
			break;
		}
	case 112:
		{
			//17.12c
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny10K.ply").toLatin1().data()))
				return;

			int num_samples = 256; 
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			MultiJittered* sampler_ptr = new MultiJittered(num_samples);
	
			AmbientOccluder* acl_ptr = new AmbientOccluder;
		//	acl_ptr->set_min_amount(1.0);    	// for Figure 17.12(a)
		//	acl_ptr->set_min_amount(0.25);		// for Figure 17.12(b)
			acl_ptr->set_min_amount(0.0);		// for Figure 17.12(c)
			acl_ptr->set_sampler(sampler_ptr);
			set_ambient_light(acl_ptr);
	
			Pinhole* pinhole_ptr = new Pinhole;
	
			// for regular view	
	
			pinhole_ptr->set_eye(20, 10, 40);
			pinhole_ptr->set_lookat(-0.025, 0.11, 0.0);  
			pinhole_ptr->set_view_distance(70000);	
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(20, 40, 20);
			light_ptr1->scale_radiance(1.5); 
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);

	
			float ka = 0.5;		// used for all materials

			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(ka);		
			matte_ptr1->set_kd(0.5);
			matte_ptr1->set_cd(0.5, 0.75, 1);   // pale blue for bunny
	
		//	char* file_name = "Bunny4K.ply"; 		// 4000 triangles
		//	char* file_name = QString(plyfile+"Stanford Bunny\\Bunny10K.ply").toLatin1().data(); 	// 10000 triangles - needs the normals reversed
		//	char* file_name = "Bunny16K.ply"; 	// 16000 triangles
		//	char* file_name = "Bunny69K.ply"; 	// 69000 triangles
	
			Grid* bunny_ptr = new Grid;
			bunny_ptr->reverse_mesh_normals();				// only required for the Bunny10K.ply file
		//	bunny_ptr->read_flat_triangles(file_name);		// read PLY file
			bunny_ptr->read_smooth_triangles(QString(plyfile+"Stanford Bunny\\Bunny10K.ply").toLatin1().data());	// read PLY file
			bunny_ptr->set_material(matte_ptr1);
			bunny_ptr->setup_cells();
	
			Instance* rotated_bunny_ptr = new Instance(bunny_ptr);
			rotated_bunny_ptr->set_material(matte_ptr1);
			rotated_bunny_ptr->rotate_y(40);
			add_object(rotated_bunny_ptr);
	
	
			// rectangle parameters
	
			Point3D p0(-0.13, 0.033, -0.1);  	// common corner
			float height = 0.25;  				// y direction
			float width = 0.45;  				// x direction	
			float depth = 0.45;   				// z direction	

			// horizontal rectangle 
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(ka);		
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(white);
	
			TRectangle* rectangle_ptr1 = new TRectangle(p0, Vector3D(0, 0,depth), Vector3D(width, 0, 0));
			rectangle_ptr1->set_material(matte_ptr2);
			add_object(rectangle_ptr1);	
	
			// rectangle perpendicular to x axis
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(ka);		
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(0.5, 1, 0.75);
	
			TRectangle* rectangle_ptr2 = new TRectangle(p0, Vector3D(0, height, 0), Vector3D(0, 0, depth));
			rectangle_ptr2->set_material(matte_ptr3);
			add_object(rectangle_ptr2);	
	
			// rectangle perpendicular to w axis
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(ka);		
			matte_ptr4->set_kd(0.5);
			matte_ptr4->set_cd(1, 1, 0.5);
	
			TRectangle* rectangle_ptr3 = new TRectangle(p0, Vector3D(width, 0, 0), Vector3D(0, height, 0));
			rectangle_ptr3->set_material(matte_ptr4);
			add_object(rectangle_ptr3);
			break;
		}
	case 113:
		{
			//17.13a
			int num_samples = 64;
	
			vp.set_hres(600);			
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);	
	
			AmbientOccluder* ambient_occluder_ptr = new AmbientOccluder;
			ambient_occluder_ptr->set_sampler(new MultiJittered(num_samples));
			ambient_occluder_ptr->set_min_amount(1.0);   	// for Figure 17.13(a)
		//	ambient_occluder_ptr->set_min_amount(0.25);		// for Figure 17.13(b)
			set_ambient_light(ambient_occluder_ptr);
	
	
			Orthographic* orthographic_ptr = new Orthographic;
			vp.set_pixel_size(0.31);	
			orthographic_ptr->set_eye(100, 100, 50);  
			orthographic_ptr->set_lookat(0, 10, 0);
			orthographic_ptr->compute_uvw(); 
			set_camera(orthographic_ptr);

	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(150, 500, 300); 
			light_ptr->scale_radiance(3.75);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// city parameters
	
			float 	a					= 10;   // city block width:  xw extent
			float 	b   				= 12;	// city block length:  yw extent
			int 	num_rows			= 10;  	// number of blocks in the xw direction
			int 	num_columns			= 12; 	// number of blocks in the zw direction
			float	width				= 7;	// building width: xw extent in range [min, a - offset]
			float 	length				= 7;	// building length: zw extent in range [min, b - offset]
			float 	min_size			= 6;	// mininum building extent in xw and yw directions
			float 	offset				= 1.0;	// half the minimum distance between buildings
			float 	min_height			= 0.0; 	// minimum building height
			float 	max_height			= 30; 	// maximum bulding height
			float 	height;						// the building height in range [min_height, max_height]
			int		num_park_rows		= 4;  	// number of blocks of park in xw direction
			int		num_park_columns	= 6;  	// number of blocks of park in xw direction
			int 	row_test;					// there are no buildings in the park
			int 	column_test;				// there are no buildings in the park
			float 	min_color			= 0.1;  // prevents black buildings
			float 	max_color			= 0.9;	// prevents white buildings
		
			set_rand_seed(15);  				// as the buildings' dimensions and colors are random, it's necessary to 
												// seed rand to keep these quantities the same at each run
												// if you leave this out, and change the number of samples per pixel,
												// these will change
	
			// the buildings are stored in a grid
	
			Grid* grid_ptr = new Grid;
	
			for (int r = 0; r < num_rows; r++)  			// xw direction
				for (int c = 0; c < num_columns; c++) {		// zw direction
					// determine if the block is in the park
		
					if ((r - num_rows / 2) >= 0)
						row_test = r -  num_rows / 2;
					else
						row_test = r -  num_rows / 2 + 1;
				
					if ((c - num_columns / 2) >= 0)
						column_test = c - num_columns / 2;
					else
						column_test = c - num_columns / 2 + 1;
			
					if (abs(row_test) >= (num_park_rows / 2) || abs(column_test) >= (num_park_columns / 2)) {
		
						Matte* matte_ptr = new Matte;
						matte_ptr->set_ka(0.4); 
						matte_ptr->set_kd(0.6);			
						matte_ptr->set_cd(	min_color + rand_float() * (max_color - min_color), 
											min_color + rand_float() * (max_color - min_color), 
											min_color + rand_float() * (max_color - min_color));    
			
						// block center coordinates
				
						float xc = a * (r - num_rows / 2.0 + 0.5);
						float zc = b * (c - num_columns / 2.0 + 0.5);
				
						width = min_size + rand_float() * (a - 2 * offset - min_size);
						length = min_size + rand_float() * (b - 2 * offset - min_size);	
				
						// minimum building coordinates
				
						float xmin = xc - width / 2.0;
						float ymin = 0.0;
						float zmin = zc - length / 2.0;
				
						// maximum building coordinates
				
						height = min_height + rand_float() * (max_height - min_height);
				
						// The following is a hack to make the middle row and column of buildings higher
						// on average than the other buildings. 
						// This only works properly when there are three rows and columns of buildings
				
						if (r == 1 || r == num_rows - 2 || c == 1 || c == num_columns - 2)
							height *= 1.5;
				
						float xmax = xc + width / 2.0;
						float ymax = height;
						float zmax = zc + length / 2.0;
				
						Box* building_ptr = new  Box(Point3D(xmin, ymin, zmin), Point3D(xmax, ymax, zmax));
						building_ptr->set_material(matte_ptr);
						grid_ptr->add_object(building_ptr);
					}
				}
		
			grid_ptr->setup_cells();
			add_object(grid_ptr);
		
			// render the park green
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.4); 
			matte_ptr1->set_kd(0.5);
			matte_ptr1->set_cd(0.3, 0.5, 0.3);     // green 
											
			Box* park_ptr = new Box( 	Point3D(-a * num_park_rows / 2, 0.0, -b * num_park_columns / 2), 
										Point3D(a * num_park_rows / 2, 0.1, b * num_park_columns / 2)  );										
			park_ptr->set_material(matte_ptr1);
			add_object(park_ptr);
					
	
			// ground plane 
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.3); 
			matte_ptr2->set_kd(0.5); 
			matte_ptr2->set_cd(0.85); 
		
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);
			break;
		}
	case 114:
		{
			//17.13b
			int num_samples = 64;
	
			vp.set_hres(600);			
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);	
	
			AmbientOccluder* ambient_occluder_ptr = new AmbientOccluder;
			ambient_occluder_ptr->set_sampler(new MultiJittered(num_samples));
		//	ambient_occluder_ptr->set_min_amount(1.0);   	// for Figure 17.13(a)
			ambient_occluder_ptr->set_min_amount(0.25);		// for Figure 17.13(b)
			set_ambient_light(ambient_occluder_ptr);
	
	
			Orthographic* orthographic_ptr = new Orthographic;
			vp.set_pixel_size(0.31);	
			orthographic_ptr->set_eye(100, 100, 50);  
			orthographic_ptr->set_lookat(0, 10, 0);
			orthographic_ptr->compute_uvw(); 
			set_camera(orthographic_ptr);

	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(150, 500, 300); 
			light_ptr->scale_radiance(3.75);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// city parameters
	
			float 	a					= 10;   // city block width:  xw extent
			float 	b   				= 12;	// city block length:  yw extent
			int 	num_rows			= 10;  	// number of blocks in the xw direction
			int 	num_columns			= 12; 	// number of blocks in the zw direction
			float	width				= 7;	// building width: xw extent in range [min, a - offset]
			float 	length				= 7;	// building length: zw extent in range [min, b - offset]
			float 	min_size			= 6;	// mininum building extent in xw and yw directions
			float 	offset				= 1.0;	// half the minimum distance between buildings
			float 	min_height			= 0.0; 	// minimum building height
			float 	max_height			= 30; 	// maximum bulding height
			float 	height;						// the building height in range [min_height, max_height]
			int		num_park_rows		= 4;  	// number of blocks of park in xw direction
			int		num_park_columns	= 6;  	// number of blocks of park in xw direction
			int 	row_test;					// there are no buildings in the park
			int 	column_test;				// there are no buildings in the park
			float 	min_color			= 0.1;  // prevents black buildings
			float 	max_color			= 0.9;	// prevents white buildings
		
			set_rand_seed(15);  				// as the buildings' dimensions and colors are random, it's necessary to 
												// seed rand to keep these quantities the same at each run
												// if you leave this out, and change the number of samples per pixel,
												// these will change
	
			// the buildings are stored in a grid
	
			Grid* grid_ptr = new Grid;
	
			for (int r = 0; r < num_rows; r++)  			// xw direction
				for (int c = 0; c < num_columns; c++) {		// zw direction
					// determine if the block is in the park
		
					if ((r - num_rows / 2) >= 0)
						row_test = r -  num_rows / 2;
					else
						row_test = r -  num_rows / 2 + 1;
				
					if ((c - num_columns / 2) >= 0)
						column_test = c - num_columns / 2;
					else
						column_test = c - num_columns / 2 + 1;
			
					if (abs(row_test) >= (num_park_rows / 2) || abs(column_test) >= (num_park_columns / 2)) {
		
						Matte* matte_ptr = new Matte;
						matte_ptr->set_ka(0.4); 
						matte_ptr->set_kd(0.6);			
						matte_ptr->set_cd(	min_color + rand_float() * (max_color - min_color), 
											min_color + rand_float() * (max_color - min_color), 
											min_color + rand_float() * (max_color - min_color));    
			
						// block center coordinates
				
						float xc = a * (r - num_rows / 2.0 + 0.5);
						float zc = b * (c - num_columns / 2.0 + 0.5);
				
						width = min_size + rand_float() * (a - 2 * offset - min_size);
						length = min_size + rand_float() * (b - 2 * offset - min_size);	
				
						// minimum building coordinates
				
						float xmin = xc - width / 2.0;
						float ymin = 0.0;
						float zmin = zc - length / 2.0;
				
						// maximum building coordinates
				
						height = min_height + rand_float() * (max_height - min_height);
				
						// The following is a hack to make the middle row and column of buildings higher
						// on average than the other buildings. 
						// This only works properly when there are three rows and columns of buildings
				
						if (r == 1 || r == num_rows - 2 || c == 1 || c == num_columns - 2)
							height *= 1.5;
				
						float xmax = xc + width / 2.0;
						float ymax = height;
						float zmax = zc + length / 2.0;
				
						Box* building_ptr = new  Box(Point3D(xmin, ymin, zmin), Point3D(xmax, ymax, zmax));
						building_ptr->set_material(matte_ptr);
						grid_ptr->add_object(building_ptr);
					}
				}
		
			grid_ptr->setup_cells();
			add_object(grid_ptr);
		
			// render the park green
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.4); 
			matte_ptr1->set_kd(0.5);
			matte_ptr1->set_cd(0.3, 0.5, 0.3);     // green 
											
			Box* park_ptr = new Box( 	Point3D(-a * num_park_rows / 2, 0.0, -b * num_park_columns / 2), 
										Point3D(a * num_park_rows / 2, 0.1, b * num_park_columns / 2)  );										
			park_ptr->set_material(matte_ptr1);
			add_object(park_ptr);
					
	
			// ground plane 
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.3); 
			matte_ptr2->set_kd(0.5); 
			matte_ptr2->set_cd(0.85); 
		
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);
			break;
		}
	case 115:
		{
			//17.14
			int num_samples = 256;
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);  
	
			tracer_ptr = new RayCast(this);
		
			MultiJittered* sampler_ptr = new MultiJittered(num_samples); 

	
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->scale_radiance(1.0);
			occluder_ptr->set_min_amount(0.0);
			occluder_ptr->set_sampler(sampler_ptr);
			set_ambient_light(occluder_ptr);			
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-10, 2, 0);
			pinhole_ptr->set_lookat(0.35, 0.45, 0); 
			pinhole_ptr->set_view_distance(1500);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// cylinder
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.85);		
			matte_ptr1->set_kd(0.6);
			matte_ptr1->set_cd(1, 0.5, 0); 
	
	
			float bottom	= 0;
			float top 		= 1;
			float radius 	= 1;
			float phi_min 	= 0;
			float phi_max 	= 180;
	
			OpenPartCylinder* cylinder_ptr = new OpenPartCylinder(	bottom, 
																	top, 
																	radius, 
																	phi_min, 
																	phi_max);
			cylinder_ptr->set_material(matte_ptr1);
			add_object(cylinder_ptr);	
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.5);		
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(white);   
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 116:
		{
			//18p1
			int num_samples = 256;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_max_depth(0);
		
			tracer_ptr = new AreaLighting(this);	
		
			AmbientOccluder* ambient_occluder_ptr = new AmbientOccluder;
			ambient_occluder_ptr->set_sampler(new MultiJittered(num_samples));
			ambient_occluder_ptr->set_min_amount(0.5);
			set_ambient_light(ambient_occluder_ptr);

			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 45, 100);  
			pinhole_ptr->set_lookat(-10, 40, 0);   
			pinhole_ptr->set_view_distance(400);   
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
		
			JitteredDirectional* light_ptr = new JitteredDirectional;
			light_ptr->set_direction(150, 50, -50);   
			light_ptr->set_color(1.0, 0.25, 0.0);  // orange
			light_ptr->set_jitter_amount(0.2);
			light_ptr->scale_radiance(4.0);       
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(1.0, 1.0, 0.5); 	// lemon
			emissive_ptr->scale_radiance(0.9);
	
			ConcaveHemisphere* hemisphere_ptr = new ConcaveHemisphere;
			hemisphere_ptr->set_radius(1000000.0);
			hemisphere_ptr->set_material(emissive_ptr);
			hemisphere_ptr->set_shadows(false);
			add_object(hemisphere_ptr);
	
			EnvironmentLight* environmentLight_ptr = new EnvironmentLight;
			environmentLight_ptr->set_material(emissive_ptr);
			environmentLight_ptr->set_sampler(new MultiJittered(num_samples));
			environmentLight_ptr->set_shadows(true);
			add_light(environmentLight_ptr);
	
	
			float ka = 0.2;  // commom ambient reflection coefficient
	
			// large sphere
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(ka); 
			matte_ptr1->set_kd(0.60);
			matte_ptr1->set_cd(0.75);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, 20, -24), 20);
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
	
			// small sphere
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(ka); 
			matte_ptr2->set_kd(0.4);
			matte_ptr2->set_cd(0.25, 1.0, 0.35);       // green
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(34, 12, 13), 12);
			sphere_ptr2->set_material(matte_ptr2);
			add_object(sphere_ptr2);
	
	
			// medium sphere
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(ka); 
			matte_ptr3->set_kd(0.5);
			matte_ptr3->set_cd(0.75);
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(-7, 15, 42), 16);
			sphere_ptr3->set_material(matte_ptr3);
			add_object(sphere_ptr3);

	
			// cylinder
	
			Phong* phong_ptr = new Phong;			
			phong_ptr->set_ka(ka); 
			phong_ptr->set_kd(0.25);
			phong_ptr->set_cd(0.60);
			phong_ptr->set_ks(0.5);
			phong_ptr->set_exp(100);
	
			float bottom 	= 0.0;
			float top 		= 85; 
			float radius	= 22;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(phong_ptr);
			add_object(cylinder_ptr);

	
			// box
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(ka); 
			matte_ptr4->set_kd(0.5);
			matte_ptr4->set_cd(0.95);
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(matte_ptr4);
			add_object(box_ptr);
	

			// ground plane 
		
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(0.15); 
			matte_ptr5->set_kd(0.5);	
			matte_ptr5->set_cd(0.7);    
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr5);
			add_object(plane_ptr);
			break;
		}
	case 117:
		{
			//18.04a
			int num_samples = 1;   		// for Figure 18.4(a)
		//	int num_samples = 100;   	// for Figure 18.4(b) & (c)
	
			Sampler* sampler_ptr = new MultiJittered(num_samples);

			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_sampler(sampler_ptr);	

			background_color = RGBColour(0.5);

			tracer_ptr = new AreaLighting(this);

			Pinhole* camera = new Pinhole;
			camera->set_eye(-20, 10, 20);
			camera->set_lookat(0, 2, 0); 	
			camera->set_view_distance(1080);          
			camera->compute_uvw();     
			set_camera(camera); 

	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(40.0);
			emissive_ptr->set_ce(white);
	
	
			// define a rectangle for the rectangular light
	
			float width = 4.0;				// for Figure 18.4(a) & (b)
			float height = 4.0;
		//	float width = 2.0;				// for Figure 18.4(c)
		//	float height = 2.0;
			Point3D center(0.0, 7.0, -7.0);	// center of each area light (rectangular, disk, and spherical)
			Point3D p0(-0.5 * width, center.y - 0.5 * height, center.z);
			Vector3D a(width, 0.0, 0.0);
			Vector3D b(0.0, height, 0.0);
			Normal normal(0, 0, 1);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b, normal);
			rectangle_ptr->set_material(emissive_ptr);
			rectangle_ptr->set_sampler(sampler_ptr);
			rectangle_ptr->set_shadows(false);
			add_object(rectangle_ptr);

	
			AreaLight* area_light_ptr = new AreaLight;
			area_light_ptr->set_object(rectangle_ptr);
			area_light_ptr->set_shadows(true);
			add_light(area_light_ptr);
	
	
			// Four axis aligned boxes
		
			float box_width 	= 1.0; 		// x dimension
			float box_depth 	= 1.0; 		// z dimension
			float box_height 	= 4.5; 		// y dimension
			float gap			= 3.0; 
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.25); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.4, 0.7, 0.4);     // green
	
			Box* box_ptr0 = new Box(Point3D(- 1.5 * gap - 2.0 * box_width, 0.0, -0.5 * box_depth), 
									Point3D(-1.5 * gap  - box_width, box_height, 0.5 * box_depth)); 
			box_ptr0->set_material(matte_ptr1);
			add_object(box_ptr0);
	
			Box* box_ptr1 = new Box(Point3D(- 0.5 * gap - box_width, 0.0, -0.5 * box_depth), 
									Point3D(-0.5 * gap, box_height, 0.5 * box_depth)); 
			box_ptr1->set_material(matte_ptr1);
			add_object(box_ptr1);
		
			Box* box_ptr2 = new Box(Point3D(0.5 * gap, 0.0, -0.5 * box_depth), 
									Point3D(0.5 * gap + box_width, box_height, 0.5 * box_depth));
			box_ptr2->set_material(matte_ptr1);
			add_object(box_ptr2);
	
			Box* box_ptr3 = new Box(Point3D(1.5 * gap + box_width, 0.0, -0.5 * box_depth), 
									Point3D(1.5 * gap + 2.0 * box_width, box_height, 0.5 * box_depth));
			box_ptr3->set_material(matte_ptr1);
			add_object(box_ptr3);

		
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.1); 
			matte_ptr2->set_kd(0.90);
			matte_ptr2->set_cd(white);
		
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0)); 
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 118:
		{
			//18.04b
		//	int num_samples = 1;   		// for Figure 18.4(a)
			int num_samples = 100;   	// for Figure 18.4(b) & (c)
	
			Sampler* sampler_ptr = new MultiJittered(num_samples);

			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_sampler(sampler_ptr);	

			background_color = RGBColour(0.5);

			tracer_ptr = new AreaLighting(this);

			Pinhole* camera = new Pinhole;
			camera->set_eye(-20, 10, 20);
			camera->set_lookat(0, 2, 0); 	
			camera->set_view_distance(1080);          
			camera->compute_uvw();     
			set_camera(camera); 

	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(40.0);
			emissive_ptr->set_ce(white);
	
	
			// define a rectangle for the rectangular light
	
			float width = 4.0;				// for Figure 18.4(a) & (b)
			float height = 4.0;
		//	float width = 2.0;				// for Figure 18.4(c)
		//	float height = 2.0;
			Point3D center(0.0, 7.0, -7.0);	// center of each area light (rectangular, disk, and spherical)
			Point3D p0(-0.5 * width, center.y - 0.5 * height, center.z);
			Vector3D a(width, 0.0, 0.0);
			Vector3D b(0.0, height, 0.0);
			Normal normal(0, 0, 1);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b, normal);
			rectangle_ptr->set_material(emissive_ptr);
			rectangle_ptr->set_sampler(sampler_ptr);
			rectangle_ptr->set_shadows(false);
			add_object(rectangle_ptr);

	
			AreaLight* area_light_ptr = new AreaLight;
			area_light_ptr->set_object(rectangle_ptr);
			area_light_ptr->set_shadows(true);
			add_light(area_light_ptr);
	
	
			// Four axis aligned boxes
		
			float box_width 	= 1.0; 		// x dimension
			float box_depth 	= 1.0; 		// z dimension
			float box_height 	= 4.5; 		// y dimension
			float gap			= 3.0; 
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.25); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.4, 0.7, 0.4);     // green
	
			Box* box_ptr0 = new Box(Point3D(- 1.5 * gap - 2.0 * box_width, 0.0, -0.5 * box_depth), 
									Point3D(-1.5 * gap  - box_width, box_height, 0.5 * box_depth)); 
			box_ptr0->set_material(matte_ptr1);
			add_object(box_ptr0);
	
			Box* box_ptr1 = new Box(Point3D(- 0.5 * gap - box_width, 0.0, -0.5 * box_depth), 
									Point3D(-0.5 * gap, box_height, 0.5 * box_depth)); 
			box_ptr1->set_material(matte_ptr1);
			add_object(box_ptr1);
		
			Box* box_ptr2 = new Box(Point3D(0.5 * gap, 0.0, -0.5 * box_depth), 
									Point3D(0.5 * gap + box_width, box_height, 0.5 * box_depth));
			box_ptr2->set_material(matte_ptr1);
			add_object(box_ptr2);
	
			Box* box_ptr3 = new Box(Point3D(1.5 * gap + box_width, 0.0, -0.5 * box_depth), 
									Point3D(1.5 * gap + 2.0 * box_width, box_height, 0.5 * box_depth));
			box_ptr3->set_material(matte_ptr1);
			add_object(box_ptr3);

		
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.1); 
			matte_ptr2->set_kd(0.90);
			matte_ptr2->set_cd(white);
		
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0)); 
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 119:
		{
			//18.04c
		//	int num_samples = 1;   		// for Figure 18.4(a)
			int num_samples = 100;   	// for Figure 18.4(b) & (c)
	
			Sampler* sampler_ptr = new MultiJittered(num_samples);

			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_sampler(sampler_ptr);	

			background_color = RGBColour(0.5);

			tracer_ptr = new AreaLighting(this);

			Pinhole* camera = new Pinhole;
			camera->set_eye(-20, 10, 20);
			camera->set_lookat(0, 2, 0); 	
			camera->set_view_distance(1080);          
			camera->compute_uvw();     
			set_camera(camera); 

	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(40.0);
			emissive_ptr->set_ce(white);
	
	
			// define a rectangle for the rectangular light
	
		//	float width = 4.0;				// for Figure 18.4(a) & (b)
		//	float height = 4.0;
			float width = 2.0;				// for Figure 18.4(c)
			float height = 2.0;
			Point3D center(0.0, 7.0, -7.0);	// center of each area light (rectangular, disk, and spherical)
			Point3D p0(-0.5 * width, center.y - 0.5 * height, center.z);
			Vector3D a(width, 0.0, 0.0);
			Vector3D b(0.0, height, 0.0);
			Normal normal(0, 0, 1);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b, normal);
			rectangle_ptr->set_material(emissive_ptr);
			rectangle_ptr->set_sampler(sampler_ptr);
			rectangle_ptr->set_shadows(false);
			add_object(rectangle_ptr);

	
			AreaLight* area_light_ptr = new AreaLight;
			area_light_ptr->set_object(rectangle_ptr);
			area_light_ptr->set_shadows(true);
			add_light(area_light_ptr);
	
	
			// Four axis aligned boxes
		
			float box_width 	= 1.0; 		// x dimension
			float box_depth 	= 1.0; 		// z dimension
			float box_height 	= 4.5; 		// y dimension
			float gap			= 3.0; 
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.25); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.4, 0.7, 0.4);     // green
	
			Box* box_ptr0 = new Box(Point3D(- 1.5 * gap - 2.0 * box_width, 0.0, -0.5 * box_depth), 
									Point3D(-1.5 * gap  - box_width, box_height, 0.5 * box_depth)); 
			box_ptr0->set_material(matte_ptr1);
			add_object(box_ptr0);
	
			Box* box_ptr1 = new Box(Point3D(- 0.5 * gap - box_width, 0.0, -0.5 * box_depth), 
									Point3D(-0.5 * gap, box_height, 0.5 * box_depth)); 
			box_ptr1->set_material(matte_ptr1);
			add_object(box_ptr1);
		
			Box* box_ptr2 = new Box(Point3D(0.5 * gap, 0.0, -0.5 * box_depth), 
									Point3D(0.5 * gap + box_width, box_height, 0.5 * box_depth));
			box_ptr2->set_material(matte_ptr1);
			add_object(box_ptr2);
	
			Box* box_ptr3 = new Box(Point3D(1.5 * gap + box_width, 0.0, -0.5 * box_depth), 
									Point3D(1.5 * gap + 2.0 * box_width, box_height, 0.5 * box_depth));
			box_ptr3->set_material(matte_ptr1);
			add_object(box_ptr3);

		
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.1); 
			matte_ptr2->set_kd(0.90);
			matte_ptr2->set_cd(white);
		
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0)); 
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 120:
		{
			//18.05a
			int num_samples = 100;   
	
			Sampler* sampler_ptr = new MultiJittered(num_samples);

			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_max_depth(0);
			vp.set_sampler(sampler_ptr);	

			background_color = RGBColour(0.5);

			tracer_ptr = new AreaLighting(this);

			Pinhole* camera = new Pinhole;
			camera->set_eye(-20, 10, 20);
			camera->set_lookat(0, 2, 0); 	
			camera->set_view_distance(1080);          
			camera->compute_uvw();     
			set_camera(camera); 

	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(40.0);
			emissive_ptr->set_ce(white);
	
	
			// disk for the disk light
	
			Point3D center(0.0, 7.0, -7.0);
			float width = 4.0;
			float radius = 0.56 * width;
			Normal normal(0, 0, 1);
		
	
			Disk* disk_ptr = new Disk(center, normal, radius);
			disk_ptr->set_material(emissive_ptr);
			disk_ptr->set_sampler(sampler_ptr);
			disk_ptr->set_shadows(false);
			disk_ptr->compute_uvw();
			add_object(disk_ptr);
	
		
			AreaLight* area_light_ptr = new AreaLight;
			area_light_ptr->set_object(disk_ptr);
			area_light_ptr->set_shadows(true);
			add_light(area_light_ptr);
	
	
			// Four axis aligned boxes
		
			float box_width 	= 1.0; 		// x dimension
			float box_depth 	= 1.0; 		// z dimension
			float box_height 	= 4.5; 		// y dimension
			float gap			= 3.0; 
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.25); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.4, 0.7, 0.4);     // green
	
			Box* box_ptr0 = new Box(Point3D(- 1.5 * gap - 2.0 * box_width, 0.0, -0.5 * box_depth), 
									Point3D(-1.5 * gap  - box_width, box_height, 0.5 * box_depth)); 
			box_ptr0->set_material(matte_ptr1);
			add_object(box_ptr0);
	
			Box* box_ptr1 = new Box(Point3D(- 0.5 * gap - box_width, 0.0, -0.5 * box_depth), 
									Point3D(-0.5 * gap, box_height, 0.5 * box_depth)); 
			box_ptr1->set_material(matte_ptr1);
			add_object(box_ptr1);
		
			Box* box_ptr2 = new Box(Point3D(0.5 * gap, 0.0, -0.5 * box_depth), 
									Point3D(0.5 * gap + box_width, box_height, 0.5 * box_depth));
			box_ptr2->set_material(matte_ptr1);
			add_object(box_ptr2);
	
			Box* box_ptr3 = new Box(Point3D(1.5 * gap + box_width, 0.0, -0.5 * box_depth), 
									Point3D(1.5 * gap + 2.0 * box_width, box_height, 0.5 * box_depth));
			box_ptr3->set_material(matte_ptr1);
			add_object(box_ptr3);

		
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.1); 
			matte_ptr2->set_kd(0.90);
			matte_ptr2->set_cd(white);
		
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0)); 
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 121:
		{
			//18.05b
			int num_samples = 100;  
	
			Sampler* sampler_ptr = new MultiJittered(num_samples);

			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_max_depth(0);
			vp.set_sampler(sampler_ptr);	

			background_color = RGBColour(0.5);

			tracer_ptr = new AreaLighting(this);

			Pinhole* camera = new Pinhole;
			camera->set_eye(-20, 10, 20);
			camera->set_lookat(0, 2, 0); 	
			camera->set_view_distance(1080);          
			camera->compute_uvw();     
			set_camera(camera); 

	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(20.0);   
			emissive_ptr->set_ce(white);
	

			// sphere for a spherical light
			// the center and radius are the same as for the disk

			float width = 4.0;
			float radius = 0.56 * width; 
			Point3D center(0.0, 7.0, -7.0);

			Sphere* sphere_ptr = new Sphere(center, radius);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_sampler(sampler_ptr);
			sphere_ptr->set_shadows(false);

			add_object(sphere_ptr);
	
			AreaLight* area_light_ptr = new AreaLight;
			area_light_ptr->set_object(sphere_ptr);
			area_light_ptr->set_shadows(true);
			add_light(area_light_ptr);
	
			// Four axis aligned boxes
		
			float box_width 	= 1.0; 		// x dimension
			float box_depth 	= 1.0; 		// z dimension
			float box_height 	= 4.5; 		// y dimension
			float gap			= 3.0; 
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.25); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.4, 0.7, 0.4);     // green
	
			Box* box_ptr0 = new Box(Point3D(- 1.5 * gap - 2.0 * box_width, 0.0, -0.5 * box_depth), 
									Point3D(-1.5 * gap  - box_width, box_height, 0.5 * box_depth)); 
			box_ptr0->set_material(matte_ptr1);
			add_object(box_ptr0);
	
			Box* box_ptr1 = new Box(Point3D(- 0.5 * gap - box_width, 0.0, -0.5 * box_depth), 
									Point3D(-0.5 * gap, box_height, 0.5 * box_depth)); 
			box_ptr1->set_material(matte_ptr1);
			add_object(box_ptr1);
		
			Box* box_ptr2 = new Box(Point3D(0.5 * gap, 0.0, -0.5 * box_depth), 
									Point3D(0.5 * gap + box_width, box_height, 0.5 * box_depth));
			box_ptr2->set_material(matte_ptr1);
			add_object(box_ptr2);
	
			Box* box_ptr3 = new Box(Point3D(1.5 * gap + box_width, 0.0, -0.5 * box_depth), 
									Point3D(1.5 * gap + 2.0 * box_width, box_height, 0.5 * box_depth));
			box_ptr3->set_material(matte_ptr1);
			add_object(box_ptr3);

		
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.1); 
			matte_ptr2->set_kd(0.90);
			matte_ptr2->set_cd(white);
		
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0)); 
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 122:
		{
			//18.06a
			int num_samples = 100;   
	
			Sampler* sampler_ptr = new MultiJittered(num_samples);

			vp.set_hres(600);
			vp.set_vres(600);
		//	vp.set_gamut_display(true);    // for Figure 18.6(b)
			vp.set_sampler(sampler_ptr);	

			background_color = RGBColour(0.5);

			tracer_ptr = new AreaLighting(this);

			Pinhole* camera = new Pinhole;
			camera->set_eye(-20, 10, 20);
			camera->set_lookat(0, 2, 0); 	
			camera->set_view_distance(1080);          
			camera->compute_uvw();     
			set_camera(camera); 

	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(40.0);
			emissive_ptr->set_ce(white);
	
	
			// define a rectangle for the rectangular light
	
			float width = 4.0;	
			float height = 4.0;
			Point3D center(0.0, 2.0, -7.0);  // rectangle just touches the plane   
			Point3D p0(-0.5 * width, center.y - 0.5 * height, center.z);
			Vector3D a(width, 0.0, 0.0);
			Vector3D b(0.0, height, 0.0);
			Normal normal(0, 0, 1);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b, normal);
			rectangle_ptr->set_material(emissive_ptr);
			rectangle_ptr->set_sampler(sampler_ptr);
			rectangle_ptr->set_shadows(false);
			add_object(rectangle_ptr);
	
	
			AreaLight* area_light_ptr = new AreaLight;
			area_light_ptr->set_object(rectangle_ptr);
			area_light_ptr->set_shadows(true);
			add_light(area_light_ptr);
	
	
			// Four axis aligned boxes
		
			float box_width 	= 1.0; 		// x dimension
			float box_depth 	= 1.0; 		// z dimension
			float box_height 	= 4.5; 		// y dimension
			float gap			= 3.0; 
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.25); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.4, 0.7, 0.4);     // green
	
			Box* box_ptr0 = new Box(Point3D(- 1.5 * gap - 2.0 * box_width, 0.0, -0.5 * box_depth), 
									Point3D(-1.5 * gap  - box_width, box_height, 0.5 * box_depth)); 
			box_ptr0->set_material(matte_ptr1);
			add_object(box_ptr0);
	
			Box* box_ptr1 = new Box(Point3D(- 0.5 * gap - box_width, 0.0, -0.5 * box_depth), 
									Point3D(-0.5 * gap, box_height, 0.5 * box_depth)); 
			box_ptr1->set_material(matte_ptr1);
			add_object(box_ptr1);
		
			Box* box_ptr2 = new Box(Point3D(0.5 * gap, 0.0, -0.5 * box_depth), 
									Point3D(0.5 * gap + box_width, box_height, 0.5 * box_depth));
			box_ptr2->set_material(matte_ptr1);
			add_object(box_ptr2);
	
			Box* box_ptr3 = new Box(Point3D(1.5 * gap + box_width, 0.0, -0.5 * box_depth), 
									Point3D(1.5 * gap + 2.0 * box_width, box_height, 0.5 * box_depth));
			box_ptr3->set_material(matte_ptr1);
			add_object(box_ptr3);

		
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.1); 
			matte_ptr2->set_kd(0.90);
			matte_ptr2->set_cd(white);
		
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0)); 
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 123:
		{
			//18.06b
			int num_samples = 100;   
	
			Sampler* sampler_ptr = new MultiJittered(num_samples);

			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_gamut_display(true);    // for Figure 18.6(b)
			vp.set_sampler(sampler_ptr);	

			background_color = RGBColour(0.5);

			tracer_ptr = new AreaLighting(this);

			Pinhole* camera = new Pinhole;
			camera->set_eye(-20, 10, 20);
			camera->set_lookat(0, 2, 0); 	
			camera->set_view_distance(1080);          
			camera->compute_uvw();     
			set_camera(camera); 

	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(40.0);
			emissive_ptr->set_ce(white);
	
	
			// define a rectangle for the rectangular light
	
			float width = 4.0;	
			float height = 4.0;
			Point3D center(0.0, 2.0, -7.0);  // rectangle just touches the plane   
			Point3D p0(-0.5 * width, center.y - 0.5 * height, center.z);
			Vector3D a(width, 0.0, 0.0);
			Vector3D b(0.0, height, 0.0);
			Normal normal(0, 0, 1);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b, normal);
			rectangle_ptr->set_material(emissive_ptr);
			rectangle_ptr->set_sampler(sampler_ptr);
			rectangle_ptr->set_shadows(false);
			add_object(rectangle_ptr);
	
	
			AreaLight* area_light_ptr = new AreaLight;
			area_light_ptr->set_object(rectangle_ptr);
			area_light_ptr->set_shadows(true);
			add_light(area_light_ptr);
	
	
			// Four axis aligned boxes
		
			float box_width 	= 1.0; 		// x dimension
			float box_depth 	= 1.0; 		// z dimension
			float box_height 	= 4.5; 		// y dimension
			float gap			= 3.0; 
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.25); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.4, 0.7, 0.4);     // green
	
			Box* box_ptr0 = new Box(Point3D(- 1.5 * gap - 2.0 * box_width, 0.0, -0.5 * box_depth), 
									Point3D(-1.5 * gap  - box_width, box_height, 0.5 * box_depth)); 
			box_ptr0->set_material(matte_ptr1);
			add_object(box_ptr0);
	
			Box* box_ptr1 = new Box(Point3D(- 0.5 * gap - box_width, 0.0, -0.5 * box_depth), 
									Point3D(-0.5 * gap, box_height, 0.5 * box_depth)); 
			box_ptr1->set_material(matte_ptr1);
			add_object(box_ptr1);
		
			Box* box_ptr2 = new Box(Point3D(0.5 * gap, 0.0, -0.5 * box_depth), 
									Point3D(0.5 * gap + box_width, box_height, 0.5 * box_depth));
			box_ptr2->set_material(matte_ptr1);
			add_object(box_ptr2);
	
			Box* box_ptr3 = new Box(Point3D(1.5 * gap + box_width, 0.0, -0.5 * box_depth), 
									Point3D(1.5 * gap + 2.0 * box_width, box_height, 0.5 * box_depth));
			box_ptr3->set_material(matte_ptr1);
			add_object(box_ptr3);

		
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.1); 
			matte_ptr2->set_kd(0.90);
			matte_ptr2->set_cd(white);
		
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0)); 
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 124:
		{
			//18.07a
			int num_samples = 100;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
		
			tracer_ptr = new AreaLighting(this);	
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.0);
		//	set_ambient_light(ambient_ptr);				// for Figure 18.7(b)
		
			AmbientOccluder* ambient_occluder_ptr = new AmbientOccluder;
			ambient_occluder_ptr->set_sampler(new MultiJittered(num_samples));
			ambient_occluder_ptr->set_min_amount(0.5);
			set_ambient_light(ambient_occluder_ptr);	// for Figure 18.7 (a) & (c)

			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 45, 100);  
			pinhole_ptr->set_lookat(-10, 40, 0);  
			pinhole_ptr->set_view_distance(400);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(0.90);
			emissive_ptr->set_ce(1.0);   			// white
		
			ConcaveSphere* sphere_ptr = new ConcaveSphere;
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_shadows(false);
			add_object(sphere_ptr);
	
			EnvironmentLight* environment_light_ptr = new EnvironmentLight;
			environment_light_ptr->set_material(emissive_ptr);
			environment_light_ptr->set_sampler(new MultiJittered(num_samples));
			environment_light_ptr->set_shadows(true);
		//	add_light(environment_light_ptr);			// for Figure 18.7 (b) & (c)
		
	
			float ka = 0.2;  	// common ambient reflection coefficient
	
			// large sphere
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(ka); 
			matte_ptr1->set_kd(0.60);
			matte_ptr1->set_cd(0.75);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, 20, -24), 20);
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
	
			// small sphere
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(ka); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.85);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(34, 12, 13), 12);
			sphere_ptr2->set_material(matte_ptr2);
			add_object(sphere_ptr2);
	
	
			// medium sphere
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(ka); 
			matte_ptr3->set_kd(0.5);
			matte_ptr3->set_cd(0.75);
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(-7, 15, 42), 16);
			sphere_ptr3->set_material(matte_ptr3);
			add_object(sphere_ptr3);
	
	
			// cylinder
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(ka); 
			matte_ptr4->set_kd(0.5);
			matte_ptr4->set_cd(0.60);
	
			float bottom 	= 0.0;
			float top 		= 85; 
			float radius	= 22;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr4);
			add_object(cylinder_ptr);

	
			// box
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(ka); 
			matte_ptr5->set_kd(0.5);
			matte_ptr5->set_cd(0.95);
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(matte_ptr5);
			add_object(box_ptr);
	
				
			// ground plane
		
			Matte* matte_ptr6 = new Matte;			
			matte_ptr6->set_ka(0.15); 
			matte_ptr6->set_kd(0.5);	
			matte_ptr6->set_cd(0.7);    
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr6);
			add_object(plane_ptr);
			break;
		}
	case 125:
		{
			//18.07b
			int num_samples = 100;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
		
			tracer_ptr = new AreaLighting(this);	
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.0);
			set_ambient_light(ambient_ptr);				// for Figure 18.7(b)
		
			AmbientOccluder* ambient_occluder_ptr = new AmbientOccluder;
			ambient_occluder_ptr->set_sampler(new MultiJittered(num_samples));
			ambient_occluder_ptr->set_min_amount(0.5);
		//	set_ambient_light(ambient_occluder_ptr);	// for Figure 18.7 (a) & (c)

			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 45, 100);  
			pinhole_ptr->set_lookat(-10, 40, 0);  
			pinhole_ptr->set_view_distance(400);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(0.90);
			emissive_ptr->set_ce(1.0);   			// white
		
			ConcaveSphere* sphere_ptr = new ConcaveSphere;
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_shadows(false);
			add_object(sphere_ptr);
	
			EnvironmentLight* environment_light_ptr = new EnvironmentLight;
			environment_light_ptr->set_material(emissive_ptr);
			environment_light_ptr->set_sampler(new MultiJittered(num_samples));
			environment_light_ptr->set_shadows(true);
			add_light(environment_light_ptr);			// for Figure 18.7 (b) & (c)
		
	
			float ka = 0.2;  	// common ambient reflection coefficient
	
			// large sphere
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(ka); 
			matte_ptr1->set_kd(0.60);
			matte_ptr1->set_cd(0.75);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, 20, -24), 20);
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
	
			// small sphere
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(ka); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.85);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(34, 12, 13), 12);
			sphere_ptr2->set_material(matte_ptr2);
			add_object(sphere_ptr2);
	
	
			// medium sphere
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(ka); 
			matte_ptr3->set_kd(0.5);
			matte_ptr3->set_cd(0.75);
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(-7, 15, 42), 16);
			sphere_ptr3->set_material(matte_ptr3);
			add_object(sphere_ptr3);
	
	
			// cylinder
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(ka); 
			matte_ptr4->set_kd(0.5);
			matte_ptr4->set_cd(0.60);
	
			float bottom 	= 0.0;
			float top 		= 85; 
			float radius	= 22;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr4);
			add_object(cylinder_ptr);

	
			// box
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(ka); 
			matte_ptr5->set_kd(0.5);
			matte_ptr5->set_cd(0.95);
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(matte_ptr5);
			add_object(box_ptr);
	
				
			// ground plane
		
			Matte* matte_ptr6 = new Matte;			
			matte_ptr6->set_ka(0.15); 
			matte_ptr6->set_kd(0.5);	
			matte_ptr6->set_cd(0.7);    
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr6);
			add_object(plane_ptr);
			break;
		}
	case 126:
		{
			//18.07c
			int num_samples = 100;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
		
			tracer_ptr = new AreaLighting(this);	
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.0);
		//	set_ambient_light(ambient_ptr);				// for Figure 18.7(b)
		
			AmbientOccluder* ambient_occluder_ptr = new AmbientOccluder;
			ambient_occluder_ptr->set_sampler(new MultiJittered(num_samples));
			ambient_occluder_ptr->set_min_amount(0.5);
			set_ambient_light(ambient_occluder_ptr);	// for Figure 18.7 (a) & (c)

			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 45, 100);  
			pinhole_ptr->set_lookat(-10, 40, 0);  
			pinhole_ptr->set_view_distance(400);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(0.90);
			emissive_ptr->set_ce(1.0);   			// white
		
			ConcaveSphere* sphere_ptr = new ConcaveSphere;
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_shadows(false);
			add_object(sphere_ptr);
	
			EnvironmentLight* environment_light_ptr = new EnvironmentLight;
			environment_light_ptr->set_material(emissive_ptr);
			environment_light_ptr->set_sampler(new MultiJittered(num_samples));
			environment_light_ptr->set_shadows(true);
			add_light(environment_light_ptr);			// for Figure 18.7 (b) & (c)
		
	
			float ka = 0.2;  	// common ambient reflection coefficient
	
			// large sphere
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(ka); 
			matte_ptr1->set_kd(0.60);
			matte_ptr1->set_cd(0.75);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, 20, -24), 20);
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
	
			// small sphere
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(ka); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.85);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(34, 12, 13), 12);
			sphere_ptr2->set_material(matte_ptr2);
			add_object(sphere_ptr2);
	
	
			// medium sphere
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(ka); 
			matte_ptr3->set_kd(0.5);
			matte_ptr3->set_cd(0.75);
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(-7, 15, 42), 16);
			sphere_ptr3->set_material(matte_ptr3);
			add_object(sphere_ptr3);
	
	
			// cylinder
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(ka); 
			matte_ptr4->set_kd(0.5);
			matte_ptr4->set_cd(0.60);
	
			float bottom 	= 0.0;
			float top 		= 85; 
			float radius	= 22;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr4);
			add_object(cylinder_ptr);

	
			// box
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(ka); 
			matte_ptr5->set_kd(0.5);
			matte_ptr5->set_cd(0.95);
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(matte_ptr5);
			add_object(box_ptr);
	
				
			// ground plane
		
			Matte* matte_ptr6 = new Matte;			
			matte_ptr6->set_ka(0.15); 
			matte_ptr6->set_kd(0.5);	
			matte_ptr6->set_cd(0.7);    
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr6);
			add_object(plane_ptr);
			break;
		}
	case 127:
		{
			//18.08a
			int num_samples = 100;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
		
			tracer_ptr = new AreaLighting(this);	
		
			AmbientOccluder* ambient_occluder_ptr = new AmbientOccluder;
			ambient_occluder_ptr->set_sampler(new MultiJittered(num_samples));
			ambient_occluder_ptr->set_min_amount(0.5);
			set_ambient_light(ambient_occluder_ptr);

			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 45, 100);  
			pinhole_ptr->set_lookat(-10, 40, 0);  
			pinhole_ptr->set_view_distance(400);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);

	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(0.90);
			emissive_ptr->set_ce(1.0, 1.0, 0.5); 	// yellow 	for Figure 18.8(a)
		//	emissive_ptr->set_ce(0.5, 0.65, 0.75);  // blue		for Figure 18.8(b)

		
			ConcaveSphere* sphere_ptr = new ConcaveSphere;
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_shadows(false);
			add_object(sphere_ptr);
	
			EnvironmentLight* environment_light_ptr = new EnvironmentLight;
			environment_light_ptr->set_material(emissive_ptr);
			environment_light_ptr->set_sampler(new MultiJittered(num_samples));
			environment_light_ptr->set_shadows(true);
			add_light(environment_light_ptr);
	
	
			float ka = 0.2;  // commom ambient reflection coefficient
	
			// large sphere
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(ka); 
			matte_ptr1->set_kd(0.60);
			matte_ptr1->set_cd(0.75);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, 20, -24), 20);
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
	
			// small sphere
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(ka); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.85);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(34, 12, 13), 12);
			sphere_ptr2->set_material(matte_ptr2);
			add_object(sphere_ptr2);
	
	
			// medium sphere
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(ka); 
			matte_ptr3->set_kd(0.5);
			matte_ptr3->set_cd(0.75);
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(-7, 15, 42), 16);
			sphere_ptr3->set_material(matte_ptr3);
			add_object(sphere_ptr3);
	
	
			// cylinder
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(ka); 
			matte_ptr4->set_kd(0.5);
			matte_ptr4->set_cd(0.60);
	
			float bottom 	= 0.0;
			float top 		= 85; 
			float radius	= 22;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr4);
			add_object(cylinder_ptr);

	
			// box
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(ka); 
			matte_ptr5->set_kd(0.5);
			matte_ptr5->set_cd(0.95);
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(matte_ptr5);
			add_object(box_ptr);
	
				
			// ground plane
		
			Matte* matte_ptr6 = new Matte;			
			matte_ptr6->set_ka(0.15); 
			matte_ptr6->set_kd(0.5);	
			matte_ptr6->set_cd(0.7);    
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr6);
			add_object(plane_ptr);
			break;
		}
	case 128:
		{
			//18.08b
			int num_samples = 100;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
		
			tracer_ptr = new AreaLighting(this);	
		
			AmbientOccluder* ambient_occluder_ptr = new AmbientOccluder;
			ambient_occluder_ptr->set_sampler(new MultiJittered(num_samples));
			ambient_occluder_ptr->set_min_amount(0.5);
			set_ambient_light(ambient_occluder_ptr);

			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 45, 100);  
			pinhole_ptr->set_lookat(-10, 40, 0);  
			pinhole_ptr->set_view_distance(400);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);

	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(0.90);
		//	emissive_ptr->set_ce(1.0, 1.0, 0.5); 	// yellow 	for Figure 18.8(a)
			emissive_ptr->set_ce(0.5, 0.65, 0.75);  // blue		for Figure 18.8(b)

		
			ConcaveSphere* sphere_ptr = new ConcaveSphere;
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_shadows(false);
			add_object(sphere_ptr);
	
			EnvironmentLight* environment_light_ptr = new EnvironmentLight;
			environment_light_ptr->set_material(emissive_ptr);
			environment_light_ptr->set_sampler(new MultiJittered(num_samples));
			environment_light_ptr->set_shadows(true);
			add_light(environment_light_ptr);
	
	
			float ka = 0.2;  // commom ambient reflection coefficient
	
			// large sphere
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(ka); 
			matte_ptr1->set_kd(0.60);
			matte_ptr1->set_cd(0.75);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, 20, -24), 20);
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
	
			// small sphere
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(ka); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.85);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(34, 12, 13), 12);
			sphere_ptr2->set_material(matte_ptr2);
			add_object(sphere_ptr2);
	
	
			// medium sphere
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(ka); 
			matte_ptr3->set_kd(0.5);
			matte_ptr3->set_cd(0.75);
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(-7, 15, 42), 16);
			sphere_ptr3->set_material(matte_ptr3);
			add_object(sphere_ptr3);
	
	
			// cylinder
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(ka); 
			matte_ptr4->set_kd(0.5);
			matte_ptr4->set_cd(0.60);
	
			float bottom 	= 0.0;
			float top 		= 85; 
			float radius	= 22;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr4);
			add_object(cylinder_ptr);

	
			// box
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(ka); 
			matte_ptr5->set_kd(0.5);
			matte_ptr5->set_cd(0.95);
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(matte_ptr5);
			add_object(box_ptr);
	
				
			// ground plane
		
			Matte* matte_ptr6 = new Matte;			
			matte_ptr6->set_ka(0.15); 
			matte_ptr6->set_kd(0.5);	
			matte_ptr6->set_cd(0.7);    
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr6);
			add_object(plane_ptr);
			break;
		}
	case 129:
		{
			//18.09
			int num_samples = 100;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
		
			tracer_ptr = new AreaLighting(this);	
		
			AmbientOccluder* ambient_occluder_ptr = new AmbientOccluder;
			ambient_occluder_ptr->set_sampler(new MultiJittered(num_samples));
			ambient_occluder_ptr->set_min_amount(0.5);
			set_ambient_light(ambient_occluder_ptr);

			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 45, 100);  
			pinhole_ptr->set_lookat(-10, 40, 0);  
			pinhole_ptr->set_view_distance(400);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(150, 50, -50);   
			light_ptr3->scale_radiance(4.0); 
			light_ptr3->set_color(1.0, 0.25, 0.0);  // orange
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);

	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(0.90);
			emissive_ptr->set_ce(1.0, 1.0, 0.5); 	// yellow
		
			ConcaveSphere* sphere_ptr = new ConcaveSphere;
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_shadows(false);
			add_object(sphere_ptr);
	
			EnvironmentLight* environment_light_ptr = new EnvironmentLight;
			environment_light_ptr->set_material(emissive_ptr);
			environment_light_ptr->set_sampler(new MultiJittered(num_samples));
			environment_light_ptr->set_shadows(true);
			add_light(environment_light_ptr);
	
	
			float ka = 0.2;  // commom ambient reflection coefficient
	
			// large sphere
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(ka); 
			matte_ptr1->set_kd(0.60);
			matte_ptr1->set_cd(0.75);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, 20, -24), 20);
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
	
			// small sphere
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(ka); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.85);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(34, 12, 13), 12);
			sphere_ptr2->set_material(matte_ptr2);
			add_object(sphere_ptr2);
	
	
			// medium sphere
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(ka); 
			matte_ptr3->set_kd(0.5);
			matte_ptr3->set_cd(0.75);
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(-7, 15, 42), 16);
			sphere_ptr3->set_material(matte_ptr3);
			add_object(sphere_ptr3);
	
	
			// cylinder
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(ka); 
			matte_ptr4->set_kd(0.5);
			matte_ptr4->set_cd(0.60);
	
			float bottom 	= 0.0;
			float top 		= 85; 
			float radius	= 22;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr4);
			add_object(cylinder_ptr);

	
			// box
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(ka); 
			matte_ptr5->set_kd(0.5);
			matte_ptr5->set_cd(0.95);
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(matte_ptr5);
			add_object(box_ptr);
	
				
			// ground plane
		
			Matte* matte_ptr6 = new Matte;			
			matte_ptr6->set_ka(0.15); 
			matte_ptr6->set_kd(0.5);	
			matte_ptr6->set_cd(0.7);    
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr6);
			add_object(plane_ptr);
			break;
		}
	case 130:
		{
			//12.10a
			int num_samples = 16;    // for Figure 18.10 (a) & (b)
		//	int num_samples = 256;   // for Figure 18.10 (c) & (d)
		  
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_pixel_size(0.5);
			vp.set_samples(num_samples);  
		
			tracer_ptr = new AreaLighting(this);	
		
			AmbientOccluder* ambientOccluder_ptr = new AmbientOccluder;
			ambientOccluder_ptr->set_sampler(new MultiJittered(num_samples));  	// for Figure 18.10 (a) & (c)
		//	ambientOccluder_ptr->set_sampler(new Hammersley(num_samples));		// for Figure 18.10 (b) & (d)
			ambientOccluder_ptr->set_min_amount(0.5);
			set_ambient_light(ambientOccluder_ptr);
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, -10000);
			pinhole_ptr->set_lookat(0.0);   
			pinhole_ptr->set_view_distance(15000);		
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(0.90);
			emissive_ptr->set_ce(white);   

	
			ConcaveSphere* sphere_ptr = new ConcaveSphere;
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_shadows(false);
			add_object(sphere_ptr);
	
			EnvironmentLight* environment_light_ptr = new EnvironmentLight;
			environment_light_ptr->set_material(emissive_ptr);
			environment_light_ptr->set_sampler(new MultiJittered(num_samples));	// for Figure 18.10 (a) & (c)
		//	environment_light_ptr->set_sampler(new Hammersley(num_samples));	// for Figure 18.10 (b) & (d)
			environment_light_ptr->set_shadows(true);
			add_light(environment_light_ptr);
	
	
			// common Matte material reflection coefficients
	
			float ka = 0.25;
			float kd = 0.75;
			float min = 0.25;
			float max = 0.8;
	
			set_rand_seed(1000);
	
	
			// the spheres
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(ka);	
			matte_ptr1->set_kd(kd);
			matte_ptr1->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));				
			Sphere*	sphere_ptr1 = new Sphere(Point3D(5, 3, 0), 30); 
			sphere_ptr1->set_material(matte_ptr1);	   							
			add_object(sphere_ptr1);
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(ka);	
			matte_ptr2->set_kd(kd);
			matte_ptr2->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr2 = new Sphere(Point3D(45, -7, -60), 20); 
			sphere_ptr2->set_material(matte_ptr2);								
			add_object(sphere_ptr2);
	

			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(ka);	
			matte_ptr3->set_kd(kd);
			matte_ptr3->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));	
			Sphere*	sphere_ptr3 = new Sphere(Point3D(40, 43, -100), 17); 
			sphere_ptr3->set_material(matte_ptr3);								
			add_object(sphere_ptr3);
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(ka);	
			matte_ptr4->set_kd(kd);
			matte_ptr4->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr4 = new Sphere(Point3D(-20, 28, -15), 20); 
			sphere_ptr4->set_material(matte_ptr4);								
			add_object(sphere_ptr4);
	
			Matte* matte_ptr5 = new Matte;
			matte_ptr5->set_ka(ka);	
			matte_ptr5->set_kd(kd);
			matte_ptr5->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr5 = new Sphere(Point3D(-25, -7, -35), 27); 			
			sphere_ptr5->set_material(matte_ptr5);								
			add_object(sphere_ptr5);
	
			Matte* matte_ptr6 = new Matte;
			matte_ptr6->set_ka(ka);	
			matte_ptr6->set_kd(kd);
			matte_ptr6->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr6 = new Sphere(Point3D(20, -27, -35), 25); 
			sphere_ptr6->set_material(matte_ptr6);								
			add_object(sphere_ptr6);
	
			Matte* matte_ptr7 = new Matte;
			matte_ptr7->set_ka(ka);	
			matte_ptr7->set_kd(kd);
			matte_ptr7->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr7 = new Sphere(Point3D(35, 18, -35), 22); 
			sphere_ptr7->set_material(matte_ptr7);   							
			add_object(sphere_ptr7);
	
			Matte* matte_ptr8 = new Matte;
			matte_ptr8->set_ka(ka);	
			matte_ptr8->set_kd(kd);
			matte_ptr8->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr8 = new Sphere(Point3D(-57, -17, -50), 15);  
			sphere_ptr8->set_material(matte_ptr8);								
			add_object(sphere_ptr8);
	
			Matte* matte_ptr9 = new Matte;
			matte_ptr9->set_ka(ka);	
			matte_ptr9->set_kd(kd);
			matte_ptr9->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr9 = new Sphere(Point3D(-47, 16, -80), 23); 
			sphere_ptr9->set_material(matte_ptr9);								
			add_object(sphere_ptr9);
		
			Matte* matte_ptr10 = new Matte;
			matte_ptr10->set_ka(ka);	
			matte_ptr10->set_kd(kd);
			matte_ptr10->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));	
			Sphere*	sphere_ptr10 = new Sphere(Point3D(-15, -32, -60), 22); 
			sphere_ptr10->set_material(matte_ptr10);     						
			add_object(sphere_ptr10);
	
			Matte* matte_ptr11 = new Matte;
			matte_ptr11->set_ka(ka);	
			matte_ptr11->set_kd(kd);
			matte_ptr11->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr11 = new Sphere(Point3D(-35, -37, -80), 22); 
			sphere_ptr11->set_material(matte_ptr11);							
			add_object(sphere_ptr11);
	
			Matte* matte_ptr12 = new Matte;
			matte_ptr12->set_ka(ka);	
			matte_ptr12->set_kd(kd);
			matte_ptr12->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr12 = new Sphere(Point3D(10, 43, -80), 22); 
			sphere_ptr12->set_material(matte_ptr12);							
			add_object(sphere_ptr12);
	
			Matte* matte_ptr13 = new Matte;
			matte_ptr13->set_ka(ka);	
			matte_ptr13->set_kd(kd);
			matte_ptr13->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));		
			Sphere*	sphere_ptr13 = new Sphere(Point3D(30, -7, -80), 10); 
			sphere_ptr13->set_material(matte_ptr13);
			add_object(sphere_ptr13);											
	
			Matte* matte_ptr14 = new Matte;
			matte_ptr14->set_ka(ka);	
			matte_ptr14->set_kd(kd);
			matte_ptr14->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));	
			Sphere*	sphere_ptr14 = new Sphere(Point3D(-40, 48, -110), 18); 
			sphere_ptr14->set_material(matte_ptr14); 							
			add_object(sphere_ptr14);
	
			Matte* matte_ptr15 = new Matte;
			matte_ptr15->set_ka(ka);	
			matte_ptr15->set_kd(kd);
			matte_ptr15->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));	
			Sphere*	sphere_ptr15 = new Sphere(Point3D(-10, 53, -120), 18); 
			sphere_ptr15->set_material(matte_ptr15); 							
			add_object(sphere_ptr15);
	
			Matte* matte_ptr16 = new Matte;
			matte_ptr16->set_ka(ka);	
			matte_ptr16->set_kd(kd);
			matte_ptr16->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr16 = new Sphere(Point3D(-55, -52, -100), 10); 
			sphere_ptr16->set_material(matte_ptr16);							
			add_object(sphere_ptr16);
	
			Matte* matte_ptr17 = new Matte;
			matte_ptr17->set_ka(ka);	
			matte_ptr17->set_kd(kd);
			matte_ptr17->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr17 = new Sphere(Point3D(5, -52, -100), 15); 		
			sphere_ptr17->set_material(matte_ptr17);							
			add_object(sphere_ptr17);
	
			Matte* matte_ptr18 = new Matte;
			matte_ptr18->set_ka(ka);	
			matte_ptr18->set_kd(kd);
			matte_ptr18->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr18 = new Sphere(Point3D(-20, -57, -120), 15); 
			sphere_ptr18->set_material(matte_ptr18);							
			add_object(sphere_ptr18);
	
			Matte* matte_ptr19 = new Matte;
			matte_ptr19->set_ka(ka);	
			matte_ptr19->set_kd(kd);
			matte_ptr19->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr19 = new Sphere(Point3D(55, -27, -100), 17); 
			sphere_ptr19->set_material(matte_ptr19);							
			add_object(sphere_ptr19);

			Matte* matte_ptr20 = new Matte;
			matte_ptr20->set_ka(ka);	
			matte_ptr20->set_kd(kd);
			matte_ptr20->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr20 = new Sphere(Point3D(50, -47, -120), 15); 
			sphere_ptr20->set_material(matte_ptr20);							
			add_object(sphere_ptr20);
	 
			Matte* matte_ptr21 = new Matte;
			matte_ptr21->set_ka(ka);	
			matte_ptr21->set_kd(kd);
			matte_ptr21->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min)); 	
			Sphere*	sphere_ptr21 = new Sphere(Point3D(70, -42, -150), 10); 
			sphere_ptr21->set_material(matte_ptr21);							
			add_object(sphere_ptr21);
	
			Matte* matte_ptr22 = new Matte;
			matte_ptr22->set_ka(ka);	
			matte_ptr22->set_kd(kd);
			matte_ptr22->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr22 = new Sphere(Point3D(5, 73, -130), 12); 
			sphere_ptr22->set_material(matte_ptr22);							
			add_object(sphere_ptr22);
	
			Matte* matte_ptr23 = new Matte;
			matte_ptr23->set_ka(ka);	
			matte_ptr23->set_kd(kd);
			matte_ptr23->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr23 = new Sphere(Point3D(66, 21, -130), 13); 			
			sphere_ptr23->set_material(matte_ptr23);							
			add_object(sphere_ptr23);	
	
			Matte* matte_ptr24 = new Matte;
			matte_ptr24->set_ka(ka);	
			matte_ptr24->set_kd(kd);
			matte_ptr24->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));  
			Sphere*	sphere_ptr24 = new Sphere(Point3D(72, -12, -140), 12); 
			sphere_ptr24->set_material(matte_ptr24);							
			add_object(sphere_ptr24);
	
			Matte* matte_ptr25 = new Matte;
			matte_ptr25->set_ka(ka);	
			matte_ptr25->set_kd(kd);
			matte_ptr25->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr25 = new Sphere(Point3D(64, 5, -160), 11); 			
			sphere_ptr25->set_material(matte_ptr25);					 		
			add_object(sphere_ptr25);
	  
			Matte* matte_ptr26 = new Matte;
			matte_ptr26->set_ka(ka);	
			matte_ptr26->set_kd(kd);
			matte_ptr26->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr26 = new Sphere(Point3D(55, 38, -160), 12); 		
			sphere_ptr26->set_material(matte_ptr26);							
			add_object(sphere_ptr26);
	
			Matte* matte_ptr27 = new Matte;
			matte_ptr27->set_ka(ka);	
			matte_ptr27->set_kd(kd);
			matte_ptr27->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr27 = new Sphere(Point3D(-73, -2, -160), 12); 		
			sphere_ptr27->set_material(matte_ptr27);							
			add_object(sphere_ptr27);
	 
			Matte* matte_ptr28 = new Matte;
			matte_ptr28->set_ka(ka);	
			matte_ptr28->set_kd(kd);
			matte_ptr28->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr28 = new Sphere(Point3D(30, -62, -140), 15); 
			sphere_ptr28->set_material(matte_ptr28); 							
			add_object(sphere_ptr28);
	
			Matte* matte_ptr29 = new Matte;
			matte_ptr29->set_ka(ka);	
			matte_ptr29->set_kd(kd);
			matte_ptr29->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr29 = new Sphere(Point3D(25, 63, -140), 15); 
			sphere_ptr29->set_material(matte_ptr29);							
			add_object(sphere_ptr29);
	
			Matte* matte_ptr30 = new Matte;
			matte_ptr30->set_ka(ka);	
			matte_ptr30->set_kd(kd);
			matte_ptr30->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr30 = new Sphere(Point3D(-60, 46, -140), 15);  
			sphere_ptr30->set_material(matte_ptr30); 							
			add_object(sphere_ptr30);
	
			Matte* matte_ptr31 = new Matte;
			matte_ptr31->set_ka(ka);	
			matte_ptr31->set_kd(kd);
			matte_ptr31->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr31 = new Sphere(Point3D(-30, 68, -130), 12); 
			sphere_ptr31->set_material(matte_ptr31); 							
			add_object(sphere_ptr31);
	
			Matte* matte_ptr32 = new Matte;
			matte_ptr32->set_ka(ka);	
			matte_ptr32->set_kd(kd);
			matte_ptr32->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr32 = new Sphere(Point3D(58, 56, -180), 11);   
			sphere_ptr32->set_material(matte_ptr32);							
			add_object(sphere_ptr32);
	
			Matte* matte_ptr33 = new Matte;
			matte_ptr33->set_ka(ka);	
			matte_ptr33->set_kd(kd);
			matte_ptr33->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr33 = new Sphere(Point3D(-63, -39, -180), 11); 
			sphere_ptr33->set_material(matte_ptr33);							 
			add_object(sphere_ptr33);
	
			Matte* matte_ptr34 = new Matte;
			matte_ptr34->set_ka(ka);	
			matte_ptr34->set_kd(kd);
			matte_ptr34->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr34 = new Sphere(Point3D(46, 68, -200), 10); 	
			sphere_ptr34->set_material(matte_ptr34);							
			add_object(sphere_ptr34);
	
			Matte* matte_ptr35 = new Matte;
			matte_ptr35->set_ka(ka);	
			matte_ptr35->set_kd(kd);
			matte_ptr35->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr35 = new Sphere(Point3D(-3, -72, -130), 12); 
			sphere_ptr35->set_material(matte_ptr35);							
			add_object(sphere_ptr35);
			break;
		}
	case 131:
		{
			//12.10b
			int num_samples = 16;    // for Figure 18.10 (a) & (b)
		//	int num_samples = 256;   // for Figure 18.10 (c) & (d)
		  
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_pixel_size(0.5);
			vp.set_samples(num_samples);  
		
			tracer_ptr = new AreaLighting(this);	
		
			AmbientOccluder* ambientOccluder_ptr = new AmbientOccluder;
		//	ambientOccluder_ptr->set_sampler(new MultiJittered(num_samples));  	// for Figure 18.10 (a) & (c)
			ambientOccluder_ptr->set_sampler(new Hammersley(num_samples));		// for Figure 18.10 (b) & (d)
			ambientOccluder_ptr->set_min_amount(0.5);
			set_ambient_light(ambientOccluder_ptr);
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, -10000);
			pinhole_ptr->set_lookat(0.0);   
			pinhole_ptr->set_view_distance(15000);		
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(0.90);
			emissive_ptr->set_ce(white);   

	
			ConcaveSphere* sphere_ptr = new ConcaveSphere;
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_shadows(false);
			add_object(sphere_ptr);
	
			EnvironmentLight* environment_light_ptr = new EnvironmentLight;
			environment_light_ptr->set_material(emissive_ptr);
		//	environment_light_ptr->set_sampler(new MultiJittered(num_samples));	// for Figure 18.10 (a) & (c)
			environment_light_ptr->set_sampler(new Hammersley(num_samples));	// for Figure 18.10 (b) & (d)
			environment_light_ptr->set_shadows(true);
			add_light(environment_light_ptr);
	
	
			// common Matte material reflection coefficients
	
			float ka = 0.25;
			float kd = 0.75;
			float min = 0.25;
			float max = 0.8;
	
			set_rand_seed(1000);
	
	
			// the spheres
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(ka);	
			matte_ptr1->set_kd(kd);
			matte_ptr1->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));				
			Sphere*	sphere_ptr1 = new Sphere(Point3D(5, 3, 0), 30); 
			sphere_ptr1->set_material(matte_ptr1);	   							
			add_object(sphere_ptr1);
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(ka);	
			matte_ptr2->set_kd(kd);
			matte_ptr2->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr2 = new Sphere(Point3D(45, -7, -60), 20); 
			sphere_ptr2->set_material(matte_ptr2);								
			add_object(sphere_ptr2);
	

			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(ka);	
			matte_ptr3->set_kd(kd);
			matte_ptr3->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));	
			Sphere*	sphere_ptr3 = new Sphere(Point3D(40, 43, -100), 17); 
			sphere_ptr3->set_material(matte_ptr3);								
			add_object(sphere_ptr3);
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(ka);	
			matte_ptr4->set_kd(kd);
			matte_ptr4->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr4 = new Sphere(Point3D(-20, 28, -15), 20); 
			sphere_ptr4->set_material(matte_ptr4);								
			add_object(sphere_ptr4);
	
			Matte* matte_ptr5 = new Matte;
			matte_ptr5->set_ka(ka);	
			matte_ptr5->set_kd(kd);
			matte_ptr5->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr5 = new Sphere(Point3D(-25, -7, -35), 27); 			
			sphere_ptr5->set_material(matte_ptr5);								
			add_object(sphere_ptr5);
	
			Matte* matte_ptr6 = new Matte;
			matte_ptr6->set_ka(ka);	
			matte_ptr6->set_kd(kd);
			matte_ptr6->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr6 = new Sphere(Point3D(20, -27, -35), 25); 
			sphere_ptr6->set_material(matte_ptr6);								
			add_object(sphere_ptr6);
	
			Matte* matte_ptr7 = new Matte;
			matte_ptr7->set_ka(ka);	
			matte_ptr7->set_kd(kd);
			matte_ptr7->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr7 = new Sphere(Point3D(35, 18, -35), 22); 
			sphere_ptr7->set_material(matte_ptr7);   							
			add_object(sphere_ptr7);
	
			Matte* matte_ptr8 = new Matte;
			matte_ptr8->set_ka(ka);	
			matte_ptr8->set_kd(kd);
			matte_ptr8->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr8 = new Sphere(Point3D(-57, -17, -50), 15);  
			sphere_ptr8->set_material(matte_ptr8);								
			add_object(sphere_ptr8);
	
			Matte* matte_ptr9 = new Matte;
			matte_ptr9->set_ka(ka);	
			matte_ptr9->set_kd(kd);
			matte_ptr9->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr9 = new Sphere(Point3D(-47, 16, -80), 23); 
			sphere_ptr9->set_material(matte_ptr9);								
			add_object(sphere_ptr9);
		
			Matte* matte_ptr10 = new Matte;
			matte_ptr10->set_ka(ka);	
			matte_ptr10->set_kd(kd);
			matte_ptr10->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));	
			Sphere*	sphere_ptr10 = new Sphere(Point3D(-15, -32, -60), 22); 
			sphere_ptr10->set_material(matte_ptr10);     						
			add_object(sphere_ptr10);
	
			Matte* matte_ptr11 = new Matte;
			matte_ptr11->set_ka(ka);	
			matte_ptr11->set_kd(kd);
			matte_ptr11->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr11 = new Sphere(Point3D(-35, -37, -80), 22); 
			sphere_ptr11->set_material(matte_ptr11);							
			add_object(sphere_ptr11);
	
			Matte* matte_ptr12 = new Matte;
			matte_ptr12->set_ka(ka);	
			matte_ptr12->set_kd(kd);
			matte_ptr12->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr12 = new Sphere(Point3D(10, 43, -80), 22); 
			sphere_ptr12->set_material(matte_ptr12);							
			add_object(sphere_ptr12);
	
			Matte* matte_ptr13 = new Matte;
			matte_ptr13->set_ka(ka);	
			matte_ptr13->set_kd(kd);
			matte_ptr13->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));		
			Sphere*	sphere_ptr13 = new Sphere(Point3D(30, -7, -80), 10); 
			sphere_ptr13->set_material(matte_ptr13);
			add_object(sphere_ptr13);											
	
			Matte* matte_ptr14 = new Matte;
			matte_ptr14->set_ka(ka);	
			matte_ptr14->set_kd(kd);
			matte_ptr14->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));	
			Sphere*	sphere_ptr14 = new Sphere(Point3D(-40, 48, -110), 18); 
			sphere_ptr14->set_material(matte_ptr14); 							
			add_object(sphere_ptr14);
	
			Matte* matte_ptr15 = new Matte;
			matte_ptr15->set_ka(ka);	
			matte_ptr15->set_kd(kd);
			matte_ptr15->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));	
			Sphere*	sphere_ptr15 = new Sphere(Point3D(-10, 53, -120), 18); 
			sphere_ptr15->set_material(matte_ptr15); 							
			add_object(sphere_ptr15);
	
			Matte* matte_ptr16 = new Matte;
			matte_ptr16->set_ka(ka);	
			matte_ptr16->set_kd(kd);
			matte_ptr16->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr16 = new Sphere(Point3D(-55, -52, -100), 10); 
			sphere_ptr16->set_material(matte_ptr16);							
			add_object(sphere_ptr16);
	
			Matte* matte_ptr17 = new Matte;
			matte_ptr17->set_ka(ka);	
			matte_ptr17->set_kd(kd);
			matte_ptr17->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr17 = new Sphere(Point3D(5, -52, -100), 15); 		
			sphere_ptr17->set_material(matte_ptr17);							
			add_object(sphere_ptr17);
	
			Matte* matte_ptr18 = new Matte;
			matte_ptr18->set_ka(ka);	
			matte_ptr18->set_kd(kd);
			matte_ptr18->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr18 = new Sphere(Point3D(-20, -57, -120), 15); 
			sphere_ptr18->set_material(matte_ptr18);							
			add_object(sphere_ptr18);
	
			Matte* matte_ptr19 = new Matte;
			matte_ptr19->set_ka(ka);	
			matte_ptr19->set_kd(kd);
			matte_ptr19->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr19 = new Sphere(Point3D(55, -27, -100), 17); 
			sphere_ptr19->set_material(matte_ptr19);							
			add_object(sphere_ptr19);

			Matte* matte_ptr20 = new Matte;
			matte_ptr20->set_ka(ka);	
			matte_ptr20->set_kd(kd);
			matte_ptr20->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr20 = new Sphere(Point3D(50, -47, -120), 15); 
			sphere_ptr20->set_material(matte_ptr20);							
			add_object(sphere_ptr20);
	 
			Matte* matte_ptr21 = new Matte;
			matte_ptr21->set_ka(ka);	
			matte_ptr21->set_kd(kd);
			matte_ptr21->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min)); 	
			Sphere*	sphere_ptr21 = new Sphere(Point3D(70, -42, -150), 10); 
			sphere_ptr21->set_material(matte_ptr21);							
			add_object(sphere_ptr21);
	
			Matte* matte_ptr22 = new Matte;
			matte_ptr22->set_ka(ka);	
			matte_ptr22->set_kd(kd);
			matte_ptr22->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr22 = new Sphere(Point3D(5, 73, -130), 12); 
			sphere_ptr22->set_material(matte_ptr22);							
			add_object(sphere_ptr22);
	
			Matte* matte_ptr23 = new Matte;
			matte_ptr23->set_ka(ka);	
			matte_ptr23->set_kd(kd);
			matte_ptr23->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr23 = new Sphere(Point3D(66, 21, -130), 13); 			
			sphere_ptr23->set_material(matte_ptr23);							
			add_object(sphere_ptr23);	
	
			Matte* matte_ptr24 = new Matte;
			matte_ptr24->set_ka(ka);	
			matte_ptr24->set_kd(kd);
			matte_ptr24->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));  
			Sphere*	sphere_ptr24 = new Sphere(Point3D(72, -12, -140), 12); 
			sphere_ptr24->set_material(matte_ptr24);							
			add_object(sphere_ptr24);
	
			Matte* matte_ptr25 = new Matte;
			matte_ptr25->set_ka(ka);	
			matte_ptr25->set_kd(kd);
			matte_ptr25->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr25 = new Sphere(Point3D(64, 5, -160), 11); 			
			sphere_ptr25->set_material(matte_ptr25);					 		
			add_object(sphere_ptr25);
	  
			Matte* matte_ptr26 = new Matte;
			matte_ptr26->set_ka(ka);	
			matte_ptr26->set_kd(kd);
			matte_ptr26->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr26 = new Sphere(Point3D(55, 38, -160), 12); 		
			sphere_ptr26->set_material(matte_ptr26);							
			add_object(sphere_ptr26);
	
			Matte* matte_ptr27 = new Matte;
			matte_ptr27->set_ka(ka);	
			matte_ptr27->set_kd(kd);
			matte_ptr27->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr27 = new Sphere(Point3D(-73, -2, -160), 12); 		
			sphere_ptr27->set_material(matte_ptr27);							
			add_object(sphere_ptr27);
	 
			Matte* matte_ptr28 = new Matte;
			matte_ptr28->set_ka(ka);	
			matte_ptr28->set_kd(kd);
			matte_ptr28->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr28 = new Sphere(Point3D(30, -62, -140), 15); 
			sphere_ptr28->set_material(matte_ptr28); 							
			add_object(sphere_ptr28);
	
			Matte* matte_ptr29 = new Matte;
			matte_ptr29->set_ka(ka);	
			matte_ptr29->set_kd(kd);
			matte_ptr29->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr29 = new Sphere(Point3D(25, 63, -140), 15); 
			sphere_ptr29->set_material(matte_ptr29);							
			add_object(sphere_ptr29);
	
			Matte* matte_ptr30 = new Matte;
			matte_ptr30->set_ka(ka);	
			matte_ptr30->set_kd(kd);
			matte_ptr30->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr30 = new Sphere(Point3D(-60, 46, -140), 15);  
			sphere_ptr30->set_material(matte_ptr30); 							
			add_object(sphere_ptr30);
	
			Matte* matte_ptr31 = new Matte;
			matte_ptr31->set_ka(ka);	
			matte_ptr31->set_kd(kd);
			matte_ptr31->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr31 = new Sphere(Point3D(-30, 68, -130), 12); 
			sphere_ptr31->set_material(matte_ptr31); 							
			add_object(sphere_ptr31);
	
			Matte* matte_ptr32 = new Matte;
			matte_ptr32->set_ka(ka);	
			matte_ptr32->set_kd(kd);
			matte_ptr32->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr32 = new Sphere(Point3D(58, 56, -180), 11);   
			sphere_ptr32->set_material(matte_ptr32);							
			add_object(sphere_ptr32);
	
			Matte* matte_ptr33 = new Matte;
			matte_ptr33->set_ka(ka);	
			matte_ptr33->set_kd(kd);
			matte_ptr33->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr33 = new Sphere(Point3D(-63, -39, -180), 11); 
			sphere_ptr33->set_material(matte_ptr33);							 
			add_object(sphere_ptr33);
	
			Matte* matte_ptr34 = new Matte;
			matte_ptr34->set_ka(ka);	
			matte_ptr34->set_kd(kd);
			matte_ptr34->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr34 = new Sphere(Point3D(46, 68, -200), 10); 	
			sphere_ptr34->set_material(matte_ptr34);							
			add_object(sphere_ptr34);
	
			Matte* matte_ptr35 = new Matte;
			matte_ptr35->set_ka(ka);	
			matte_ptr35->set_kd(kd);
			matte_ptr35->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr35 = new Sphere(Point3D(-3, -72, -130), 12); 
			sphere_ptr35->set_material(matte_ptr35);							
			add_object(sphere_ptr35);
			break;
		}
	case 132:
		{
			//12.10c
		//	int num_samples = 16;    // for Figure 18.10 (a) & (b)
			int num_samples = 256;   // for Figure 18.10 (c) & (d)
		  
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_pixel_size(0.5);
			vp.set_samples(num_samples);  
		
			tracer_ptr = new AreaLighting(this);	
		
			AmbientOccluder* ambientOccluder_ptr = new AmbientOccluder;
			ambientOccluder_ptr->set_sampler(new MultiJittered(num_samples));  	// for Figure 18.10 (a) & (c)
		//	ambientOccluder_ptr->set_sampler(new Hammersley(num_samples));		// for Figure 18.10 (b) & (d)
			ambientOccluder_ptr->set_min_amount(0.5);
			set_ambient_light(ambientOccluder_ptr);
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, -10000);
			pinhole_ptr->set_lookat(0.0);   
			pinhole_ptr->set_view_distance(15000);		
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(0.90);
			emissive_ptr->set_ce(white);   

	
			ConcaveSphere* sphere_ptr = new ConcaveSphere;
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_shadows(false);
			add_object(sphere_ptr);
	
			EnvironmentLight* environment_light_ptr = new EnvironmentLight;
			environment_light_ptr->set_material(emissive_ptr);
			environment_light_ptr->set_sampler(new MultiJittered(num_samples));	// for Figure 18.10 (a) & (c)
		//	environment_light_ptr->set_sampler(new Hammersley(num_samples));	// for Figure 18.10 (b) & (d)
			environment_light_ptr->set_shadows(true);
			add_light(environment_light_ptr);
	
	
			// common Matte material reflection coefficients
	
			float ka = 0.25;
			float kd = 0.75;
			float min = 0.25;
			float max = 0.8;
	
			set_rand_seed(1000);
	
	
			// the spheres
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(ka);	
			matte_ptr1->set_kd(kd);
			matte_ptr1->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));				
			Sphere*	sphere_ptr1 = new Sphere(Point3D(5, 3, 0), 30); 
			sphere_ptr1->set_material(matte_ptr1);	   							
			add_object(sphere_ptr1);
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(ka);	
			matte_ptr2->set_kd(kd);
			matte_ptr2->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr2 = new Sphere(Point3D(45, -7, -60), 20); 
			sphere_ptr2->set_material(matte_ptr2);								
			add_object(sphere_ptr2);
	

			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(ka);	
			matte_ptr3->set_kd(kd);
			matte_ptr3->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));	
			Sphere*	sphere_ptr3 = new Sphere(Point3D(40, 43, -100), 17); 
			sphere_ptr3->set_material(matte_ptr3);								
			add_object(sphere_ptr3);
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(ka);	
			matte_ptr4->set_kd(kd);
			matte_ptr4->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr4 = new Sphere(Point3D(-20, 28, -15), 20); 
			sphere_ptr4->set_material(matte_ptr4);								
			add_object(sphere_ptr4);
	
			Matte* matte_ptr5 = new Matte;
			matte_ptr5->set_ka(ka);	
			matte_ptr5->set_kd(kd);
			matte_ptr5->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr5 = new Sphere(Point3D(-25, -7, -35), 27); 			
			sphere_ptr5->set_material(matte_ptr5);								
			add_object(sphere_ptr5);
	
			Matte* matte_ptr6 = new Matte;
			matte_ptr6->set_ka(ka);	
			matte_ptr6->set_kd(kd);
			matte_ptr6->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr6 = new Sphere(Point3D(20, -27, -35), 25); 
			sphere_ptr6->set_material(matte_ptr6);								
			add_object(sphere_ptr6);
	
			Matte* matte_ptr7 = new Matte;
			matte_ptr7->set_ka(ka);	
			matte_ptr7->set_kd(kd);
			matte_ptr7->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr7 = new Sphere(Point3D(35, 18, -35), 22); 
			sphere_ptr7->set_material(matte_ptr7);   							
			add_object(sphere_ptr7);
	
			Matte* matte_ptr8 = new Matte;
			matte_ptr8->set_ka(ka);	
			matte_ptr8->set_kd(kd);
			matte_ptr8->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr8 = new Sphere(Point3D(-57, -17, -50), 15);  
			sphere_ptr8->set_material(matte_ptr8);								
			add_object(sphere_ptr8);
	
			Matte* matte_ptr9 = new Matte;
			matte_ptr9->set_ka(ka);	
			matte_ptr9->set_kd(kd);
			matte_ptr9->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr9 = new Sphere(Point3D(-47, 16, -80), 23); 
			sphere_ptr9->set_material(matte_ptr9);								
			add_object(sphere_ptr9);
		
			Matte* matte_ptr10 = new Matte;
			matte_ptr10->set_ka(ka);	
			matte_ptr10->set_kd(kd);
			matte_ptr10->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));	
			Sphere*	sphere_ptr10 = new Sphere(Point3D(-15, -32, -60), 22); 
			sphere_ptr10->set_material(matte_ptr10);     						
			add_object(sphere_ptr10);
	
			Matte* matte_ptr11 = new Matte;
			matte_ptr11->set_ka(ka);	
			matte_ptr11->set_kd(kd);
			matte_ptr11->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr11 = new Sphere(Point3D(-35, -37, -80), 22); 
			sphere_ptr11->set_material(matte_ptr11);							
			add_object(sphere_ptr11);
	
			Matte* matte_ptr12 = new Matte;
			matte_ptr12->set_ka(ka);	
			matte_ptr12->set_kd(kd);
			matte_ptr12->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr12 = new Sphere(Point3D(10, 43, -80), 22); 
			sphere_ptr12->set_material(matte_ptr12);							
			add_object(sphere_ptr12);
	
			Matte* matte_ptr13 = new Matte;
			matte_ptr13->set_ka(ka);	
			matte_ptr13->set_kd(kd);
			matte_ptr13->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));		
			Sphere*	sphere_ptr13 = new Sphere(Point3D(30, -7, -80), 10); 
			sphere_ptr13->set_material(matte_ptr13);
			add_object(sphere_ptr13);											
	
			Matte* matte_ptr14 = new Matte;
			matte_ptr14->set_ka(ka);	
			matte_ptr14->set_kd(kd);
			matte_ptr14->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));	
			Sphere*	sphere_ptr14 = new Sphere(Point3D(-40, 48, -110), 18); 
			sphere_ptr14->set_material(matte_ptr14); 							
			add_object(sphere_ptr14);
	
			Matte* matte_ptr15 = new Matte;
			matte_ptr15->set_ka(ka);	
			matte_ptr15->set_kd(kd);
			matte_ptr15->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));	
			Sphere*	sphere_ptr15 = new Sphere(Point3D(-10, 53, -120), 18); 
			sphere_ptr15->set_material(matte_ptr15); 							
			add_object(sphere_ptr15);
	
			Matte* matte_ptr16 = new Matte;
			matte_ptr16->set_ka(ka);	
			matte_ptr16->set_kd(kd);
			matte_ptr16->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr16 = new Sphere(Point3D(-55, -52, -100), 10); 
			sphere_ptr16->set_material(matte_ptr16);							
			add_object(sphere_ptr16);
	
			Matte* matte_ptr17 = new Matte;
			matte_ptr17->set_ka(ka);	
			matte_ptr17->set_kd(kd);
			matte_ptr17->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr17 = new Sphere(Point3D(5, -52, -100), 15); 		
			sphere_ptr17->set_material(matte_ptr17);							
			add_object(sphere_ptr17);
	
			Matte* matte_ptr18 = new Matte;
			matte_ptr18->set_ka(ka);	
			matte_ptr18->set_kd(kd);
			matte_ptr18->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr18 = new Sphere(Point3D(-20, -57, -120), 15); 
			sphere_ptr18->set_material(matte_ptr18);							
			add_object(sphere_ptr18);
	
			Matte* matte_ptr19 = new Matte;
			matte_ptr19->set_ka(ka);	
			matte_ptr19->set_kd(kd);
			matte_ptr19->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr19 = new Sphere(Point3D(55, -27, -100), 17); 
			sphere_ptr19->set_material(matte_ptr19);							
			add_object(sphere_ptr19);

			Matte* matte_ptr20 = new Matte;
			matte_ptr20->set_ka(ka);	
			matte_ptr20->set_kd(kd);
			matte_ptr20->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr20 = new Sphere(Point3D(50, -47, -120), 15); 
			sphere_ptr20->set_material(matte_ptr20);							
			add_object(sphere_ptr20);
	 
			Matte* matte_ptr21 = new Matte;
			matte_ptr21->set_ka(ka);	
			matte_ptr21->set_kd(kd);
			matte_ptr21->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min)); 	
			Sphere*	sphere_ptr21 = new Sphere(Point3D(70, -42, -150), 10); 
			sphere_ptr21->set_material(matte_ptr21);							
			add_object(sphere_ptr21);
	
			Matte* matte_ptr22 = new Matte;
			matte_ptr22->set_ka(ka);	
			matte_ptr22->set_kd(kd);
			matte_ptr22->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr22 = new Sphere(Point3D(5, 73, -130), 12); 
			sphere_ptr22->set_material(matte_ptr22);							
			add_object(sphere_ptr22);
	
			Matte* matte_ptr23 = new Matte;
			matte_ptr23->set_ka(ka);	
			matte_ptr23->set_kd(kd);
			matte_ptr23->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr23 = new Sphere(Point3D(66, 21, -130), 13); 			
			sphere_ptr23->set_material(matte_ptr23);							
			add_object(sphere_ptr23);	
	
			Matte* matte_ptr24 = new Matte;
			matte_ptr24->set_ka(ka);	
			matte_ptr24->set_kd(kd);
			matte_ptr24->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));  
			Sphere*	sphere_ptr24 = new Sphere(Point3D(72, -12, -140), 12); 
			sphere_ptr24->set_material(matte_ptr24);							
			add_object(sphere_ptr24);
	
			Matte* matte_ptr25 = new Matte;
			matte_ptr25->set_ka(ka);	
			matte_ptr25->set_kd(kd);
			matte_ptr25->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr25 = new Sphere(Point3D(64, 5, -160), 11); 			
			sphere_ptr25->set_material(matte_ptr25);					 		
			add_object(sphere_ptr25);
	  
			Matte* matte_ptr26 = new Matte;
			matte_ptr26->set_ka(ka);	
			matte_ptr26->set_kd(kd);
			matte_ptr26->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr26 = new Sphere(Point3D(55, 38, -160), 12); 		
			sphere_ptr26->set_material(matte_ptr26);							
			add_object(sphere_ptr26);
	
			Matte* matte_ptr27 = new Matte;
			matte_ptr27->set_ka(ka);	
			matte_ptr27->set_kd(kd);
			matte_ptr27->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr27 = new Sphere(Point3D(-73, -2, -160), 12); 		
			sphere_ptr27->set_material(matte_ptr27);							
			add_object(sphere_ptr27);
	 
			Matte* matte_ptr28 = new Matte;
			matte_ptr28->set_ka(ka);	
			matte_ptr28->set_kd(kd);
			matte_ptr28->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr28 = new Sphere(Point3D(30, -62, -140), 15); 
			sphere_ptr28->set_material(matte_ptr28); 							
			add_object(sphere_ptr28);
	
			Matte* matte_ptr29 = new Matte;
			matte_ptr29->set_ka(ka);	
			matte_ptr29->set_kd(kd);
			matte_ptr29->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr29 = new Sphere(Point3D(25, 63, -140), 15); 
			sphere_ptr29->set_material(matte_ptr29);							
			add_object(sphere_ptr29);
	
			Matte* matte_ptr30 = new Matte;
			matte_ptr30->set_ka(ka);	
			matte_ptr30->set_kd(kd);
			matte_ptr30->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr30 = new Sphere(Point3D(-60, 46, -140), 15);  
			sphere_ptr30->set_material(matte_ptr30); 							
			add_object(sphere_ptr30);
	
			Matte* matte_ptr31 = new Matte;
			matte_ptr31->set_ka(ka);	
			matte_ptr31->set_kd(kd);
			matte_ptr31->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr31 = new Sphere(Point3D(-30, 68, -130), 12); 
			sphere_ptr31->set_material(matte_ptr31); 							
			add_object(sphere_ptr31);
	
			Matte* matte_ptr32 = new Matte;
			matte_ptr32->set_ka(ka);	
			matte_ptr32->set_kd(kd);
			matte_ptr32->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr32 = new Sphere(Point3D(58, 56, -180), 11);   
			sphere_ptr32->set_material(matte_ptr32);							
			add_object(sphere_ptr32);
	
			Matte* matte_ptr33 = new Matte;
			matte_ptr33->set_ka(ka);	
			matte_ptr33->set_kd(kd);
			matte_ptr33->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr33 = new Sphere(Point3D(-63, -39, -180), 11); 
			sphere_ptr33->set_material(matte_ptr33);							 
			add_object(sphere_ptr33);
	
			Matte* matte_ptr34 = new Matte;
			matte_ptr34->set_ka(ka);	
			matte_ptr34->set_kd(kd);
			matte_ptr34->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr34 = new Sphere(Point3D(46, 68, -200), 10); 	
			sphere_ptr34->set_material(matte_ptr34);							
			add_object(sphere_ptr34);
	
			Matte* matte_ptr35 = new Matte;
			matte_ptr35->set_ka(ka);	
			matte_ptr35->set_kd(kd);
			matte_ptr35->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr35 = new Sphere(Point3D(-3, -72, -130), 12); 
			sphere_ptr35->set_material(matte_ptr35);							
			add_object(sphere_ptr35);
			break;
		}
	case 133:
		{
			//12.10d
		//	int num_samples = 16;    // for Figure 18.10 (a) & (b)
			int num_samples = 256;   // for Figure 18.10 (c) & (d)
		  
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_pixel_size(0.5);
			vp.set_samples(num_samples);  
		
			tracer_ptr = new AreaLighting(this);	
		
			AmbientOccluder* ambientOccluder_ptr = new AmbientOccluder;
		//	ambientOccluder_ptr->set_sampler(new MultiJittered(num_samples));  	// for Figure 18.10 (a) & (c)
			ambientOccluder_ptr->set_sampler(new Hammersley(num_samples));		// for Figure 18.10 (b) & (d)
			ambientOccluder_ptr->set_min_amount(0.5);
			set_ambient_light(ambientOccluder_ptr);
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, -10000);
			pinhole_ptr->set_lookat(0.0);   
			pinhole_ptr->set_view_distance(15000);		
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(0.90);
			emissive_ptr->set_ce(white);   

	
			ConcaveSphere* sphere_ptr = new ConcaveSphere;
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_shadows(false);
			add_object(sphere_ptr);
	
			EnvironmentLight* environment_light_ptr = new EnvironmentLight;
			environment_light_ptr->set_material(emissive_ptr);
		//	environment_light_ptr->set_sampler(new MultiJittered(num_samples));	// for Figure 18.10 (a) & (c)
			environment_light_ptr->set_sampler(new Hammersley(num_samples));	// for Figure 18.10 (b) & (d)
			environment_light_ptr->set_shadows(true);
			add_light(environment_light_ptr);
	
	
			// common Matte material reflection coefficients
	
			float ka = 0.25;
			float kd = 0.75;
			float min = 0.25;
			float max = 0.8;
	
			set_rand_seed(1000);
	
	
			// the spheres
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(ka);	
			matte_ptr1->set_kd(kd);
			matte_ptr1->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));				
			Sphere*	sphere_ptr1 = new Sphere(Point3D(5, 3, 0), 30); 
			sphere_ptr1->set_material(matte_ptr1);	   							
			add_object(sphere_ptr1);
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(ka);	
			matte_ptr2->set_kd(kd);
			matte_ptr2->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr2 = new Sphere(Point3D(45, -7, -60), 20); 
			sphere_ptr2->set_material(matte_ptr2);								
			add_object(sphere_ptr2);
	

			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(ka);	
			matte_ptr3->set_kd(kd);
			matte_ptr3->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));	
			Sphere*	sphere_ptr3 = new Sphere(Point3D(40, 43, -100), 17); 
			sphere_ptr3->set_material(matte_ptr3);								
			add_object(sphere_ptr3);
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(ka);	
			matte_ptr4->set_kd(kd);
			matte_ptr4->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr4 = new Sphere(Point3D(-20, 28, -15), 20); 
			sphere_ptr4->set_material(matte_ptr4);								
			add_object(sphere_ptr4);
	
			Matte* matte_ptr5 = new Matte;
			matte_ptr5->set_ka(ka);	
			matte_ptr5->set_kd(kd);
			matte_ptr5->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr5 = new Sphere(Point3D(-25, -7, -35), 27); 			
			sphere_ptr5->set_material(matte_ptr5);								
			add_object(sphere_ptr5);
	
			Matte* matte_ptr6 = new Matte;
			matte_ptr6->set_ka(ka);	
			matte_ptr6->set_kd(kd);
			matte_ptr6->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr6 = new Sphere(Point3D(20, -27, -35), 25); 
			sphere_ptr6->set_material(matte_ptr6);								
			add_object(sphere_ptr6);
	
			Matte* matte_ptr7 = new Matte;
			matte_ptr7->set_ka(ka);	
			matte_ptr7->set_kd(kd);
			matte_ptr7->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr7 = new Sphere(Point3D(35, 18, -35), 22); 
			sphere_ptr7->set_material(matte_ptr7);   							
			add_object(sphere_ptr7);
	
			Matte* matte_ptr8 = new Matte;
			matte_ptr8->set_ka(ka);	
			matte_ptr8->set_kd(kd);
			matte_ptr8->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr8 = new Sphere(Point3D(-57, -17, -50), 15);  
			sphere_ptr8->set_material(matte_ptr8);								
			add_object(sphere_ptr8);
	
			Matte* matte_ptr9 = new Matte;
			matte_ptr9->set_ka(ka);	
			matte_ptr9->set_kd(kd);
			matte_ptr9->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr9 = new Sphere(Point3D(-47, 16, -80), 23); 
			sphere_ptr9->set_material(matte_ptr9);								
			add_object(sphere_ptr9);
		
			Matte* matte_ptr10 = new Matte;
			matte_ptr10->set_ka(ka);	
			matte_ptr10->set_kd(kd);
			matte_ptr10->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));	
			Sphere*	sphere_ptr10 = new Sphere(Point3D(-15, -32, -60), 22); 
			sphere_ptr10->set_material(matte_ptr10);     						
			add_object(sphere_ptr10);
	
			Matte* matte_ptr11 = new Matte;
			matte_ptr11->set_ka(ka);	
			matte_ptr11->set_kd(kd);
			matte_ptr11->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr11 = new Sphere(Point3D(-35, -37, -80), 22); 
			sphere_ptr11->set_material(matte_ptr11);							
			add_object(sphere_ptr11);
	
			Matte* matte_ptr12 = new Matte;
			matte_ptr12->set_ka(ka);	
			matte_ptr12->set_kd(kd);
			matte_ptr12->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr12 = new Sphere(Point3D(10, 43, -80), 22); 
			sphere_ptr12->set_material(matte_ptr12);							
			add_object(sphere_ptr12);
	
			Matte* matte_ptr13 = new Matte;
			matte_ptr13->set_ka(ka);	
			matte_ptr13->set_kd(kd);
			matte_ptr13->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));		
			Sphere*	sphere_ptr13 = new Sphere(Point3D(30, -7, -80), 10); 
			sphere_ptr13->set_material(matte_ptr13);
			add_object(sphere_ptr13);											
	
			Matte* matte_ptr14 = new Matte;
			matte_ptr14->set_ka(ka);	
			matte_ptr14->set_kd(kd);
			matte_ptr14->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));	
			Sphere*	sphere_ptr14 = new Sphere(Point3D(-40, 48, -110), 18); 
			sphere_ptr14->set_material(matte_ptr14); 							
			add_object(sphere_ptr14);
	
			Matte* matte_ptr15 = new Matte;
			matte_ptr15->set_ka(ka);	
			matte_ptr15->set_kd(kd);
			matte_ptr15->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));	
			Sphere*	sphere_ptr15 = new Sphere(Point3D(-10, 53, -120), 18); 
			sphere_ptr15->set_material(matte_ptr15); 							
			add_object(sphere_ptr15);
	
			Matte* matte_ptr16 = new Matte;
			matte_ptr16->set_ka(ka);	
			matte_ptr16->set_kd(kd);
			matte_ptr16->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr16 = new Sphere(Point3D(-55, -52, -100), 10); 
			sphere_ptr16->set_material(matte_ptr16);							
			add_object(sphere_ptr16);
	
			Matte* matte_ptr17 = new Matte;
			matte_ptr17->set_ka(ka);	
			matte_ptr17->set_kd(kd);
			matte_ptr17->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr17 = new Sphere(Point3D(5, -52, -100), 15); 		
			sphere_ptr17->set_material(matte_ptr17);							
			add_object(sphere_ptr17);
	
			Matte* matte_ptr18 = new Matte;
			matte_ptr18->set_ka(ka);	
			matte_ptr18->set_kd(kd);
			matte_ptr18->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr18 = new Sphere(Point3D(-20, -57, -120), 15); 
			sphere_ptr18->set_material(matte_ptr18);							
			add_object(sphere_ptr18);
	
			Matte* matte_ptr19 = new Matte;
			matte_ptr19->set_ka(ka);	
			matte_ptr19->set_kd(kd);
			matte_ptr19->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr19 = new Sphere(Point3D(55, -27, -100), 17); 
			sphere_ptr19->set_material(matte_ptr19);							
			add_object(sphere_ptr19);

			Matte* matte_ptr20 = new Matte;
			matte_ptr20->set_ka(ka);	
			matte_ptr20->set_kd(kd);
			matte_ptr20->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr20 = new Sphere(Point3D(50, -47, -120), 15); 
			sphere_ptr20->set_material(matte_ptr20);							
			add_object(sphere_ptr20);
	 
			Matte* matte_ptr21 = new Matte;
			matte_ptr21->set_ka(ka);	
			matte_ptr21->set_kd(kd);
			matte_ptr21->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min)); 	
			Sphere*	sphere_ptr21 = new Sphere(Point3D(70, -42, -150), 10); 
			sphere_ptr21->set_material(matte_ptr21);							
			add_object(sphere_ptr21);
	
			Matte* matte_ptr22 = new Matte;
			matte_ptr22->set_ka(ka);	
			matte_ptr22->set_kd(kd);
			matte_ptr22->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr22 = new Sphere(Point3D(5, 73, -130), 12); 
			sphere_ptr22->set_material(matte_ptr22);							
			add_object(sphere_ptr22);
	
			Matte* matte_ptr23 = new Matte;
			matte_ptr23->set_ka(ka);	
			matte_ptr23->set_kd(kd);
			matte_ptr23->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr23 = new Sphere(Point3D(66, 21, -130), 13); 			
			sphere_ptr23->set_material(matte_ptr23);							
			add_object(sphere_ptr23);	
	
			Matte* matte_ptr24 = new Matte;
			matte_ptr24->set_ka(ka);	
			matte_ptr24->set_kd(kd);
			matte_ptr24->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));  
			Sphere*	sphere_ptr24 = new Sphere(Point3D(72, -12, -140), 12); 
			sphere_ptr24->set_material(matte_ptr24);							
			add_object(sphere_ptr24);
	
			Matte* matte_ptr25 = new Matte;
			matte_ptr25->set_ka(ka);	
			matte_ptr25->set_kd(kd);
			matte_ptr25->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr25 = new Sphere(Point3D(64, 5, -160), 11); 			
			sphere_ptr25->set_material(matte_ptr25);					 		
			add_object(sphere_ptr25);
	  
			Matte* matte_ptr26 = new Matte;
			matte_ptr26->set_ka(ka);	
			matte_ptr26->set_kd(kd);
			matte_ptr26->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr26 = new Sphere(Point3D(55, 38, -160), 12); 		
			sphere_ptr26->set_material(matte_ptr26);							
			add_object(sphere_ptr26);
	
			Matte* matte_ptr27 = new Matte;
			matte_ptr27->set_ka(ka);	
			matte_ptr27->set_kd(kd);
			matte_ptr27->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr27 = new Sphere(Point3D(-73, -2, -160), 12); 		
			sphere_ptr27->set_material(matte_ptr27);							
			add_object(sphere_ptr27);
	 
			Matte* matte_ptr28 = new Matte;
			matte_ptr28->set_ka(ka);	
			matte_ptr28->set_kd(kd);
			matte_ptr28->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr28 = new Sphere(Point3D(30, -62, -140), 15); 
			sphere_ptr28->set_material(matte_ptr28); 							
			add_object(sphere_ptr28);
	
			Matte* matte_ptr29 = new Matte;
			matte_ptr29->set_ka(ka);	
			matte_ptr29->set_kd(kd);
			matte_ptr29->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr29 = new Sphere(Point3D(25, 63, -140), 15); 
			sphere_ptr29->set_material(matte_ptr29);							
			add_object(sphere_ptr29);
	
			Matte* matte_ptr30 = new Matte;
			matte_ptr30->set_ka(ka);	
			matte_ptr30->set_kd(kd);
			matte_ptr30->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr30 = new Sphere(Point3D(-60, 46, -140), 15);  
			sphere_ptr30->set_material(matte_ptr30); 							
			add_object(sphere_ptr30);
	
			Matte* matte_ptr31 = new Matte;
			matte_ptr31->set_ka(ka);	
			matte_ptr31->set_kd(kd);
			matte_ptr31->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr31 = new Sphere(Point3D(-30, 68, -130), 12); 
			sphere_ptr31->set_material(matte_ptr31); 							
			add_object(sphere_ptr31);
	
			Matte* matte_ptr32 = new Matte;
			matte_ptr32->set_ka(ka);	
			matte_ptr32->set_kd(kd);
			matte_ptr32->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr32 = new Sphere(Point3D(58, 56, -180), 11);   
			sphere_ptr32->set_material(matte_ptr32);							
			add_object(sphere_ptr32);
	
			Matte* matte_ptr33 = new Matte;
			matte_ptr33->set_ka(ka);	
			matte_ptr33->set_kd(kd);
			matte_ptr33->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr33 = new Sphere(Point3D(-63, -39, -180), 11); 
			sphere_ptr33->set_material(matte_ptr33);							 
			add_object(sphere_ptr33);
	
			Matte* matte_ptr34 = new Matte;
			matte_ptr34->set_ka(ka);	
			matte_ptr34->set_kd(kd);
			matte_ptr34->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr34 = new Sphere(Point3D(46, 68, -200), 10); 	
			sphere_ptr34->set_material(matte_ptr34);							
			add_object(sphere_ptr34);
	
			Matte* matte_ptr35 = new Matte;
			matte_ptr35->set_ka(ka);	
			matte_ptr35->set_kd(kd);
			matte_ptr35->set_cd(min + rand_float() * (max - min), min + rand_float() * (max - min), min + rand_float() * (max - min));
			Sphere*	sphere_ptr35 = new Sphere(Point3D(-3, -72, -130), 12); 
			sphere_ptr35->set_material(matte_ptr35);							
			add_object(sphere_ptr35);
			break;
		}
	case 134:
		{
			//18.11a
			int num_samples = 100;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
		
			tracer_ptr = new AreaLighting(this);	
		
			AmbientOccluder* ambient_occluder_ptr = new AmbientOccluder;
			ambient_occluder_ptr->set_sampler(new MultiJittered(num_samples));
			ambient_occluder_ptr->set_min_amount(0.5);
			set_ambient_light(ambient_occluder_ptr);

			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 45, 100);  
			pinhole_ptr->set_lookat(-10, 40, 0);  
			pinhole_ptr->set_view_distance(400);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);

	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(0.90);
			emissive_ptr->set_ce(white);   	
		
			ConcaveSphere* sphere_ptr = new ConcaveSphere;
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_shadows(false);
			add_object(sphere_ptr);
	
			EnvironmentLight* environment_light_ptr = new EnvironmentLight;
			environment_light_ptr->set_material(emissive_ptr);
			environment_light_ptr->set_sampler(new MultiJittered(num_samples));
			environment_light_ptr->set_shadows(true);
			add_light(environment_light_ptr);
	
	
			float ka = 0.2;  		// commom ambient reflection coefficient
			float ks = 1.0;  		// commom specular reflection coefficient
			float exp = 10.0;   	// for Figure 18.11(a)
		//	float exp = 50.0;   	// for Figure 18.11(b)
		//	float exp = 200.0;   	// for Figure 18.11(c)
			RGBColour cs(1, 0, 0); 	// common specular color
	
			// large sphere
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(ka); 
			phong_ptr1->set_kd(0.6);
			phong_ptr1->set_cd(0.75);
			phong_ptr1->set_ks(ks);
			phong_ptr1->set_exp(exp);
			phong_ptr1->set_cs(cs);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, 20, -24), 20);
			sphere_ptr1->set_material(phong_ptr1);
			add_object(sphere_ptr1);
	
	
			// small sphere
		
			Phong* phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(ka); 
			phong_ptr2->set_kd(0.5);
			phong_ptr2->set_cd(0.95);
			phong_ptr2->set_ks(ks);
			phong_ptr2->set_exp(exp);
			phong_ptr2->set_cs(cs);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(34, 12, 13), 12);
			sphere_ptr2->set_material(phong_ptr2);
			add_object(sphere_ptr2);
	
	
			// medium sphere
	
			Phong* phong_ptr3 = new Phong;			
			phong_ptr3->set_ka(ka); 
			phong_ptr3->set_kd(0.5);
			phong_ptr3->set_cd(0.75);
			phong_ptr3->set_ks(ks);
			phong_ptr3->set_exp(exp);
			phong_ptr3->set_cs(cs);
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(-7, 15, 42), 16);
			sphere_ptr3->set_material(phong_ptr3);
			add_object(sphere_ptr3);
	
	
			// cylinder
	
			Phong* phong_ptr4 = new Phong;			
			phong_ptr4->set_ka(ka); 
			phong_ptr4->set_kd(0.5);
			phong_ptr4->set_cd(0.60);
			phong_ptr4->set_ks(ks);
			phong_ptr4->set_exp(exp);
			phong_ptr4->set_cs(cs);
	
			float bottom 	= 0.0;
			float top 		= 85; 
			float radius	= 22;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(phong_ptr4);
			add_object(cylinder_ptr);

	
			// box
	
			Phong* phong_ptr5 = new Phong;			
			phong_ptr5->set_ka(ka); 
			phong_ptr5->set_kd(0.5);
			phong_ptr5->set_cd(0.95);
			phong_ptr5->set_ks(ks);
			phong_ptr5->set_exp(exp);
			phong_ptr5->set_cs(cs);
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(phong_ptr5);
			add_object(box_ptr);
	
				
			// ground plane
		
			Matte* matte_ptr6 = new Matte;			
			matte_ptr6->set_ka(0.15); 
			matte_ptr6->set_kd(0.5);	
			matte_ptr6->set_cd(0.7);    
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr6);
			add_object(plane_ptr);
			break;
		}
	case 135:
		{
			//18.11b
			int num_samples = 100;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
		
			tracer_ptr = new AreaLighting(this);	
		
			AmbientOccluder* ambient_occluder_ptr = new AmbientOccluder;
			ambient_occluder_ptr->set_sampler(new MultiJittered(num_samples));
			ambient_occluder_ptr->set_min_amount(0.5);
			set_ambient_light(ambient_occluder_ptr);

			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 45, 100);  
			pinhole_ptr->set_lookat(-10, 40, 0);  
			pinhole_ptr->set_view_distance(400);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);

	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(0.90);
			emissive_ptr->set_ce(white);   	
		
			ConcaveSphere* sphere_ptr = new ConcaveSphere;
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_shadows(false);
			add_object(sphere_ptr);
	
			EnvironmentLight* environment_light_ptr = new EnvironmentLight;
			environment_light_ptr->set_material(emissive_ptr);
			environment_light_ptr->set_sampler(new MultiJittered(num_samples));
			environment_light_ptr->set_shadows(true);
			add_light(environment_light_ptr);
	
	
			float ka = 0.2;  		// commom ambient reflection coefficient
			float ks = 1.0;  		// commom specular reflection coefficient
		//	float exp = 10.0;   	// for Figure 18.11(a)
			float exp = 50.0;   	// for Figure 18.11(b)
		//	float exp = 200.0;   	// for Figure 18.11(c)
			RGBColour cs(1, 0, 0); 	// common specular color
	
			// large sphere
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(ka); 
			phong_ptr1->set_kd(0.6);
			phong_ptr1->set_cd(0.75);
			phong_ptr1->set_ks(ks);
			phong_ptr1->set_exp(exp);
			phong_ptr1->set_cs(cs);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, 20, -24), 20);
			sphere_ptr1->set_material(phong_ptr1);
			add_object(sphere_ptr1);
	
	
			// small sphere
		
			Phong* phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(ka); 
			phong_ptr2->set_kd(0.5);
			phong_ptr2->set_cd(0.95);
			phong_ptr2->set_ks(ks);
			phong_ptr2->set_exp(exp);
			phong_ptr2->set_cs(cs);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(34, 12, 13), 12);
			sphere_ptr2->set_material(phong_ptr2);
			add_object(sphere_ptr2);
	
	
			// medium sphere
	
			Phong* phong_ptr3 = new Phong;			
			phong_ptr3->set_ka(ka); 
			phong_ptr3->set_kd(0.5);
			phong_ptr3->set_cd(0.75);
			phong_ptr3->set_ks(ks);
			phong_ptr3->set_exp(exp);
			phong_ptr3->set_cs(cs);
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(-7, 15, 42), 16);
			sphere_ptr3->set_material(phong_ptr3);
			add_object(sphere_ptr3);
	
	
			// cylinder
	
			Phong* phong_ptr4 = new Phong;			
			phong_ptr4->set_ka(ka); 
			phong_ptr4->set_kd(0.5);
			phong_ptr4->set_cd(0.60);
			phong_ptr4->set_ks(ks);
			phong_ptr4->set_exp(exp);
			phong_ptr4->set_cs(cs);
	
			float bottom 	= 0.0;
			float top 		= 85; 
			float radius	= 22;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(phong_ptr4);
			add_object(cylinder_ptr);

	
			// box
	
			Phong* phong_ptr5 = new Phong;			
			phong_ptr5->set_ka(ka); 
			phong_ptr5->set_kd(0.5);
			phong_ptr5->set_cd(0.95);
			phong_ptr5->set_ks(ks);
			phong_ptr5->set_exp(exp);
			phong_ptr5->set_cs(cs);
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(phong_ptr5);
			add_object(box_ptr);
	
				
			// ground plane
		
			Matte* matte_ptr6 = new Matte;			
			matte_ptr6->set_ka(0.15); 
			matte_ptr6->set_kd(0.5);	
			matte_ptr6->set_cd(0.7);    
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr6);
			add_object(plane_ptr);
			break;
		}
	case 136:
		{
			//18.11c
			int num_samples = 100;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
		
			tracer_ptr = new AreaLighting(this);	
		
			AmbientOccluder* ambient_occluder_ptr = new AmbientOccluder;
			ambient_occluder_ptr->set_sampler(new MultiJittered(num_samples));
			ambient_occluder_ptr->set_min_amount(0.5);
			set_ambient_light(ambient_occluder_ptr);

			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 45, 100);  
			pinhole_ptr->set_lookat(-10, 40, 0);  
			pinhole_ptr->set_view_distance(400);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);

	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(0.90);
			emissive_ptr->set_ce(white);   	
		
			ConcaveSphere* sphere_ptr = new ConcaveSphere;
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_shadows(false);
			add_object(sphere_ptr);
	
			EnvironmentLight* environment_light_ptr = new EnvironmentLight;
			environment_light_ptr->set_material(emissive_ptr);
			environment_light_ptr->set_sampler(new MultiJittered(num_samples));
			environment_light_ptr->set_shadows(true);
			add_light(environment_light_ptr);
	
	
			float ka = 0.2;  		// commom ambient reflection coefficient
			float ks = 1.0;  		// commom specular reflection coefficient
		//	float exp = 10.0;   	// for Figure 18.11(a)
		//	float exp = 50.0;   	// for Figure 18.11(b)
			float exp = 200.0;   	// for Figure 18.11(c)
			RGBColour cs(1, 0, 0); 	// common specular color
	
			// large sphere
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(ka); 
			phong_ptr1->set_kd(0.6);
			phong_ptr1->set_cd(0.75);
			phong_ptr1->set_ks(ks);
			phong_ptr1->set_exp(exp);
			phong_ptr1->set_cs(cs);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, 20, -24), 20);
			sphere_ptr1->set_material(phong_ptr1);
			add_object(sphere_ptr1);
	
	
			// small sphere
		
			Phong* phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(ka); 
			phong_ptr2->set_kd(0.5);
			phong_ptr2->set_cd(0.95);
			phong_ptr2->set_ks(ks);
			phong_ptr2->set_exp(exp);
			phong_ptr2->set_cs(cs);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(34, 12, 13), 12);
			sphere_ptr2->set_material(phong_ptr2);
			add_object(sphere_ptr2);
	
	
			// medium sphere
	
			Phong* phong_ptr3 = new Phong;			
			phong_ptr3->set_ka(ka); 
			phong_ptr3->set_kd(0.5);
			phong_ptr3->set_cd(0.75);
			phong_ptr3->set_ks(ks);
			phong_ptr3->set_exp(exp);
			phong_ptr3->set_cs(cs);
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(-7, 15, 42), 16);
			sphere_ptr3->set_material(phong_ptr3);
			add_object(sphere_ptr3);
	
	
			// cylinder
	
			Phong* phong_ptr4 = new Phong;			
			phong_ptr4->set_ka(ka); 
			phong_ptr4->set_kd(0.5);
			phong_ptr4->set_cd(0.60);
			phong_ptr4->set_ks(ks);
			phong_ptr4->set_exp(exp);
			phong_ptr4->set_cs(cs);
	
			float bottom 	= 0.0;
			float top 		= 85; 
			float radius	= 22;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(phong_ptr4);
			add_object(cylinder_ptr);

	
			// box
	
			Phong* phong_ptr5 = new Phong;			
			phong_ptr5->set_ka(ka); 
			phong_ptr5->set_kd(0.5);
			phong_ptr5->set_cd(0.95);
			phong_ptr5->set_ks(ks);
			phong_ptr5->set_exp(exp);
			phong_ptr5->set_cs(cs);
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(phong_ptr5);
			add_object(box_ptr);
	
				
			// ground plane
		
			Matte* matte_ptr6 = new Matte;			
			matte_ptr6->set_ka(0.15); 
			matte_ptr6->set_kd(0.5);	
			matte_ptr6->set_cd(0.7);    
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr6);
			add_object(plane_ptr);
			break;
		}
	case 137:
		{
			//18.12a
			int num_samples = 100;   
	
			Sampler* sampler_ptr = new MultiJittered(num_samples);

			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_sampler(sampler_ptr);

			background_color = RGBColour(0.5);

			tracer_ptr = new RayCast(this);   

			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-20, 10, 20);
			pinhole_ptr->set_lookat(0, 2, 0); 	
			pinhole_ptr->set_view_distance(1080);          
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 

	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(40.0);   // can be different from the light_ptr
			emissive_ptr->set_ce(white);

			float width = 4.0;
			float radius = 0.56 * width;
			Point3D center(0.0, 7.0, -7.0);		
			Sphere* sphere_ptr = new Sphere(center, radius);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_sampler(sampler_ptr);
			sphere_ptr->set_shadows(false);
			add_object(sphere_ptr);
	
		
			FakeSphericalLight* light_ptr = new FakeSphericalLight;
			light_ptr->set_location(center);
			light_ptr->scale_radiance(250.0);       // for Figure 18.12(a)
		//	light_ptr->scale_radiance(3.0);			// for Figure 18.12(b)
			light_ptr->set_jitter_amount(radius);
			light_ptr->use_distance_attenuation(true);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
		
	
			// Four axis aligned boxes
		
			float box_width 	= 1.0; 		// x dimension
			float box_depth 	= 1.0; 		// z dimension
			float box_height 	= 4.5; 		// y dimension
			float gap			= 3.0; 
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.25); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.4, 0.7, 0.4);     // green
	
			Box* box_ptr0 = new Box(Point3D(- 1.5 * gap - 2.0 * box_width, 0.0, -0.5 * box_depth), 
									Point3D(-1.5 * gap  - box_width, box_height, 0.5 * box_depth)); 
			box_ptr0->set_material(matte_ptr1);
			add_object(box_ptr0);
	
			Box* box_ptr1 = new Box(Point3D(- 0.5 * gap - box_width, 0.0, -0.5 * box_depth), 
									Point3D(-0.5 * gap, box_height, 0.5 * box_depth)); 
			box_ptr1->set_material(matte_ptr1);
			add_object(box_ptr1);
		
			Box* box_ptr2 = new Box(Point3D(0.5 * gap, 0.0, -0.5 * box_depth), 
									Point3D(0.5 * gap + box_width, box_height, 0.5 * box_depth));
			box_ptr2->set_material(matte_ptr1);
			add_object(box_ptr2);
	
			Box* box_ptr3 = new Box(Point3D(1.5 * gap + box_width, 0.0, -0.5 * box_depth), 
									Point3D(1.5 * gap + 2.0 * box_width, box_height, 0.5 * box_depth));
			box_ptr3->set_material(matte_ptr1);
			add_object(box_ptr3);

		
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.1); 
			matte_ptr2->set_kd(0.90);
			matte_ptr2->set_cd(white);
		
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0)); 
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 138:
		{
			//18.12b
			int num_samples = 100;   
	
			Sampler* sampler_ptr = new MultiJittered(num_samples);

			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_sampler(sampler_ptr);

			background_color = RGBColour(0.5);

			tracer_ptr = new RayCast(this);   

			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-20, 10, 20);
			pinhole_ptr->set_lookat(0, 2, 0); 	
			pinhole_ptr->set_view_distance(1080);          
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 

	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(40.0);   // can be different from the light_ptr
			emissive_ptr->set_ce(white);

			float width = 4.0;
			float radius = 0.56 * width;
			Point3D center(0.0, 7.0, -7.0);		
			Sphere* sphere_ptr = new Sphere(center, radius);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_sampler(sampler_ptr);
			sphere_ptr->set_shadows(false);
			add_object(sphere_ptr);
	
		
			FakeSphericalLight* light_ptr = new FakeSphericalLight;
			light_ptr->set_location(center);
		//	light_ptr->scale_radiance(250.0);       // for Figure 18.12(a)
			light_ptr->scale_radiance(3.0);			// for Figure 18.12(b)
			light_ptr->set_jitter_amount(radius);
			light_ptr->use_distance_attenuation(false);		// according to original book, the distance attenuation should be turned off for figure 18.12b
			light_ptr->set_shadows(true);
			add_light(light_ptr);
		
	
			// Four axis aligned boxes
		
			float box_width 	= 1.0; 		// x dimension
			float box_depth 	= 1.0; 		// z dimension
			float box_height 	= 4.5; 		// y dimension
			float gap			= 3.0; 
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.25); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.4, 0.7, 0.4);     // green
	
			Box* box_ptr0 = new Box(Point3D(- 1.5 * gap - 2.0 * box_width, 0.0, -0.5 * box_depth), 
									Point3D(-1.5 * gap  - box_width, box_height, 0.5 * box_depth)); 
			box_ptr0->set_material(matte_ptr1);
			add_object(box_ptr0);
	
			Box* box_ptr1 = new Box(Point3D(- 0.5 * gap - box_width, 0.0, -0.5 * box_depth), 
									Point3D(-0.5 * gap, box_height, 0.5 * box_depth)); 
			box_ptr1->set_material(matte_ptr1);
			add_object(box_ptr1);
		
			Box* box_ptr2 = new Box(Point3D(0.5 * gap, 0.0, -0.5 * box_depth), 
									Point3D(0.5 * gap + box_width, box_height, 0.5 * box_depth));
			box_ptr2->set_material(matte_ptr1);
			add_object(box_ptr2);
	
			Box* box_ptr3 = new Box(Point3D(1.5 * gap + box_width, 0.0, -0.5 * box_depth), 
									Point3D(1.5 * gap + 2.0 * box_width, box_height, 0.5 * box_depth));
			box_ptr3->set_material(matte_ptr1);
			add_object(box_ptr3);		
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.1); 
			matte_ptr2->set_kd(0.90);
			matte_ptr2->set_cd(white);
		
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0)); 
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);	
			break;
		}
	case 139:
		{
			//19.07
			int num_samples = 1;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(25, 200, 100);  
			pinhole_ptr->set_lookat(-0.5, 0, 0);  
			pinhole_ptr->set_view_distance(8000);	
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(1, 5, 0);
			light_ptr1->scale_radiance(3.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			// yellow triangle
		
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.25); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(1, 1, 0);
	
			Triangle* triangle_ptr1 = new Triangle(Point3D(2, 0.5, 5), Point3D(2, 1.5, -5), Point3D(-1, 0, -4)); 
			triangle_ptr1->set_material(matte_ptr1);
			add_object(triangle_ptr1);
	
	
			// dark green triangle (transformed)
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.25); 
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(0.0, 0.5, 0.41);
	
			Instance* triangle_ptr2 = new Instance(new Triangle(Point3D(2, 1, 5), Point3D(2, 0.5, -5), Point3D(-1, -1, -4))); 
			triangle_ptr2->rotate_y(120);
			triangle_ptr2->set_material(matte_ptr2);
			add_object(triangle_ptr2);
	
	
			// brown triangle (transformed)
			
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(0.25); 
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(0.71, 0.40, 0.16);
	
			Instance* triangle_ptr3 = new Instance(new Triangle(Point3D(2, 0, 5), Point3D(2, 1, -5), Point3D(-1, 0, -4))); 
			triangle_ptr3->rotate_y(240);
			triangle_ptr3->set_material(matte_ptr3);
			add_object(triangle_ptr3);
			break;
		}
	case 140:
		{
			//19.16a
			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);	
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera = new Pinhole;
			camera->set_eye(5, 25, 20); 
			camera->set_lookat(0, 0, 0); 
			camera->set_view_distance(1500); 
			camera->compute_uvw();     
			set_camera(camera); 

			background_color = black;
		
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(200, 75, 100);
			light_ptr2->scale_radiance(4.0);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
			Phong* phong_ptr2 = new Phong;
			phong_ptr2->set_ka(0.25);
			phong_ptr2->set_kd(0.5);
			phong_ptr2->set_cd(1, 1, 0.45);  // lemon
			phong_ptr2->set_ks(0.05);
			phong_ptr2->set_exp(5);
	
			float a = 2.0;	 	// for all parts
			float b = 0.15;		// for Figure 19.16(a)
		//	float b = 0.5;	   	// for Figure 19.16(b)  default torus
		//	float b = 2;      	// for Figure 19.16(c)
																
			Torus* torus_ptr = new Torus(a, b);												
			torus_ptr->set_material(phong_ptr2);
			add_object(torus_ptr);
	
	
			// ground plane with checker:
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(1.0); 
			checker_ptr->set_color1(0.8);  
			checker_ptr->set_color2(1);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.30);
			sv_matte_ptr->set_kd(0.6);  
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -2, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 141:
		{
			//19.16b
			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);	
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera = new Pinhole;
			camera->set_eye(5, 25, 20); 
			camera->set_lookat(0, 0, 0); 
			camera->set_view_distance(1500); 
			camera->compute_uvw();     
			set_camera(camera); 

			background_color = black;
		
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(200, 75, 100);
			light_ptr2->scale_radiance(4.0);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
			Phong* phong_ptr2 = new Phong;
			phong_ptr2->set_ka(0.25);
			phong_ptr2->set_kd(0.5);
			phong_ptr2->set_cd(1, 1, 0.45);  // lemon
			phong_ptr2->set_ks(0.05);
			phong_ptr2->set_exp(5);
	
			float a = 2.0;	 	// for all parts
		//	float b = 0.15;		// for Figure 19.16(a)
			float b = 0.5;	   	// for Figure 19.16(b)  default torus
		//	float b = 2;      	// for Figure 19.16(c)
																
			Torus* torus_ptr = new Torus(a, b);												
			torus_ptr->set_material(phong_ptr2);
			add_object(torus_ptr);
	
	
			// ground plane with checker:
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(1.0); 
			checker_ptr->set_color1(0.8);  
			checker_ptr->set_color2(1);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.30);
			sv_matte_ptr->set_kd(0.6);  
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -2, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 142:
		{
			//19.16c
			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);	
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera = new Pinhole;
			camera->set_eye(5, 25, 20); 
			camera->set_lookat(0, 0, 0); 
			camera->set_view_distance(1500); 
			camera->compute_uvw();     
			set_camera(camera); 

			background_color = black;
		
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(200, 75, 100);
			light_ptr2->scale_radiance(4.0);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
			Phong* phong_ptr2 = new Phong;
			phong_ptr2->set_ka(0.25);
			phong_ptr2->set_kd(0.5);
			phong_ptr2->set_cd(1, 1, 0.45);  // lemon
			phong_ptr2->set_ks(0.05);
			phong_ptr2->set_exp(5);
	
			float a = 2.0;	 	// for all parts
		//	float b = 0.15;		// for Figure 19.16(a)
		//	float b = 0.5;	   	// for Figure 19.16(b)  default torus
			float b = 2;      	// for Figure 19.16(c)
																
			Torus* torus_ptr = new Torus(a, b);												
			torus_ptr->set_material(phong_ptr2);
			add_object(torus_ptr);
	
	
			// ground plane with checker:
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(1.0); 
			checker_ptr->set_color1(0.8);  
			checker_ptr->set_color2(1);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.30);
			sv_matte_ptr->set_kd(0.6);  
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -2, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 143:
		{
			//19.23a
			int num_samples = 1;
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new FirstHit(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 5, 10);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(1200);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			// point light
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(10, 13, 20);
			light_ptr1->scale_radiance(3.0); 
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);	

	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_cd(1, 1, 0); // yellow
			matte_ptr1->set_ka(0.3);    
			matte_ptr1->set_kd(0.6);
	
			// solid cylinder
			// the following values for bottom, top, and radius can also be the default values
			// by setting them in the SolidCylinder default constructor
	
			float bottom = -1.0;
			float top = 1.0;
			float radius = 1.0;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr1);
			add_object(cylinder_ptr);
	
			// ground plane
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_cd(1);				
			matte_ptr2->set_ka(0.25);    
			matte_ptr2->set_kd(1.0);
			Plane* plane_ptr1 = new Plane(Point3D(0, -1, 0), Normal(0, 1, 0));
			plane_ptr1->set_material(matte_ptr2);
			add_object(plane_ptr1);
			break;
		}
	case 144:
		{
			//19.25b
			int num_samples = 16;
	
			vp.set_hres(400);      
			vp.set_vres(400);    
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			background_color = white;
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100); 
			pinhole_ptr->set_eye(0, 50, 100); 
			pinhole_ptr->set_lookat(0.0, 0.75, 0.0); 
			pinhole_ptr->set_view_distance(16000);           
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(10, 5, 20);		
			light_ptr->scale_radiance(3.0);
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
	
			ConeChecker* checker_ptr = new ConeChecker;
			checker_ptr->set_color1(0.85);
			checker_ptr->set_color2(0.85);
			checker_ptr->set_line_color(black);
			checker_ptr->set_vertical_line_width(0.075);
			checker_ptr->set_horizontal_line_width(0.075);
			checker_ptr->set_num_vertical_checkers(10);
			checker_ptr->set_num_horizontal_checkers(14);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(checker_ptr);	
	
			OpenCone* cone_ptr = new OpenCone;
			cone_ptr->set_material(sv_matte_ptr);
			add_object(cone_ptr);
			break;
		}
	case 145:
		{
			//19.27a
			int num_samples = 16;
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(1, 2, 5);
			pinhole_ptr->set_lookat(0, -0.35, 0);
			pinhole_ptr->set_view_distance(900); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
		
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(20, 15, 15);
			light_ptr1->scale_radiance(3.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
			
			Phong* phong_ptr = new Phong;						
			phong_ptr->set_ka(0.3);    
			phong_ptr->set_kd(0.5);
			phong_ptr->set_cd(0.15, 0.75, 0.90);
			phong_ptr->set_ks(0.1);
			phong_ptr->set_exp(20.0);
	
			double inner_radius = 0.9;
			double outer_radius = 1.0;

			FlatRimmedBowl* bowl_ptr = new FlatRimmedBowl(inner_radius, outer_radius);
			bowl_ptr->set_material(phong_ptr);
			add_object(bowl_ptr);
			
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(1.0);		
			checker_ptr->set_color1(white);   
			checker_ptr->set_color2(0.75);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.35);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(checker_ptr);

			Plane* plane_ptr1 = new Plane(Point3D(0, -1, 0), Normal(0, 1, 0)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);	
			break;
		}
	case 146:
		{
			//19.27b
			int num_samples = 16;
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(1, 2, 5);
			pinhole_ptr->set_lookat(0, -0.35, 0);
			pinhole_ptr->set_view_distance(900); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
		
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(20, 15, 15);
			light_ptr1->scale_radiance(3.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
			
			Phong* phong_ptr = new Phong;						
			phong_ptr->set_ka(0.25);    
			phong_ptr->set_kd(0.5);
			phong_ptr->set_cd(0.53, 0.67, 0.34);
			phong_ptr->set_ks(0.1);
			phong_ptr->set_exp(50.0);
	
			double inner_radius = 0.9;
			double outer_radius = 1.0;

			RoundRimmedBowl* bowl_ptr = new RoundRimmedBowl(inner_radius, outer_radius);
			bowl_ptr->set_material(phong_ptr);
			add_object(bowl_ptr);
			
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(1.0);		
			checker_ptr->set_color1(white);   
			checker_ptr->set_color2(0.75);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.35);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(checker_ptr);

			Plane* plane_ptr1 = new Plane(Point3D(0, -1, 0), Normal(0, 1, 0)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);	
			break;
		}
	case 147:
		{
			//19.29a
			int num_samples = 16;
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 5, 10);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(1200);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(10, 13, 20);
			light_ptr->scale_radiance(3.0); 
			light_ptr->set_shadows(true);
			add_light(light_ptr);	

			Matte* matte_ptr1 = new Matte;		
			matte_ptr1->set_ka(0.3);    
			matte_ptr1->set_kd(0.6);
			matte_ptr1->set_cd(0, 1, 1);   // cyan
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.3);    
			matte_ptr2->set_kd(0.6);
			matte_ptr2->set_cd(1, 1, 0);  // yellow
	
			float bottom = -1.0;
			float top = 1.0;
			float radius = 1.0;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_bottom_material(matte_ptr1); 	// cyan
			cylinder_ptr->set_top_material(matte_ptr1); 	// cyan
			cylinder_ptr->set_wall_material(matte_ptr2); 	// yellow
			add_object(cylinder_ptr);
	
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(0.25);    
			matte_ptr3->set_kd(1.0);
			matte_ptr3->set_cd(white);
	
			Plane* plane_ptr = new Plane(Point3D(0, -1, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr3);
			add_object(plane_ptr);
			break;
		}
	case 148:
		{
			//19.29b
			int num_samples = 16;
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 3.25, 5);
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->set_view_distance(900); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
		
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(20, 15, 15);
			light_ptr1->scale_radiance(3.0);
			light_ptr1->set_shadows(false);
			add_light(light_ptr1);

	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.3);    
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(1, 1, 0.25);  	// lemon
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.4);    
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(0.5);   			// gray
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(0.4);    
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(0.25, 1, 1); 	// cyan
	
			// ring parameters	
		
			float y0 = -0.25;
			float y1 = 0.25;
			float inner_radius = 0.5;
			float outer_radius = 1.0;
	
			ThickRing* ring_ptr = new ThickRing(y0, y1, inner_radius, outer_radius); 
			ring_ptr->set_bottom_material(matte_ptr1);		// lemon
			ring_ptr->set_top_material(matte_ptr1);			// lemon
			ring_ptr->set_inner_wall_material(matte_ptr2);	// gray
			ring_ptr->set_outer_wall_material(matte_ptr3);	// cyan
			add_object(ring_ptr);
			break;
		}
	case 149:
		{
			//20.06a
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(60, 40, 80);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(12000); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(100, 100, 60);
			light_ptr->scale_radiance(3.0);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
			SphereChecker* checker_ptr = new SphereChecker;
			checker_ptr->set_num_vertical(45);
			checker_ptr->set_num_horizontal(20);
			checker_ptr->set_vertical_line_width(0.1);
			checker_ptr->set_horizontal_line_width(0.1);
			checker_ptr->set_color1(white);
			checker_ptr->set_color2(white);
			checker_ptr->set_line_color(black);
			
			SV_Matte* sv_matte_ptr = new SV_Matte;						
			sv_matte_ptr->set_ka(0.2);    
			sv_matte_ptr->set_kd(0.6);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Sphere* sphere_ptr = new Sphere;
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 150:
		{
			//20.06b
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(60, 40, 80);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(12000); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(100, 100, 60);
			light_ptr->scale_radiance(3.0);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
			SphereChecker* checker_ptr = new SphereChecker;
			checker_ptr->set_num_vertical(45);
			checker_ptr->set_num_horizontal(20);
			checker_ptr->set_vertical_line_width(0.1);
			checker_ptr->set_horizontal_line_width(0.1);
			checker_ptr->set_color1(white);
			checker_ptr->set_color2(white);
			checker_ptr->set_line_color(black);
			
			SV_Matte* sv_matte_ptr = new SV_Matte;						
			sv_matte_ptr->set_ka(0.2);    
			sv_matte_ptr->set_kd(0.6);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Sphere* sphere_ptr = new Sphere;
			sphere_ptr->set_material(sv_matte_ptr);
	
			Instance* ellipsoid_ptr = new Instance(sphere_ptr);
			ellipsoid_ptr->scale(1.25, 1.0, 2.25); 
			add_object(ellipsoid_ptr);
			break;
		}
	case 151:
		{
			//20.06c
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(60, 40, 80);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(12000); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(100, 100, 60);
			light_ptr->scale_radiance(3.0);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
			SphereChecker* checker_ptr = new SphereChecker;
			checker_ptr->set_num_vertical(20);
			checker_ptr->set_num_horizontal(20);
			checker_ptr->set_vertical_line_width(0.15);
			checker_ptr->set_horizontal_line_width(0.04);
			checker_ptr->set_color1(white);
			checker_ptr->set_color2(white);
			checker_ptr->set_line_color(black);
			
			SV_Matte* sv_matte_ptr = new SV_Matte;						
			sv_matte_ptr->set_ka(0.2);    
			sv_matte_ptr->set_kd(0.6);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Sphere* sphere_ptr = new Sphere;
			sphere_ptr->set_material(sv_matte_ptr);
	
			Instance* ellipsoid_ptr = new Instance(sphere_ptr);
			ellipsoid_ptr->scale(0.25, 2.5, 0.25); 
			add_object(ellipsoid_ptr);
			break;
		}
	case 152:
		{
			//20.06d
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(60, 40, 80);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(12000); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(100, 100, 60);
			light_ptr->scale_radiance(3.0);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
			SphereChecker* checker_ptr = new SphereChecker;
			checker_ptr->set_num_vertical(45);
			checker_ptr->set_num_horizontal(20);
			checker_ptr->set_vertical_line_width(0.1);
			checker_ptr->set_horizontal_line_width(0.1);
			checker_ptr->set_color1(white);
			checker_ptr->set_color2(white);
			checker_ptr->set_line_color(black);
			
			SV_Matte* sv_matte_ptr = new SV_Matte;						
			sv_matte_ptr->set_ka(0.2);    
			sv_matte_ptr->set_kd(0.6);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Sphere* sphere_ptr = new Sphere;
			sphere_ptr->set_material(sv_matte_ptr);
	
			Instance* ellipsoid_ptr = new Instance(sphere_ptr);
			ellipsoid_ptr->scale(2.5, 0.25, 2.5);   
			add_object(ellipsoid_ptr);
			break;
		}
	case 153:
		{
			//21.04
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny10K.ply").toLatin1().data()))
				return;
			
			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(350); 
			vp.set_samples(num_samples);	
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
		
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinHole_ptr = new Pinhole;
			pinHole_ptr->set_eye(7.7, 6, 15);
			pinHole_ptr->set_lookat(-1.0, -0.5, 0); 
			pinHole_ptr->set_view_distance(650);
			pinHole_ptr->compute_uvw();
			set_camera(pinHole_ptr);
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(30, 30, 25); 
			light_ptr1->set_location(30, 20, -10);  
			light_ptr1->scale_radiance(2.5);  
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(10, 20, 40);  
			light_ptr2->scale_radiance(1.5);  
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
			// ground plane 
	
			Matte* matte_ptr1 = new Matte;		
			matte_ptr1->set_ka(0.35);
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(white);  
	
			Plane* planePr1 = new Plane(Point3D(0, 0.24, 0), Normal(0, 1, 0));
			planePr1->set_material(matte_ptr1);
			add_object(planePr1);

				
			float 	x0 					= -5.0;					// minimum x center coordinate
			float 	z0 					= -5.0;					// minimum z center coordinate
			float 	x1 					= 5.0;					// minimum x center coordinate
			float 	z1 					= 5.0;					// minimum z center coordinate
			int 	num_x_bunnies		= 8;					// number of bunnies in the x direction
			int 	num_z_bunnies		= 8;  					// number of bunnies in the z direction
			float	x_spacing			= (x1 - x0) / (num_x_bunnies - 1); // center spacing in x direction
			float	z_spacing			= (z1 - z0) / (num_z_bunnies - 1); // center spacing in x direction
	
			Grid* bunny_ptr1 = new Grid(new Mesh);
			bunny_ptr1->read_smooth_triangles(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data());
			bunny_ptr1->setup_cells();
	
			set_rand_seed(1000);
			Grid* grid_ptr = new Grid;
	
			for (int iz = 0; iz < num_z_bunnies; iz++)
				for (int ix = 0; ix < num_x_bunnies; ix++) {
					Phong* phong_ptr = new Phong;	
					phong_ptr->set_ka(0.25); 
					phong_ptr->set_kd(0.75);
					phong_ptr->set_cd(rand_float(), rand_float(), rand_float());
					phong_ptr->set_ks(0.125);  
					phong_ptr->set_exp(20.0);
			
					Instance* bunny_ptr2 = new Instance(bunny_ptr1);
					bunny_ptr2->set_material(phong_ptr);
					bunny_ptr2->scale(6.5);
					bunny_ptr2->translate(x0 + ix * x_spacing, 0, z0 + iz * z_spacing);
					bunny_ptr2->set_bounding_box(); // essential for placing each bunny in the grid
					grid_ptr->add_object(bunny_ptr2);
				}

			grid_ptr->setup_cells();
			add_object(grid_ptr);
			break;
		}
	case 154:
		{
			//21.05a
			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 0, 100);  
			pinhole_ptr->set_lookat(0, 1, 0); 	 
			pinhole_ptr->set_view_distance(8000);	
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);

			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(50, 50, 1);
			light_ptr->scale_radiance(3.0);  
			add_light(light_ptr);
	
			Phong* phong_ptr = new Phong;			
			phong_ptr->set_ka(0.25); 
			phong_ptr->set_kd(0.8);
			phong_ptr->set_cd(0.75); 
			phong_ptr->set_ks(0.15); 
			phong_ptr->set_exp(50.0);  
	
			Sphere* sphere_ptr = new Sphere;
			sphere_ptr->set_material(phong_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 155:
		{
			//21.05b
			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(1);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 0, 100);   
			pinhole_ptr->set_lookat(0, 1, 0); 	 
			pinhole_ptr->set_view_distance(8000);	
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);

			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(50, 50, 1);
			light_ptr->scale_radiance(3.0);   
			add_light(light_ptr);
	
			Phong* phong_ptr = new Phong;			
			phong_ptr->set_cd(0.75);  
			phong_ptr->set_ka(0.25); 
			phong_ptr->set_kd(0.8);
			phong_ptr->set_ks(0.15); 
			phong_ptr->set_exp(50.0);  
	
			Instance* ellipsoid_ptr = new Instance(new Sphere);
			ellipsoid_ptr->set_material(phong_ptr);
			ellipsoid_ptr->scale(2, 3, 1);
			ellipsoid_ptr->rotate_x(-45);
			ellipsoid_ptr->translate(0, 1, 0);
			add_object(ellipsoid_ptr);
			break;
		}
	case 156:
		{
			//21.06
			int num_samples = 1;
	
			vp.set_hres(600);	  		
			vp.set_vres(280);
			vp.set_samples(1);
	
			tracer_ptr = new RayCast(this);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 15, 50);
			pinhole_ptr->set_lookat(0, 0.75, 0);
			pinhole_ptr->set_view_distance(4000); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
		
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(10, 15, 20);
			light_ptr1->scale_radiance(3.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
		
			Phong* phong_ptr = new Phong;			
			phong_ptr->set_ka(0.3);    
			phong_ptr->set_kd(0.75);
			phong_ptr->set_cd(0.7, 0.5, 0);		// orange
			phong_ptr->set_ks(0.2);
			phong_ptr->set_exp(3);
	
			// cylinder	
	
			float y0  = -0.75; 
			float y1  = 1.25; 
			float radius = 1.0;
	
			Instance* cylinder_ptr = new Instance(new SolidCylinder(y0, y1, radius));
			cylinder_ptr->translate(-2.75, 0, 0);
			cylinder_ptr->set_material(phong_ptr);
			add_object(cylinder_ptr);

	
			// thick ring (see Exercise 19.26)
		
			y0 = -0.125;
			y1 = 0.125;
			float inner_radius = 0.75;
			float outer_radius = 1.6;
	
			Instance* ring_ptr = new Instance(new ThickRing(y0, y1, inner_radius, outer_radius));
			ring_ptr->rotate_x(90);
			ring_ptr->rotate_y(-30);
			ring_ptr->translate(0.0, 0.85, 0.5);
			ring_ptr->set_material(phong_ptr);
			add_object(ring_ptr);
	
	
			// box
			// the untransformed box is centered on the origin
	
			Point3D p0(-0.75, -1.125, -0.75); 
			Point3D p1(0.75, 1.125, 0.75);
	
			Instance* box_ptr = new Instance(new Box(p0, p1));
			box_ptr->rotate_y(-10);
			box_ptr->translate(2.5, 0.38, -1);
			box_ptr->set_material(phong_ptr);
			add_object(box_ptr);
	
	
			// ground plane
	
			Matte* matte_ptr = new Matte;
			matte_ptr->set_ka(0.5);
			matte_ptr->set_kd(0.85);
			matte_ptr->set_cd(0.25);
	
			Plane* plane_ptr = new Plane(Point3D(0, -0.75, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 157:
		{
			//21.07
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(280);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 15, 50);
			pinhole_ptr->set_lookat(0, 0.75, 0);
			pinhole_ptr->set_view_distance(4000); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
		
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(10, 15, 20);
			light_ptr1->scale_radiance(3.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
		
			Phong* phong_ptr = new Phong;			
			phong_ptr->set_ka(0.3);    
			phong_ptr->set_kd(0.75);
			phong_ptr->set_cd(0.7, 0.5, 0);		// orange
			phong_ptr->set_ks(0.2);
			phong_ptr->set_exp(3);
	
			float bevel_radius = 0.05;  // for all objects
		
			// cylinder
	
			float y0  = -0.75; 
			float y1  = 1.25; 
			float radius = 1.0;
	
			Instance* cylinder_ptr = new Instance(new BeveledCylinder(y0, y1, radius, bevel_radius));
			cylinder_ptr->translate(-2.75, 0, 0);
			cylinder_ptr->set_material(phong_ptr);
			add_object(cylinder_ptr);

			// thick ring
	
			y0 = -0.125;
			y1 = 0.125;
			float inner_radius = 0.75;
			float outer_radius = 1.6;
	
			Instance* ring_ptr = new Instance(new BeveledRing(y0, y1, inner_radius, outer_radius, bevel_radius));
			ring_ptr->rotate_x(90);
			ring_ptr->rotate_y(-30);
			ring_ptr->translate(0.0, 0.85, 0.5);
			ring_ptr->set_material(phong_ptr);
			add_object(ring_ptr);
		
			// box
			// the untransformed box is centered on the origin
	
			Point3D p0(-0.75, -1.125, -0.75);
			Point3D p1(0.75, 1.125, 0.75);
	
			Instance* box_ptr = new Instance(new BeveledBox(p0, p1, bevel_radius));
			box_ptr->rotate_y(-10);
			box_ptr->translate(2.5, 0.38, -1);
			box_ptr->set_material(phong_ptr);
			add_object(box_ptr);
	
			// ground plane
	
			Matte* matte_ptr = new Matte;
			matte_ptr->set_ka(0.5);
			matte_ptr->set_kd(0.85);
			matte_ptr->set_cd(0.25);
	
			Plane* plane_ptr = new Plane(Point3D(0, -0.75, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 158:
		{
			//21.09a
			//The BeveledWedge needs part torus and part annulus, rectangle, beveled cylinder and so on
			int num_samples = 16;

			vp.set_hres(500);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(50, 40, 30);			
			pinhole_ptr->set_lookat(0.25, 0.25, 0);
			pinhole_ptr->set_view_distance(4000);   
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(20, 30, 30);
			light_ptr2->scale_radiance(2.5);   
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.25);    
			matte_ptr1->set_kd(0.65);
			matte_ptr1->set_cd(0.5, 1, 0.5);	  // green
	
			// wedge1 parameters
	
			float y0 = -1.0;		// minimum y value
			float y1 = 2;			// maximum y value
			float r0 = 1.5;			// inner radius
			float r1 = 3;			// outer radius
			float rb = 0.25;		// bevel radius
			float phi0 = 140;		// minimum azimuth angle in degrees
			float phi1 = 350;		// maximum azimuth angle in degrees
	
			BeveledWedge* wedge_ptr1 = new BeveledWedge(y0, y1, r0, r1, rb, phi0, phi1);
			wedge_ptr1->set_material(matte_ptr1);
			add_object(wedge_ptr1);
	
		
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.25);    
			matte_ptr2->set_kd(0.85);
			matte_ptr2->set_cd(1.0, 0.5, 0.0);	// orange
	
			// wedge2 parameters
	
			y0 = -1.5;		// minimum y value
			y1 = 1.25;		// minimum y value
			r0 = 0.5;		// inner radius
			r1 = 4.0;		// outer radius
			rb = 0.075;		// bevel radius
			phi0 = 110;		// minimum azimuth angle in degrees
			phi1 = 130;		// maximum azimuth angle in degrees
		
			BeveledWedge* wedge_ptr2 = new BeveledWedge(y0, y1, r0, r1, rb, phi0, phi1);
			wedge_ptr2->set_material(matte_ptr2);
			add_object(wedge_ptr2);	
		
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_cd(1, 1, 0.0);	// yellow
			matte_ptr3->set_ka(0.25);    
			matte_ptr3->set_kd(0.85);
	
			// wedge3 parameters
	
			y0 = -0.75;		// minimum y value
			y1 = 0.5;		// minimum y value
			r0 = 1.25;		// inner radius
			r1 = 3.75;		// outer radius
			rb = 0.1;		// bevel radius
			phi0 = 0;		// minimum azimuth angle in degrees
			phi1 = 90;		// maximum azimuth angle in degrees
		
			BeveledWedge* wedge_ptr3 = new BeveledWedge(y0, y1, r0, r1, rb, phi0, phi1);
			wedge_ptr3->set_material(matte_ptr3);
			add_object(wedge_ptr3);
			break;
		}
	case 159:
		{
			//21.11a
			//This is based on 21.09a
			if( !CheckFile(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data()))
				return;

			int num_samples = 1;

			vp.set_hres(600);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(50, 50, 30);			
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->set_view_distance(5000);  
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(20, 30, 30);
			light_ptr2->scale_radiance(2.0);   
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
		
			// rosette parameters
	
			int		num_rings = 3;		// maximum of 6
			float	hole_radius = 0.75;
			float	ring_width = 1.0;
			float	rb = 0.1;			// bevel radius
			float	y0 = -0.25;			// minimum y value
			float 	y1 = 0.25;			// minimum y value
	
		
			Rosette* rosette_ptr = new Rosette(num_rings, hole_radius, ring_width, rb, y0, y1);
	
			// put a different random marble texture on each wedge
	
			// blue marble ramp image
	
			Image* image_ptr1 = new Image;						
			image_ptr1->read_ppm_file(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data());
	
			// marble texture parameters
	
			int num_octaves = 4;
			float lacunarity = 2.0;
			float gain = 0.5;
			float perturbation = 3.0;
	
			int num_objects = rosette_ptr->get_num_objects();
	
			for (int j = 0; j < num_objects; j++) {
		
				RampFBmTexture* blue_marble_ptr = new RampFBmTexture(image_ptr1);   // blue marble
				blue_marble_ptr->set_num_octaves(num_octaves);
				blue_marble_ptr->set_lacunarity(lacunarity);
				blue_marble_ptr->set_gain(gain);
				blue_marble_ptr->set_perturbation(perturbation);
		
				// transformed marble texture

				TInstance* wedge_marble_ptr = new TInstance(blue_marble_ptr);
				set_rand_seed(j * 10);
				wedge_marble_ptr->scale(0.25);
				wedge_marble_ptr->rotate_x(20.0 * (2.0 * rand_float() - 1.0));
				wedge_marble_ptr->rotate_y(30.0 * (2.0 * rand_float() - 1.0));
				wedge_marble_ptr->rotate_z(45.0 * (2.0 * rand_float() - 1.0));
				wedge_marble_ptr->translate(10.0 * (2.0 * rand_float() - 1.0), 20.0 * (2.0 * rand_float() - 1.0), 30.0 * (2.0 * rand_float() - 1.0));
		
				// marble material

				SV_Matte* sv_matte_ptr = new SV_Matte;		
				sv_matte_ptr->set_ka(0.35);
				sv_matte_ptr->set_kd(0.75);
				sv_matte_ptr->set_cd(wedge_marble_ptr);
		
				rosette_ptr->store_material(sv_matte_ptr, j);	// store material in the specified wedge

			}
	
			rosette_ptr->setup_cells();
			add_object(rosette_ptr);
			break;
		}
	case 160:
		{
			//21.11b
			if( !CheckFile(QString(ppmfile+"sandstone_ramp1.ppm").toLatin1().data()))	//I can't find Sandstone1.ppm in original files
				return;
			if( !CheckFile(QString(ppmfile+"GrayMarbleRamp.ppm").toLatin1().data()))	//Also I can't find this either
				return;

			int num_samples = 1;

			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			background_color = RGBColour(0.4, 0.4, 0.8);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(20, 12.5, 30);		
			pinhole_ptr->set_lookat(1, 11.6, 0.0);
			pinhole_ptr->set_view_distance(440); 	
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(-20, 30, 30);
			light_ptr2->scale_radiance(3);  
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
		
			// archway parameters
	
			float 	width			= 20.0;		
			float 	height			= 25.0;		
			float 	depth			= 3.0;	
			float 	column_width  	= 4.0;
			int 	num_blocks		= 6;
			int 	num_wedges		= 10;
			float 	bevel_radius	= 0.5;

			Archway* archway_ptr = new Archway(width, height, depth, column_width, num_blocks, num_wedges, bevel_radius);
	
			// put a different random sandstone texture on each archway component
	
			// sandstone parameters
	
			int num_octaves = 4;
			float lacunarity = 2.0;
			float gain = 0.5;
			float perturbation = 0.1; 

			// sandstone ramp image
	
			Image* image_ptr1 = new Image;						
			image_ptr1->read_ppm_file(QString(ppmfile+"sandstone_ramp1.ppm").toLatin1().data());
	
			int num_objects = archway_ptr->get_num_objects();
	
			for (int j = 0; j < num_objects; j++) {
		
				RampFBmTexture* marble_ptr = new RampFBmTexture(image_ptr1); 
				marble_ptr->set_num_octaves(num_octaves);
				marble_ptr->set_lacunarity(lacunarity);
				marble_ptr->set_gain(gain);
				marble_ptr->set_perturbation(perturbation);
		
				// transformed marble texture

				TInstance* wedge_marble_ptr = new TInstance(marble_ptr);
				set_rand_seed(j * 10);
				wedge_marble_ptr->scale(0.5); 
				wedge_marble_ptr->rotate_x(20.0 * (2.0 * rand_float() - 1.0));
				wedge_marble_ptr->rotate_y(30.0 * (2.0 * rand_float() - 1.0));
				wedge_marble_ptr->rotate_z(45.0 * (2.0 * rand_float() - 1.0));
				wedge_marble_ptr->translate(10.0 * (	2.0 * rand_float() - 1.0), 
														20.0 * (2.0 * rand_float() - 1.0), 
														30.0 * (2.0 * rand_float() - 1.0));
		
				// marble material

				SV_Matte* sv_matte_ptr = new SV_Matte;		
				sv_matte_ptr->set_ka(0.35);
				sv_matte_ptr->set_kd(0.85);
				sv_matte_ptr->set_cd(wedge_marble_ptr);
		
				archway_ptr->store_material(sv_matte_ptr, j);	
			}
	
			archway_ptr->setup_cells();
	
			Instance* door_ptr = new Instance(archway_ptr);
			door_ptr->rotate_z(90);
			door_ptr->rotate_y(90);
			door_ptr->translate(0.0, height - width / 2.0, 0.0);
			add_object(door_ptr);
	
			// build a wall of blocks that has the archway going through it 
	
			// wall parameters
	
			float wall_height 		= 40;   // x direction
			float wall_length 		= 100; 	// z direction
			float wall_thickness 	= 3;	// y direction
			int num_blocks_per_row 	= 40;
			int num_rows			= 20;
			float offset			= wall_thickness / 4.0; // wall is offset back from the front of the archway
	
			float block_length = wall_length / num_blocks_per_row;   // z dimension of blocks
			float block_height = wall_height / num_rows;			// x dimension of blocks
			float block_offset	= block_length / 2.0; 
	
			Grid* wall_ptr = new Grid;
	
			for (int k = 0; k < num_rows / 2; k ++) {
				for (int j = 0; j < num_blocks_per_row; j++) {   // first row
		
					Point3D p0(	-(height - width / 2.0) + 2 * k * block_height, 
								-offset, 
								- wall_length / 2.0 + j * block_length);
					Point3D p1(	-(height - width / 2.0) + (2 * k + 1) * block_height, 
								-offset + wall_thickness, 
								- wall_length / 2.0 + (j + 1) * block_length);
					BeveledBox* block_ptr = new BeveledBox(p0, p1, bevel_radius);
			
					// only add the block to the wall if it isn't inside the archway
			
					BBox bbox = block_ptr->get_bounding_box();
			
					bool in_rectangle = 	bbox.z0 < (width / 2.0 - column_width + bevel_radius)
										&& 	bbox.z1 > (-width / 2.0 + column_width - bevel_radius)
										&&	bbox.x0 < 0.0;	
								
					float r_squared = (width / 2.0 - column_width + bevel_radius) * (width / 2.0 - column_width + bevel_radius);
					float d0 = bbox.x0 * bbox.x0 + bbox.z0 * bbox.z0;	// lower left
					float d1 = bbox.x0 * bbox.x0 + bbox.z1 * bbox.z1;	// lower right
					float d2 = bbox.x1 * bbox.x1 + bbox.z1 * bbox.z1;	// upper right	
					float d3 = bbox.x1 * bbox.x1 + bbox.z0 * bbox.z0;	// upper left	
			
					bool in_circle = d0 < r_squared || d1 < r_squared || d2 < r_squared || d3 < r_squared && bbox.x0 > block_height;						
										
					if (!in_rectangle && !in_circle)																					
						wall_ptr->add_object(block_ptr);		
				}
		
				for (int j = 0; j < num_blocks_per_row; j++) {   // second row - offset in the z direction by half a block length

					Point3D p0(	-(height - width / 2.0) + (2 * k + 1) * block_height, 
								-offset, 
								- wall_length / 2.0 + j * block_length + block_offset);
					Point3D p1(	-(height - width / 2.0) + (2 * k + 2) * block_height, 
								-offset + wall_thickness, 
								-wall_length / 2.0 + (j + 1) * block_length + block_offset);
					BeveledBox* block_ptr = new BeveledBox(p0, p1, bevel_radius);
			
					// only add the block to the wall if it isn't inside the archway
			
					BBox bbox = block_ptr->get_bounding_box();
			
					bool in_rectangle = 	bbox.z0 < (width / 2.0 - column_width + bevel_radius)
										&& 	bbox.z1 > (-width / 2.0 + column_width - bevel_radius)
										&&	bbox.x0 < 0.0;									
										
					float r_squared = (width / 2.0 - column_width + bevel_radius) * (width / 2.0 - column_width + bevel_radius);
					float d0 = bbox.x0 * bbox.x0 + bbox.z0 * bbox.z0;	// lower left
					float d1 = bbox.x0 * bbox.x0 + bbox.z1 * bbox.z1;	// lower right
					float d2 = bbox.x1 * bbox.x1 + bbox.z1 * bbox.z1;	// upper right	
					float d3 = bbox.x1 * bbox.x1 + bbox.z0 * bbox.z0;	// upper left	
			
					bool in_circle = d0 < r_squared || d1 < r_squared || d2 < r_squared || d3 < r_squared && bbox.x0 > block_height;							
										
					if (!in_rectangle && !in_circle)																					
						wall_ptr->add_object(block_ptr);				
				}		
			}
	
	
			// use a different random marble texture on each block
			// the marble paramters are the same as the sandstone's, except for the perturbation:
	
			perturbation = 3.0; 
	
			// gray marble ramp image
	
			Image* image_ptr2 = new Image;						
			image_ptr2->read_ppm_file(QString(ppmfile+"GrayMarbleRamp.ppm").toLatin1().data());
	
			num_objects = wall_ptr->get_num_objects();
	
			for (int j = 0; j < num_objects; j++) {
		
				RampFBmTexture* marble_ptr = new RampFBmTexture(image_ptr2);  
				marble_ptr->set_num_octaves(num_octaves);
				marble_ptr->set_lacunarity(lacunarity);
				marble_ptr->set_gain(gain);
				marble_ptr->set_perturbation(perturbation);
		
				// transformed marble texture

				TInstance* wedge_marble_ptr = new TInstance(marble_ptr);
				set_rand_seed(j * 10);
				wedge_marble_ptr->scale(0.25);
				wedge_marble_ptr->rotate_x(20.0 * (2.0 * rand_float() - 1.0));
				wedge_marble_ptr->rotate_y(30.0 * (2.0 * rand_float() - 1.0));
				wedge_marble_ptr->rotate_z(45.0 * (2.0 * rand_float() - 1.0));
				wedge_marble_ptr->translate(10.0 * (2.0 * rand_float() - 1.0), 
											20.0 * (2.0 * rand_float() - 1.0), 
											30.0 * (2.0 * rand_float() - 1.0));
		
				// marble material

				SV_Matte* sv_matte_ptr = new SV_Matte;		
				sv_matte_ptr->set_ka(0.25);
				sv_matte_ptr->set_kd(0.5);
				sv_matte_ptr->set_cd(wedge_marble_ptr);
		
				wall_ptr->store_material(sv_matte_ptr, j);	
			}
	
			wall_ptr->setup_cells();
	
			Instance* vertical_wall_ptr = new Instance(wall_ptr);
			vertical_wall_ptr->rotate_z(90);
			vertical_wall_ptr->rotate_y(90);
			vertical_wall_ptr->translate(0.0, height - width / 2.0, 0.0);
			add_object(vertical_wall_ptr);
	
	
			// ground plane
	
			Matte* matte_ptr = new Matte;
			matte_ptr->set_ka(0.25);
			matte_ptr->set_kd(0.5);
			matte_ptr->set_cd(0.35, 0.75, 0.35);
	
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 161:
		{
			//21.12
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(350);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 15.75, 50);
			pinhole_ptr->set_lookat(0, 2, 0);	
			pinhole_ptr->set_view_distance(3500); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);

			Directional* light_ptr = new Directional;
			light_ptr->set_direction(10, 15, 20);
			light_ptr->scale_radiance(3.0);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
		
			Phong* phong_ptr = new Phong;			
			phong_ptr->set_ka(0.3);    
			phong_ptr->set_kd(0.75);
			phong_ptr->set_cd(0.7, 0.5, 0);		// orange
			phong_ptr->set_ks(0.15);
			phong_ptr->set_exp(3.0);
	
	
			// commmon cylinder parameters
	
			float radius 		= 1.0;
			float bevel_radius 	= 0.25;
		
			// short cylinder
	
			float y0 = 0.0;
			float y1 = 2.0;
	
			Instance* cylinder_ptr1 = new Instance(new BeveledCylinder(y0, y1, radius, bevel_radius));
			cylinder_ptr1->translate(-2.75, 0, 0);
			cylinder_ptr1->set_material(phong_ptr);
			add_object(cylinder_ptr1);
	
			// tall cylinder
	
			y0 = 0.0;
			y1 = 4.0;
	
			BeveledCylinder* cylinder_ptr2 = new BeveledCylinder(y0, y1, radius, bevel_radius);
			cylinder_ptr2->set_material(phong_ptr);
			add_object(cylinder_ptr2);
	
			// scaled cylinder
	
			y0 = 0.0;
			y1 = 2.0;
	
			Instance* cylinder_ptr3 = new Instance(new BeveledCylinder(y0, y1, radius, bevel_radius));
			cylinder_ptr3->scale(1, 2, 1);
			cylinder_ptr3->translate(2.75, 0, 0);
			cylinder_ptr3->set_material(phong_ptr);
			add_object(cylinder_ptr3);

			// ground plane
	
			Matte* matte_ptr = new Matte;
			matte_ptr->set_cd(1);
			matte_ptr->set_ka(0.25);
			matte_ptr->set_kd(1);
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 162:
		{
			//21.13
			int num_samples = 1;
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);

			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 15, 50);
			pinhole_ptr->set_lookat(-2.75, 0.25, 0);
			pinhole_ptr->set_view_distance(7000); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
		
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(10, 15, 20);
			light_ptr1->scale_radiance(3.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
		
			Phong* phong_ptr = new Phong;			
			phong_ptr->set_ka(0.3);    
			phong_ptr->set_kd(1.0);
			phong_ptr->set_cd(0.7, 0.5, 0);		// orange
			phong_ptr->set_ks(0.4);
			phong_ptr->set_kd(0.75);
			phong_ptr->set_ks(0.2);
			phong_ptr->set_exp(3.0);
			
			// cylinder
	
			float y0 = -0.75;
			float y1 = 1.25;
			float radius = 1.0;
			float bevel_radius = 1.0;
		
			Instance* cylinder_ptr = new Instance(new BeveledCylinder(y0, y1, radius, bevel_radius));
			cylinder_ptr->translate(-2.75, 0.0, 0.0);
			cylinder_ptr->set_material(phong_ptr);
			add_object(cylinder_ptr);
	
			// ground plane
	
			Matte* matte_ptr = new Matte;
			matte_ptr->set_ka(0.5);
			matte_ptr->set_kd(0.85);
			matte_ptr->set_cd(0.25);
	
			Plane* plane_ptr = new Plane(Point3D(0, -0.75, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 163:
		{
			//21.14
			int num_samples = 16;
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(4, 3.25, 5);
			pinhole_ptr->set_lookat(0.85, 0.0, 0);
			pinhole_ptr->set_view_distance(900); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
		
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(20, 10, 15);
			light_ptr1->scale_radiance(2.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
			
	
			// ring parameters	
		
			Point3D centre(0);
			float y0 = -0.25;
			float y1 = 0.25;
			float inner_radius = 0.5;
			float outer_radius = 1.0;
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.3);    
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0, 1, 1);  // cyan
	
			//Notice that the Annulus class have a thickness parameter, but there are some mistake in original excercises, here we change the parameter into thickness
			Annulus* bottom_ptr = new Annulus(Point3D(0, y0, 0), Normal(0, -1, 0), inner_radius, outer_radius-inner_radius); 
			bottom_ptr->set_material(matte_ptr1);
	
			Annulus* top_ptr = new Annulus(Point3D(0, y1, 0),  Normal(0, 1, 0), inner_radius, outer_radius-inner_radius); 
			top_ptr->set_material(matte_ptr1);
	
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.4);    
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(1, 1, 0);   // yellow
	
			OpenCylinder* outer_wall_ptr = new OpenCylinder(y0, y1, outer_radius); 
			outer_wall_ptr->set_material(matte_ptr2);
	
		
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(0.4);    
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(1, 1, 0);   // yellow
	
			OpenCylinder* inner_wall_ptr = new OpenCylinder(y0, y1, inner_radius); 
			inner_wall_ptr->set_material(matte_ptr3);
	
	
			// construct the ring as a compound object
	
			Compound* ring_ptr = new Compound;
			ring_ptr->add_object(bottom_ptr); 
			ring_ptr->add_object(top_ptr);
			ring_ptr->add_object(outer_wall_ptr);
			ring_ptr->add_object(inner_wall_ptr);
	
			// use nested instances for the transformed ring
	
			Instance* rotated_ring_ptr = new Instance(ring_ptr);
			rotated_ring_ptr->rotate_z(-45);
	
			Instance* translated_ring_ptr = new Instance(rotated_ring_ptr);
			translated_ring_ptr->translate(1, 0, 0);
			add_object(translated_ring_ptr);
	
			// sphere
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(0.15);    
			matte_ptr4->set_kd(0.9);
			matte_ptr4->set_cd(1, 0.75, 0);
	
			Sphere* sphere_ptr = new Sphere(Point3D(2, 1, 0.5), 0.2);
			sphere_ptr->set_material(matte_ptr4);
			add_object(sphere_ptr);
	
			// ground plane
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(0.15);    
			matte_ptr5->set_kd(0.75);
			matte_ptr5->set_cd(1.0);
	
			Plane* plane_ptr = new Plane(Point3D(0, -2, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr5);
			add_object(plane_ptr);
			break;
		}
	case 164:
		{
			//21.15
			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(400); 
			vp.set_samples(num_samples);	
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 15, 20);
			pinhole_ptr->set_lookat(-0.5, -0.5, 0); 
			pinhole_ptr->set_view_distance(800);
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(30, 30, 25);  
			light_ptr->scale_radiance(3.0);  
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// ellipsoids
				
			float 	x0 					= -5.0;					// minimum x center coordinate
			float 	z0 					= -5.0;					// minimum z center coordinate
			float 	x1 					= 5.0;					// maximum x center coordinate
			float 	z1 					= 5.0;					// maximum z center coordinate
			int 	num_x_ellipsoids	= 5;					// number of ellipsoids in the x direction
			int 	num_z_ellipsoids	= 5;  					// number of ellipsoids in the z direction
			float 	radius 				= 1.0;   				// common sphere radius
			float	x_spacing			= (x1 - x0) / (num_x_ellipsoids - 1); // center spacing in x direction
			float	z_spacing			= (z1 - z0) / (num_z_ellipsoids - 1); // center spacing in x direction
	
			Sphere* sphere_ptr = new Sphere;
			set_rand_seed(1000);
	
			for (int iz = 0; iz < num_z_ellipsoids; iz++) {
				for (int ix = 0; ix < num_x_ellipsoids; ix++) {
					Phong* phong_ptr = new Phong;	
					phong_ptr->set_ka(0.35);  
					phong_ptr->set_kd(0.75);
					phong_ptr->set_ks(0.1);  
					phong_ptr->set_exp(20.0);
					phong_ptr->set_cd(rand_float(), rand_float(), rand_float());
			
					float xc = x0 + ix * x_spacing;  	// ellipsoid center x coordinate
					float zc = z0 + iz * z_spacing;		// ellipsoid center z coordinate
			
					Instance* ellipsoid_ptr = new Instance(sphere_ptr);
					ellipsoid_ptr->scale(1.0, 4.0 * rand_float(), 1.0);
					ellipsoid_ptr->translate(xc, 0, zc);
					ellipsoid_ptr->set_material(phong_ptr);
					add_object(ellipsoid_ptr);
				}
			}
	
			// ground plane 
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.75);
			matte_ptr->set_kd(0.5);
			matte_ptr->set_cd(0.85);  
	
			Plane* plane_ptr = new Plane(Point3D(0, -1, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 165:
		{
			//21.16b
			//Notice that the round rimmed bowl must have a part torus on the bound of bowl, not whole shape.
			int num_samples = 16;
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(1);
	
			tracer_ptr = new RayCast(this);
		
			Pinhole* camera_ptr = new Pinhole;
			camera_ptr->set_eye(1, 2, 5);       
			camera_ptr->set_lookat(0, -0.1, 0);
			camera_ptr->set_view_distance(700); 
			camera_ptr->compute_uvw();
			set_camera(camera_ptr);
		
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(20, 15, 15);    
			light_ptr1->scale_radiance(3.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			// bowl
		
			Phong* phong_ptr = new Phong;				
			phong_ptr->set_ka(0.25);    
			phong_ptr->set_kd(0.5);
			phong_ptr->set_cd(0.53, 0.67, 0.34);	// yellow green	
			phong_ptr->set_ks(0.1);
			phong_ptr->set_exp(50);

			float inner_radius = 1.0;
			float outer_radius = 1.2;
			float wall_thickness = 0.2;
			float opening_angle = 120;  // in degrees
	
			RoundRimmedBowl* bowl_ptr = new RoundRimmedBowl(inner_radius, outer_radius, opening_angle);
			bowl_ptr->set_material(phong_ptr);
			add_object(bowl_ptr);
	
	
			// ground plane with checker
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(1);		
			checker_ptr->set_color1(white);  
			checker_ptr->set_color2(0.75);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.35);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(checker_ptr);

			Plane* plane_ptr = new Plane(Point3D(0, -1.01, 0), Normal(0, 1, 0)); 
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);	
			break;
		}
	case 166:
		{
			//21.17
			if( !CheckFile(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data()))
				return;

			int num_samples = 1;

			vp.set_hres(600);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(50, 50, 30);			
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->set_view_distance(5000);  
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(20, 30, 30);
			light_ptr2->scale_radiance(2.0);   
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
		
			// rosette parameters
	
			int		num_rings = 3;		// maximum of 6
			float	hole_radius = 0.75;
			float	ring_width = 1.0;
			float	rb = 0.1;			// bevel radius
			float	y0 = -0.25;			// minimum y value
			float 	y1 = 0.25;			// minimum y value
	
		
			Rosette* rosette_ptr = new Rosette(num_rings, hole_radius, ring_width, rb, y0, y1);
	
			// put a different random marble texture on each wedge
	
			// blue marble ramp image
	
			Image* image_ptr1 = new Image;						
			image_ptr1->read_ppm_file(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data());
	
			// marble texture parameters
	
			int num_octaves = 4;
			float lacunarity = 2.0;
			float gain = 0.5;
			float perturbation = 3.0;
	
			int num_objects = rosette_ptr->get_num_objects();
	
			for (int j = 0; j < num_objects; j++) {
		
				RampFBmTexture* blue_marble_ptr = new RampFBmTexture(image_ptr1);   // blue marble
				blue_marble_ptr->set_num_octaves(num_octaves);
				blue_marble_ptr->set_lacunarity(lacunarity);
				blue_marble_ptr->set_gain(gain);
				blue_marble_ptr->set_perturbation(perturbation);
		
				// transformed marble texture

				TInstance* wedge_marble_ptr = new TInstance(blue_marble_ptr);
				set_rand_seed(j * 10);
				wedge_marble_ptr->scale(0.25);
				wedge_marble_ptr->rotate_x(20.0 * (2.0 * rand_float() - 1.0));
				wedge_marble_ptr->rotate_y(30.0 * (2.0 * rand_float() - 1.0));
				wedge_marble_ptr->rotate_z(45.0 * (2.0 * rand_float() - 1.0));
				wedge_marble_ptr->translate(10.0 * (2.0 * rand_float() - 1.0), 20.0 * (2.0 * rand_float() - 1.0), 30.0 * (2.0 * rand_float() - 1.0));
		
				// marble material

				SV_Matte* sv_matte_ptr = new SV_Matte;		
				sv_matte_ptr->set_ka(0.35);
				sv_matte_ptr->set_kd(0.75);
				sv_matte_ptr->set_cd(wedge_marble_ptr);
		
				rosette_ptr->store_material(sv_matte_ptr, j);	// store material in the specified wedge
			}
	
			rosette_ptr->setup_cells();
			add_object(rosette_ptr);
			break;
		}
	case 167:
		{
			//22p1
			int num_samples = 1;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0.0, 0.0, 0.9);
			pinhole_ptr->set_lookat(0, 0, -100);
			pinhole_ptr->set_view_distance(150); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;   
			light_ptr->set_direction(0, 0, 1);				
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
			int num_spheres = 1000;
			float volume = 0.1 / num_spheres;
			float radius = pow(0.75 * volume / 3.14159, 0.333333);
	
			set_rand_seed(15);
	
			Grid* grid_ptr = new Grid;  
	
			for (int j = 0; j < num_spheres; j++) {
				Matte* matte_ptr = new Matte;
				matte_ptr->set_ka(0.25);
				matte_ptr->set_kd(0.75);
				matte_ptr->set_cd(RGBColour(rand_float(), rand_float(), rand_float()));
		
				Sphere*	sphere_ptr = new Sphere; 
				sphere_ptr->set_radius(radius);
				sphere_ptr->set_center(	1.0 - 2.0 * rand_float(), 
										1.0 - 2.0 * rand_float(), 
										1.0 - 2.0 * rand_float());	
				sphere_ptr->set_material(matte_ptr);
				grid_ptr->add_object(sphere_ptr);
			}	

			grid_ptr->setup_cells();
			add_object(grid_ptr);
			break;
		}
	case 168:
		{
			//22.09a
			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);

			Orthographic* orthographic_ptr = new Orthographic;
			vp.set_pixel_size(0.0085);
			orthographic_ptr->set_eye(7, 5, 5); 
			orthographic_ptr->set_lookat(0, 0, 0);
			orthographic_ptr->compute_uvw(); 
			set_camera(orthographic_ptr);
	
	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(1, 0, 0);    				// from the +ve x direction     
			light_ptr1->scale_radiance(1);   
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(0, 1, 0);    				// from the +ve y direction     
			light_ptr2->scale_radiance(2);   
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);	
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(0, 0, 1);    				// from the +ve z direction      
			light_ptr3->scale_radiance(1.5);   
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
			Directional* light_ptr4 = new Directional;
			light_ptr4->set_direction(-1, 0, 0);    			// from the -ve x direction     
			light_ptr4->scale_radiance(1);   
			light_ptr4->set_shadows(true);
			add_light(light_ptr4);
	
			Directional* light_ptr5 = new Directional;
			light_ptr5->set_direction(0, -1, 0);    			// from the -ve y direction     
			light_ptr5->scale_radiance(2);   
			light_ptr5->set_shadows(true);
			add_light(light_ptr5);	
	
			Directional* light_ptr6 = new Directional;
			light_ptr6->set_direction(0, 0, -1);    			// from the -ve z direction      
			light_ptr6->scale_radiance(1.5);   
			light_ptr6->set_shadows(true);
			add_light(light_ptr6);
	
	
			Grid* grid_ptr = new Grid;

			// eight boxes
	
			// bottom four
	
			float bottom_size = 0.5;
			Vector3D diagonal(bottom_size, bottom_size, bottom_size);
			Point3D p0;
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.25);
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.5);   // gray
		
			p0 = Point3D(-1, -1, -1);
			Box* box_ptr1 = new Box(p0, p0 + diagonal); 
			box_ptr1->set_material(matte_ptr1);
			grid_ptr->add_object(box_ptr1);
	
		
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(0.25);
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(1, 0, 0);  // red
	
			p0 = Point3D(-1, -1, 1 - bottom_size);
			Box* box_ptr2 = new Box(p0, p0 + diagonal); 
			box_ptr2->set_material(matte_ptr2);
			grid_ptr->add_object(box_ptr2);
	
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.25);
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(1, 1, 0);  // yellow
	
			p0 = Point3D(1 - bottom_size, -1, 1 - bottom_size);
			Box* box_ptr3 = new Box(p0, p0 + diagonal); 
			box_ptr3->set_material(matte_ptr3);
			grid_ptr->add_object(box_ptr3);
	
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(0.25);
			matte_ptr4->set_kd(0.75);
			matte_ptr4->set_cd(0.2, 0.6, 0.4);  // green
	
			p0 = Point3D(1 - bottom_size, -1, -1);
			Box* box_ptr4 = new Box(p0, p0 + diagonal); 
			box_ptr4->set_material(matte_ptr4);
			grid_ptr->add_object(box_ptr4);
	
	
	
			// top four
	
			float top_size = 0.35;
			diagonal = Vector3D(top_size, top_size, top_size);
	
			Matte* matte_ptr5 = new Matte;
			matte_ptr5->set_ka(0.25);
			matte_ptr5->set_kd(0.75);
			matte_ptr5->set_cd(0.27, 0.36, 1.0);  // blue
	
			p0 = Point3D(-1, 1 - top_size, -1);
			Box* box_ptr5 = new Box(p0, p0 + diagonal); 
			box_ptr5->set_material(matte_ptr5);
			grid_ptr->add_object(box_ptr5);

	
			Matte* matte_ptr6 = new Matte;
			matte_ptr6->set_ka(0.25);
			matte_ptr6->set_kd(0.75);
			matte_ptr6->set_cd(0.75, 0, 0.75);  // majenta
	
			p0 = Point3D(-1, 1 - top_size, 1 - top_size);
			Box* box_ptr6 = new Box(p0, p0 + Vector3D(0.25, top_size, top_size)); 
			box_ptr6->set_material(matte_ptr6);
			grid_ptr->add_object(box_ptr6);
	
	
			Matte* matte_ptr7 = new Matte;
			matte_ptr7->set_ka(0.25);
			matte_ptr7->set_kd(0.75);
			matte_ptr7->set_cd(1, 1, 1);  // white
	
			p0 = Point3D(1 - 0.25, 1 - 0.25, 1 - 0.25);
			Box* box_ptr7 = new Box(p0, p0 + Vector3D(0.25)); 
			box_ptr7->set_material(matte_ptr7);
			grid_ptr->add_object(box_ptr7);
	
	
			Matte* matte_ptr8 = new Matte;
			matte_ptr8->set_ka(0.25);
			matte_ptr8->set_kd(0.75);
			matte_ptr8->set_cd(0, 0.75, 0.75);  // cyan
	
			p0 = Point3D(1 - top_size, 1 - top_size, -1);
			Box* box_ptr8 = new Box(p0, p0 + Vector3D(top_size, top_size, 0.25)); 
			box_ptr8->set_material(matte_ptr8);
			grid_ptr->add_object(box_ptr8);
	
			grid_ptr->setup_cells();
			add_object(grid_ptr);
			break;
		}
	case 169:
		{
			//22.10a
			int num_samples = 16;
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);

			Orthographic* orthographic_ptr = new Orthographic;
			vp.set_pixel_size(0.006);	
			orthographic_ptr->set_eye(0, 0, 0); 
			orthographic_ptr->set_lookat(0, -100, 0);
			orthographic_ptr->compute_uvw(); 
			set_camera(orthographic_ptr);
	
		
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(1, 0, 0);    				// from the +ve x direction     
			light_ptr1->scale_radiance(1);   
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(0, 1, 0);    				// from the +ve y direction     
			light_ptr2->scale_radiance(2);   
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);	
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(0, 0, 1);    				// from the +ve z direction      
			light_ptr3->scale_radiance(1.5);   
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			Directional* light_ptr4 = new Directional;
			light_ptr4->set_direction(-1, 0, 0);    			// from the -ve x direction     
			light_ptr4->scale_radiance(1);   
			light_ptr4->set_shadows(true);
			add_light(light_ptr4);
	
			Directional* light_ptr5 = new Directional;
			light_ptr5->set_direction(0, -1, 0);    			// from the -ve y direction     
			light_ptr5->scale_radiance(2);   
			light_ptr5->set_shadows(true);
			add_light(light_ptr5);	
	
			Directional* light_ptr6 = new Directional;
			light_ptr6->set_direction(0, 0, -1);    			// from the -ve z direction      
			light_ptr6->scale_radiance(1.5);   
			light_ptr6->set_shadows(true);
			add_light(light_ptr6);
	
	
			Grid* grid_ptr = new Grid;
	
			// eight boxes
	
			// bottom four
	
			float bottom_size = 0.5;
			Vector3D diagonal(bottom_size, bottom_size, bottom_size);
			Point3D p0;
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.25);
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.5);   // gray
		
			p0 = Point3D(-1, -1, -1);
			Box* box_ptr1 = new Box(p0, p0 + diagonal); 
			box_ptr1->set_material(matte_ptr1);
			grid_ptr->add_object(box_ptr1);
	
		
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(0.25);
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(1, 0, 0);  // red
	
			p0 = Point3D(-1, -1, 1 - bottom_size);
			Box* box_ptr2 = new Box(p0, p0 + diagonal); 
			box_ptr2->set_material(matte_ptr2);
			grid_ptr->add_object(box_ptr2);
	
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.25);
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(1, 1, 0);  // yellow
	
			p0 = Point3D(1 - bottom_size, -1, 1 - bottom_size);
			Box* box_ptr3 = new Box(p0, p0 + diagonal); 
			box_ptr3->set_material(matte_ptr3);
			grid_ptr->add_object(box_ptr3);
	
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(0.25);
			matte_ptr4->set_kd(0.75);
			matte_ptr4->set_cd(0.2, 0.6, 0.4);  // green
	
			p0 = Point3D(1 - bottom_size, -1, -1);
			Box* box_ptr4 = new Box(p0, p0 + diagonal); 
			box_ptr4->set_material(matte_ptr4);
			grid_ptr->add_object(box_ptr4);
	
	
	
			// top four
	
			float top_size = 0.35;
			diagonal = Vector3D(top_size, top_size, top_size);
	
			Matte* matte_ptr5 = new Matte;
			matte_ptr5->set_ka(0.25);
			matte_ptr5->set_kd(0.75);
			matte_ptr5->set_cd(0.27, 0.36, 1.0);  // blue
	
			p0 = Point3D(-1, 1 - top_size, -1);
			Box* box_ptr5 = new Box(p0, p0 + diagonal); 
			box_ptr5->set_material(matte_ptr5);
			grid_ptr->add_object(box_ptr5);

	
			Matte* matte_ptr6 = new Matte;
			matte_ptr6->set_ka(0.25);
			matte_ptr6->set_kd(0.75);
			matte_ptr6->set_cd(0.75, 0, 0.75);  // majenta
	
			p0 = Point3D(-1, 1 - top_size, 1 - top_size);
			Box* box_ptr6 = new Box(p0, p0 + Vector3D(0.25, top_size, top_size)); 
			box_ptr6->set_material(matte_ptr6);
			grid_ptr->add_object(box_ptr6);
	
	
			Matte* matte_ptr7 = new Matte;
			matte_ptr7->set_ka(0.25);
			matte_ptr7->set_kd(0.75);
			matte_ptr7->set_cd(1, 1, 1);  // white
	
			p0 = Point3D(1 - 0.25, 1 - 0.25, 1 - 0.25);
			Box* box_ptr7 = new Box(p0, p0 + Vector3D(0.25)); 
			box_ptr7->set_material(matte_ptr7);
			grid_ptr->add_object(box_ptr7);
	
	
			Matte* matte_ptr8 = new Matte;
			matte_ptr8->set_ka(0.25);
			matte_ptr8->set_kd(0.75);
			matte_ptr8->set_cd(0, 0.75, 0.75);  // cyan
	
			p0 = Point3D(1 - top_size, 1 - top_size, -1);
			Box* box_ptr8 = new Box(p0, p0 + Vector3D(top_size, top_size, 0.25)); 
			box_ptr8->set_material(matte_ptr8);
			grid_ptr->add_object(box_ptr8);
	
			grid_ptr->setup_cells();
			add_object(grid_ptr);		
			break;
		}
	case 170:
		{
			//22.10b
			int num_samples = 16;
	
			vp.set_hres(800);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Spherical* spherical_ptr = new Spherical;
			spherical_ptr->set_eye(0, 0, 0);       
			spherical_ptr->set_lookat(-100, 0, 0);
			spherical_ptr->set_horizontal_fov(360);     
			spherical_ptr->set_vertical_fov(180);
			spherical_ptr->compute_uvw();
			set_camera(spherical_ptr);

	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(1, 0, 0);    				// from the +ve x direction     
			light_ptr1->scale_radiance(1);   
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(0, 1, 0);    				// from the +ve y direction     
			light_ptr2->scale_radiance(2);   
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);	
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(0, 0, 1);    				// from the +ve z direction      
			light_ptr3->scale_radiance(1.5);   
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			Directional* light_ptr4 = new Directional;
			light_ptr4->set_direction(-1, 0, 0);    			// from the -ve x direction     
			light_ptr4->scale_radiance(1);   
			light_ptr4->set_shadows(true);
			add_light(light_ptr4);
	
			Directional* light_ptr5 = new Directional;
			light_ptr5->set_direction(0, -1, 0);    			// from the -ve y direction     
			light_ptr5->scale_radiance(2);   
			light_ptr5->set_shadows(true);
			add_light(light_ptr5);	
	
			Directional* light_ptr6 = new Directional;
			light_ptr6->set_direction(0, 0, -1);    			// from the -ve z direction      
			light_ptr6->scale_radiance(1.5);   
			light_ptr6->set_shadows(true);
			add_light(light_ptr6);
	
	
			Grid* grid_ptr = new Grid;

			// eight boxes
	
			// bottom four
	
			float bottom_size = 0.5;
			Vector3D diagonal(bottom_size, bottom_size, bottom_size);
			Point3D p0;
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.25);
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.5);   // gray
		
			p0 = Point3D(-1, -1, -1);
			Box* box_ptr1 = new Box(p0, p0 + diagonal); 
			box_ptr1->set_material(matte_ptr1);
			grid_ptr->add_object(box_ptr1);
	
		
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(0.25);
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(1, 0, 0);  // red
	
			p0 = Point3D(-1, -1, 1 - bottom_size);
			Box* box_ptr2 = new Box(p0, p0 + diagonal); 
			box_ptr2->set_material(matte_ptr2);
			grid_ptr->add_object(box_ptr2);
	
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.25);
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(1, 1, 0);  // yellow
	
			p0 = Point3D(1 - bottom_size, -1, 1 - bottom_size);
			Box* box_ptr3 = new Box(p0, p0 + diagonal); 
			box_ptr3->set_material(matte_ptr3);
			grid_ptr->add_object(box_ptr3);
	
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(0.25);
			matte_ptr4->set_kd(0.75);
			matte_ptr4->set_cd(0.2, 0.6, 0.4);  // green
	
			p0 = Point3D(1 - bottom_size, -1, -1);
			Box* box_ptr4 = new Box(p0, p0 + diagonal); 
			box_ptr4->set_material(matte_ptr4);
			grid_ptr->add_object(box_ptr4);
	
	
			// top four
	
			float top_size = 0.35;
			diagonal = Vector3D(top_size, top_size, top_size);
	
			Matte* matte_ptr5 = new Matte;
			matte_ptr5->set_ka(0.25);
			matte_ptr5->set_kd(0.75);
			matte_ptr5->set_cd(0.27, 0.36, 1.0);  // blue
	
			p0 = Point3D(-1, 1 - top_size, -1);
			Box* box_ptr5 = new Box(p0, p0 + diagonal); 
			box_ptr5->set_material(matte_ptr5);
			grid_ptr->add_object(box_ptr5);

	
			Matte* matte_ptr6 = new Matte;
			matte_ptr6->set_ka(0.25);
			matte_ptr6->set_kd(0.75);
			matte_ptr6->set_cd(0.75, 0, 0.75);  // majenta
	
			p0 = Point3D(-1, 1 - top_size, 1 - top_size);
			Box* box_ptr6 = new Box(p0, p0 + Vector3D(0.25, top_size, top_size)); 
			box_ptr6->set_material(matte_ptr6);
			grid_ptr->add_object(box_ptr6);
	
	
			Matte* matte_ptr7 = new Matte;
			matte_ptr7->set_ka(0.25);
			matte_ptr7->set_kd(0.75);
			matte_ptr7->set_cd(1, 1, 1);  // white
	
			p0 = Point3D(1 - 0.25, 1 - 0.25, 1 - 0.25);
			Box* box_ptr7 = new Box(p0, p0 + Vector3D(0.25)); 
			box_ptr7->set_material(matte_ptr7);
			grid_ptr->add_object(box_ptr7);
	
	
			Matte* matte_ptr8 = new Matte;
			matte_ptr8->set_ka(0.25);
			matte_ptr8->set_kd(0.75);
			matte_ptr8->set_cd(0, 0.75, 0.75);  // cyan
	
			p0 = Point3D(1 - top_size, 1 - top_size, -1);
			Box* box_ptr8 = new Box(p0, p0 + Vector3D(top_size, top_size, 0.25)); 
			box_ptr8->set_material(matte_ptr8);
			grid_ptr->add_object(box_ptr8);
	
			grid_ptr->setup_cells();
			add_object(grid_ptr);	
			break;
		}
	case 171:
		{
			//22.11a
			int num_samples = 1;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 20);
			pinhole_ptr->set_lookat(0, 0, 0);
			pinhole_ptr->set_view_distance(3600); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;   
			light_ptr->set_direction(-10, 20, 20);				
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
			int num_spheres = 1000;			// for Figure 22.11(a)
		//	int num_spheres = 10000;		// for Figure 22.11(b)
		//	int num_spheres = 100000;		// for Figure 22.11(c)
		//	int num_spheres = 1000000;		// for Figure 22.11(d)			
	
			float volume = 0.1 / num_spheres;
			float radius = pow(0.75 * volume / 3.14159, 0.333333);
	
			set_rand_seed(15);
	
			Grid* grid_ptr = new Grid;  
	
			for (int j = 0; j < num_spheres; j++) {
				Matte* matte_ptr = new Matte;
				matte_ptr->set_ka(0.25);
				matte_ptr->set_kd(0.75);
				matte_ptr->set_cd(rand_float(), rand_float(), rand_float());
		
				Sphere*	sphere_ptr = new Sphere; 
				sphere_ptr->set_radius(radius);
				sphere_ptr->set_center(	1.0 - 2.0 * rand_float(), 
										1.0 - 2.0 * rand_float(), 
										1.0 - 2.0 * rand_float());	
				sphere_ptr->set_material(matte_ptr);
				grid_ptr->add_object(sphere_ptr);
			}	

			grid_ptr->setup_cells();
			add_object(grid_ptr);
			break;
		}
	case 172:
		{
			//22.11b
			int num_samples = 1;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 20);
			pinhole_ptr->set_lookat(0, 0, 0);
			pinhole_ptr->set_view_distance(3600); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;   
			light_ptr->set_direction(-10, 20, 20);				
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
		//	int num_spheres = 1000;			// for Figure 22.11(a)
			int num_spheres = 10000;		// for Figure 22.11(b)
		//	int num_spheres = 100000;		// for Figure 22.11(c)
		//	int num_spheres = 1000000;		// for Figure 22.11(d)			
	
			float volume = 0.1 / num_spheres;
			float radius = pow(0.75 * volume / 3.14159, 0.333333);
	
			set_rand_seed(15);
	
			Grid* grid_ptr = new Grid;  
	
			for (int j = 0; j < num_spheres; j++) {
				Matte* matte_ptr = new Matte;
				matte_ptr->set_ka(0.25);
				matte_ptr->set_kd(0.75);
				matte_ptr->set_cd(rand_float(), rand_float(), rand_float());
		
				Sphere*	sphere_ptr = new Sphere; 
				sphere_ptr->set_radius(radius);
				sphere_ptr->set_center(	1.0 - 2.0 * rand_float(), 
										1.0 - 2.0 * rand_float(), 
										1.0 - 2.0 * rand_float());	
				sphere_ptr->set_material(matte_ptr);
				grid_ptr->add_object(sphere_ptr);
			}	

			grid_ptr->setup_cells();
			add_object(grid_ptr);
			break;
		}
	case 173:
		{
			//22.11c
			int num_samples = 1;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 20);
			pinhole_ptr->set_lookat(0, 0, 0);
			pinhole_ptr->set_view_distance(3600); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;   
			light_ptr->set_direction(-10, 20, 20);				
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
		//	int num_spheres = 1000;			// for Figure 22.11(a)
		//	int num_spheres = 10000;		// for Figure 22.11(b)
			int num_spheres = 100000;		// for Figure 22.11(c)
		//	int num_spheres = 1000000;		// for Figure 22.11(d)			
	
			float volume = 0.1 / num_spheres;
			float radius = pow(0.75 * volume / 3.14159, 0.333333);
	
			set_rand_seed(15);
	
			Grid* grid_ptr = new Grid;  
	
			for (int j = 0; j < num_spheres; j++) {
				Matte* matte_ptr = new Matte;
				matte_ptr->set_ka(0.25);
				matte_ptr->set_kd(0.75);
				matte_ptr->set_cd(rand_float(), rand_float(), rand_float());
		
				Sphere*	sphere_ptr = new Sphere; 
				sphere_ptr->set_radius(radius);
				sphere_ptr->set_center(	1.0 - 2.0 * rand_float(), 
										1.0 - 2.0 * rand_float(), 
										1.0 - 2.0 * rand_float());	
				sphere_ptr->set_material(matte_ptr);
				grid_ptr->add_object(sphere_ptr);
			}	

			grid_ptr->setup_cells();
			add_object(grid_ptr);
			break;
		}
	case 174:
		{
			//22.11d
			int num_samples = 1;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 20);
			pinhole_ptr->set_lookat(0, 0, 0);
			pinhole_ptr->set_view_distance(3600); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;   
			light_ptr->set_direction(-10, 20, 20);				
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
		//	int num_spheres = 1000;			// for Figure 22.11(a)
		//	int num_spheres = 10000;		// for Figure 22.11(b)
		//	int num_spheres = 100000;		// for Figure 22.11(c)
			int num_spheres = 1000000;		// for Figure 22.11(d)			
	
			float volume = 0.1 / num_spheres;
			float radius = pow(0.75 * volume / 3.14159, 0.333333);
	
			set_rand_seed(15);
	
			Grid* grid_ptr = new Grid;  
	
			for (int j = 0; j < num_spheres; j++) {
				Matte* matte_ptr = new Matte;
				matte_ptr->set_ka(0.25);
				matte_ptr->set_kd(0.75);
				matte_ptr->set_cd(rand_float(), rand_float(), rand_float());
		
				Sphere*	sphere_ptr = new Sphere; 
				sphere_ptr->set_radius(radius);
				sphere_ptr->set_center(	1.0 - 2.0 * rand_float(), 
										1.0 - 2.0 * rand_float(), 
										1.0 - 2.0 * rand_float());	
				sphere_ptr->set_material(matte_ptr);
				grid_ptr->add_object(sphere_ptr);
			}	

			grid_ptr->setup_cells();
			add_object(grid_ptr);
			break;
		}
	case 175:
		{
			//22.11e
			int num_samples = 1;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 15, 30);
			pinhole_ptr->set_lookat(0, 0, 0);
			pinhole_ptr->set_view_distance(4600); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;   
			light_ptr->set_direction(-10, 20, 20);				
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
			int num_spheres = 100000;
	
			float volume = 0.1 / num_spheres;
			float radius = pow(0.75 * volume / 3.14159, 0.333333);
	
			set_rand_seed(15);
	
			Grid* grid_ptr = new Grid;  
	
			for (int j = 0; j < num_spheres; j++) {
				Matte* matte_ptr = new Matte;
				matte_ptr->set_ka(0.25);
				matte_ptr->set_kd(0.75);
				matte_ptr->set_cd(rand_float(), rand_float(), rand_float());
		
				Sphere*	sphere_ptr = new Sphere; 
				sphere_ptr->set_radius(radius);
				sphere_ptr->set_center(	1.0 - 2.0 * rand_float(), 
										1.0 - 2.0 * rand_float(), 
										1.0 - 2.0 * rand_float());	
				sphere_ptr->set_material(matte_ptr);
				grid_ptr->add_object(sphere_ptr);
			}	

			grid_ptr->setup_cells();
			add_object(grid_ptr);
			break;
		}
	case 176:
		{
			//22.14
			int num_samples = 1;
	
			vp.set_hres(800);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Spherical* spherical_ptr = new Spherical;
			spherical_ptr->set_eye(0, 0, 0);       
			spherical_ptr->set_lookat(-100, 0, 0);
			spherical_ptr->set_horizontal_fov(360);     
			spherical_ptr->set_vertical_fov(180);
			spherical_ptr->compute_uvw();
			set_camera(spherical_ptr);

	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(1, 0, 0);    				// from the +ve x direction     
			light_ptr1->scale_radiance(1);   
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(0, 1, 0);    				// from the +ve y direction     
			light_ptr2->scale_radiance(2);   
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);	
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(0, 0, 1);    				// from the +ve z direction      
			light_ptr3->scale_radiance(1.5);   
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			Directional* light_ptr4 = new Directional;
			light_ptr4->set_direction(-1, 0, 0);    			// from the -ve x direction     
			light_ptr4->scale_radiance(1);   
			light_ptr4->set_shadows(true);
			add_light(light_ptr4);
	
			Directional* light_ptr5 = new Directional;
			light_ptr5->set_direction(0, -1, 0);    			// from the -ve y direction     
			light_ptr5->scale_radiance(2);   
			light_ptr5->set_shadows(true);
			add_light(light_ptr5);	
	
			Directional* light_ptr6 = new Directional;
			light_ptr6->set_direction(0, 0, -1);    			// from the -ve z direction      
			light_ptr6->scale_radiance(1.5);   
			light_ptr6->set_shadows(true);
			add_light(light_ptr6);
	
	
			Grid* grid_ptr = new Grid;
	
			int num_spheres	= 25;
			float volume = 0.1 / num_spheres;
			float radius = 2.5 * pow(0.75 * volume / 3.14159, 0.333333);
	
			set_rand_seed(15);  
	
			for (int j = 0; j < num_spheres; j++) {
				SphereChecker* checker_ptr = new SphereChecker;
				checker_ptr->set_numlong(20);
				checker_ptr->set_numlat(10);
				checker_ptr->set_line_width(0.05);
		
				RGBColour color(rand_float(), rand_float(), rand_float());
				checker_ptr->set_color1(color);
				checker_ptr->set_color2(color);
				checker_ptr->set_line_color(black);
		
				SV_Matte* sv_matte_ptr1 = new SV_Matte;		
				sv_matte_ptr1->set_ka(0.25);
				sv_matte_ptr1->set_kd(0.85);
				sv_matte_ptr1->set_cd(checker_ptr);
		
				Sphere* sphere_ptr1 = new Sphere;
				sphere_ptr1->set_material(sv_matte_ptr1);
		
				Instance* sphere_ptr2 = new Instance(sphere_ptr1);
				sphere_ptr2->scale(radius);
				sphere_ptr2->translate(1.0 - 2.0 * rand_float(), 1.0 - 2.0 * rand_float(), 1.0 - 2.0 * rand_float());
				sphere_ptr2->set_bounding_box();
		
				grid_ptr->add_object(sphere_ptr2);
			}	
	
			grid_ptr->setup_cells();
			add_object(grid_ptr);	
			break;
		}
	case 177:
		{
			//22.16
			if( !CheckFile(QString(ppmfile+"uffizi_probe_large.ppm").toLatin1().data()))
				return;

			int num_samples = 1;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);	
	
			Pinhole* pinhole_ptr = new Pinhole;			
			pinhole_ptr->set_eye(0.05, 0.06, 0.07); 
			pinhole_ptr->set_lookat(0.1, 0.1, -10.0);	
			pinhole_ptr->set_view_distance(80);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(0.0);   
			light_ptr->scale_radiance(3.0);
			light_ptr->set_shadows(false);
			add_light(light_ptr);

	
			// the box
			
			Matte* matte_ptr = new Matte;
			matte_ptr->set_ka(0.2); 
			matte_ptr->set_kd(0.5);
			matte_ptr->set_cd(1.0, 0.75, 0.25);  // brown
	
			Point3D p0(-10);
			Point3D p1(10);
	
			Box* box_ptr = new Box(p0, p1);	
			box_ptr->set_material(matte_ptr);

			Grid* grid_ptr = new Grid();
			grid_ptr->add_object(box_ptr);
			grid_ptr->setup_cells();
			add_object(grid_ptr);
		
			Image* image_ptr = new Image;
		//	image_ptr->read_ppm_file("uffizi_probe_small.ppm");  // for testing 
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_large.ppm").toLatin1().data());  // for production

			//This LightProbe class also refers to LightProbeMap 
			LightProbeMap* light_probe_ptr = new LightProbeMap;
			light_probe_ptr->set_map_type(panoramic);     		
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(1);
			sv_matte_ptr->set_kd(0.85);  
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* large_sphere_ptr = new Instance(unit_sphere_ptr); 
			large_sphere_ptr->scale(1000000.0);
			large_sphere_ptr->set_material(sv_matte_ptr);
			add_object(large_sphere_ptr);
			break;
		}
	case 178:
		{
			//22.17a
			int num_samples = 1;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 15, 30);
			pinhole_ptr->set_lookat(0, 0, 0);
			pinhole_ptr->set_view_distance(4000); // for Figure 22.17(a)
		//	pinhole_ptr->set_view_distance(600); // for Figure 22.17(b)
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;   
			light_ptr->set_direction(-10, 20, 20);				
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
			int num_spheres = 1000;
	
			float volume = 0.1 / num_spheres;
			float radius = 10.0 * pow(0.75 * volume / 3.14159, 0.333333);  	// for Figure 22.17(a)
		//	float radius = 250.0 * pow(0.75 * volume / 3.14159, 0.333333);  // for Figure 22.17(b)
	
			set_rand_seed(15);
	
			Grid* grid_ptr = new Grid;  
	
			for (int j = 0; j < num_spheres; j++) {
				Matte* matte_ptr = new Matte;
				matte_ptr->set_ka(0.25);
				matte_ptr->set_kd(0.75);
				matte_ptr->set_cd(rand_float(), rand_float(), rand_float());
		
				Sphere*	sphere_ptr = new Sphere; 
				sphere_ptr->set_radius(radius);
				sphere_ptr->set_center(	1.0 - 2.0 * rand_float(), 
										1.0 - 2.0 * rand_float(), 
										1.0 - 2.0 * rand_float());
				sphere_ptr->set_bounding_box();			// This statement is needed because the bounding box of a sphere is never calculated, which will be put into grid
				sphere_ptr->set_material(matte_ptr);
				grid_ptr->add_object(sphere_ptr);
			}	

			grid_ptr->setup_cells();
			add_object(grid_ptr);
			break;
		}
	case 179:
		{
			//22.17b
			int num_samples = 1;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 15, 30);
			pinhole_ptr->set_lookat(0, 0, 0);
		//	pinhole_ptr->set_view_distance(4000); // for Figure 22.17(a)
			pinhole_ptr->set_view_distance(600); // for Figure 22.17(b)
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;   
			light_ptr->set_direction(-10, 20, 20);				
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
			int num_spheres = 1000;
	
			float volume = 0.1 / num_spheres;
		//	float radius = 10.0 * pow(0.75 * volume / 3.14159, 0.333333);  	// for Figure 22.17(a)
			float radius = 250.0 * pow(0.75 * volume / 3.14159, 0.333333);  // for Figure 22.17(b)
	
			set_rand_seed(15);
	
			Grid* grid_ptr = new Grid;  
	
			for (int j = 0; j < num_spheres; j++) {
				Matte* matte_ptr = new Matte;
				matte_ptr->set_ka(0.25);
				matte_ptr->set_kd(0.75);
				matte_ptr->set_cd(rand_float(), rand_float(), rand_float());
		
				Sphere*	sphere_ptr = new Sphere; 
				sphere_ptr->set_radius(radius);
				sphere_ptr->set_center(	1.0 - 2.0 * rand_float(), 
										1.0 - 2.0 * rand_float(), 
										1.0 - 2.0 * rand_float());
				sphere_ptr->set_bounding_box();	
				sphere_ptr->set_material(matte_ptr);
				grid_ptr->add_object(sphere_ptr);
			}	

			grid_ptr->setup_cells();
			add_object(grid_ptr);
			break;
		}
	case 180:
		{
			//22.18a
			int num_samples = 25;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7, 5, 4.5);
			pinhole_ptr->set_lookat(0, -0.5, -0.25);
			pinhole_ptr->set_view_distance(1305);
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);

	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(1, 0, 0);    				// from the +ve x direction     
			light_ptr1->scale_radiance(1);   
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(0, 1, 0);    				// from the +ve y direction     
			light_ptr2->scale_radiance(2);   
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);	
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(0, 0, 1);    				// from the +ve z direction      
			light_ptr3->scale_radiance(1.5);   
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
			Grid* grid_ptr = new Grid;
	
			int num_spheres = 25;
			float volume = 0.1 / num_spheres;
			float radius = 2.5 * pow(0.75 * volume / 3.14159, 0.333333);
	
			set_rand_seed(15);  
	
			for (int j = 0; j < num_spheres; j++) {
				SphereChecker* checker_ptr = new SphereChecker;
				checker_ptr->set_numlong(16);
				checker_ptr->set_numlat(8);
				checker_ptr->set_line_width(0.075);
		
				RGBColour color(rand_float(), rand_float(), rand_float());
				checker_ptr->set_color1(color);
				checker_ptr->set_color2(color);
				checker_ptr->set_line_color(black);
		
				SV_Matte* sv_matte_ptr1 = new SV_Matte;		
				sv_matte_ptr1->set_ka(0.5);
				sv_matte_ptr1->set_kd(0.6);
				sv_matte_ptr1->set_cd(checker_ptr);
				sv_matte_ptr1->set_cd(checker_ptr);
		
				Sphere* sphere_ptr1 = new Sphere;
				sphere_ptr1->set_material(sv_matte_ptr1);
		
				Instance* sphere_ptr2 = new Instance(sphere_ptr1);
				sphere_ptr2->scale(radius);
				sphere_ptr2->translate(1.0 - 2.0 * rand_float(), 1.0 - 2.0 * rand_float(), 1.0 - 2.0 * rand_float());
				sphere_ptr2->set_bounding_box();
				grid_ptr->add_object(sphere_ptr2);
			}	
	
			grid_ptr->setup_cells();
			add_object(grid_ptr);		
	
			// plane perpendicular to x axis
	
			Matte* matte_ptr1 = new Matte;		
			matte_ptr1->set_ka(0.15);
			matte_ptr1->set_kd(0.6);
			matte_ptr1->set_cd(0.5);
	
			Plane* plane_ptr1 = new Plane(Point3D(-2, 0, 0), Normal(1, 0, 0));
			plane_ptr1->set_material(matte_ptr1);
			add_object(plane_ptr1);
	
			// plane perpendicular to y axis
	
			Matte* matte_ptr2 = new Matte;		
			matte_ptr2->set_ka(0.15);
			matte_ptr2->set_kd(0.6);
			matte_ptr2->set_cd(0.5);
	
			Plane* plane_ptr2 = new Plane(Point3D(0, -2, 0), Normal(0, 1, 0));
			plane_ptr2->set_material(matte_ptr2);
			add_object(plane_ptr2);
	
			// plane perpendicular to z axis
	
			Matte* matte_ptr3 = new Matte;		
			matte_ptr3->set_ka(0.15);
			matte_ptr3->set_kd(0.6);
			matte_ptr3->set_cd(0.5);
	
			Plane* plane_ptr3 = new Plane(Point3D(0, 0, -2), Normal(0, 0, 1));
			plane_ptr3->set_material(matte_ptr3);
			add_object(plane_ptr3);
			break;
		}
	case 181:
		{
			//22.18b
			int num_samples = 25;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7, 5, 4.5);
			pinhole_ptr->set_lookat(0, -0.5, -0.25);
			pinhole_ptr->set_view_distance(1305);
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);

	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(1, 0, 0);    				// from the +ve x direction     
			light_ptr1->scale_radiance(1);   
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(0, 1, 0);    				// from the +ve y direction     
			light_ptr2->scale_radiance(2);   
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);	
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(0, 0, 1);    				// from the +ve z direction      
			light_ptr3->scale_radiance(1.5);   
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
			Grid* grid_ptr = new Grid;
	
			int num_spheres = 25;
			float volume = 0.1 / num_spheres;
			float radius = 2.5 * pow(0.75 * volume / 3.14159, 0.333333);
	
			set_rand_seed(15);  
	
			for (int j = 0; j < num_spheres; j++) {
				SphereChecker* checker_ptr = new SphereChecker;
				checker_ptr->set_numlong(16);
				checker_ptr->set_numlat(8);
				checker_ptr->set_line_width(0.075);
		
				RGBColour color(rand_float(), rand_float(), rand_float());
				checker_ptr->set_color1(color);
				checker_ptr->set_color2(color);
				checker_ptr->set_line_color(black);
		
				SV_Matte* sv_matte_ptr1 = new SV_Matte;		
				sv_matte_ptr1->set_ka(0.5);
				sv_matte_ptr1->set_kd(0.6);
				sv_matte_ptr1->set_cd(checker_ptr);
				sv_matte_ptr1->set_cd(checker_ptr);
		
				Sphere* sphere_ptr1 = new Sphere;
				sphere_ptr1->set_material(sv_matte_ptr1);
		
				Instance* sphere_ptr2 = new Instance(sphere_ptr1);
				sphere_ptr2->scale(radius);
				sphere_ptr2->scale(1, 0.25, 1);
				sphere_ptr2->translate(1.0 - 2.0 * rand_float(), 1.0 - 2.0 * rand_float(), 1.0 - 2.0 * rand_float());
				sphere_ptr2->set_bounding_box();
				grid_ptr->add_object(sphere_ptr2);
			}	
	
			grid_ptr->setup_cells();
			add_object(grid_ptr);		
	
			// plane perpendicular to x axis
	
			Matte* matte_ptr1 = new Matte;		
			matte_ptr1->set_ka(0.15);
			matte_ptr1->set_kd(0.6);
			matte_ptr1->set_cd(0.5);
	
			Plane* plane_ptr1 = new Plane(Point3D(-2, 0, 0), Normal(1, 0, 0));
			plane_ptr1->set_material(matte_ptr1);
			add_object(plane_ptr1);
	
			// plane perpendicular to y axis
	
			Matte* matte_ptr2 = new Matte;		
			matte_ptr2->set_ka(0.15);
			matte_ptr2->set_kd(0.6);
			matte_ptr2->set_cd(0.5);
	
			Plane* plane_ptr2 = new Plane(Point3D(0, -2, 0), Normal(0, 1, 0));
			plane_ptr2->set_material(matte_ptr2);
			add_object(plane_ptr2);
	
			// plane perpendicular to z axis
	
			Matte* matte_ptr3 = new Matte;		
			matte_ptr3->set_ka(0.15);
			matte_ptr3->set_kd(0.6);
			matte_ptr3->set_cd(0.5);
	
			Plane* plane_ptr3 = new Plane(Point3D(0, 0, -2), Normal(0, 0, 1));
			plane_ptr3->set_material(matte_ptr3);
			add_object(plane_ptr3);
			break;
		}
	case 182:
		{
			//22.18c
			int num_samples = 25;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7, 5, 4.5);
			pinhole_ptr->set_lookat(0, -0.5, -0.25);
			pinhole_ptr->set_view_distance(1305);
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);

	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(1, 0, 0);    				// from the +ve x direction     
			light_ptr1->scale_radiance(1);   
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(0, 1, 0);    				// from the +ve y direction     
			light_ptr2->scale_radiance(2);   
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);	
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(0, 0, 1);    				// from the +ve z direction      
			light_ptr3->scale_radiance(1.5);   
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
			Grid* grid_ptr = new Grid;
	
			int num_spheres = 25;
			float volume = 0.1 / num_spheres;
			float radius = 2.5 * pow(0.75 * volume / 3.14159, 0.333333);
	
			set_rand_seed(15);  
	
			for (int j = 0; j < num_spheres; j++) {
				SphereChecker* checker_ptr = new SphereChecker;
				checker_ptr->set_numlong(16);
				checker_ptr->set_numlat(8);
				checker_ptr->set_line_width(0.075);
		
				RGBColour color(rand_float(), rand_float(), rand_float());
				checker_ptr->set_color1(color);
				checker_ptr->set_color2(color);
				checker_ptr->set_line_color(black);
		
				SV_Matte* sv_matte_ptr1 = new SV_Matte;		
				sv_matte_ptr1->set_ka(0.5);
				sv_matte_ptr1->set_kd(0.6);
				sv_matte_ptr1->set_cd(checker_ptr);
				sv_matte_ptr1->set_cd(checker_ptr);
		
				Sphere* sphere_ptr1 = new Sphere;
				sphere_ptr1->set_material(sv_matte_ptr1);
		
				Instance* sphere_ptr2 = new Instance(sphere_ptr1);
				sphere_ptr2->scale(radius);
				sphere_ptr2->translate(1.0 - 2.0 * rand_float(), 1.0 - 2.0 * rand_float(), 1.0 - 2.0 * rand_float());
				sphere_ptr2->set_bounding_box();
				grid_ptr->add_object(sphere_ptr2);
			}	
	
			grid_ptr->setup_cells();
	
			Instance* scaled_grid_ptr = new Instance(grid_ptr);
			scaled_grid_ptr->scale(1, 0.25, 1);
			add_object(scaled_grid_ptr);
			
	
			// plane perpendicular to x axis
	
			Matte* matte_ptr1 = new Matte;		
			matte_ptr1->set_ka(0.15);
			matte_ptr1->set_kd(0.6);
			matte_ptr1->set_cd(0.5);
	
			Plane* plane_ptr1 = new Plane(Point3D(-2, 0, 0), Normal(1, 0, 0));
			plane_ptr1->set_material(matte_ptr1);
			add_object(plane_ptr1);
	
			// plane perpendicular to y axis
	
			Matte* matte_ptr2 = new Matte;		
			matte_ptr2->set_ka(0.15);
			matte_ptr2->set_kd(0.6);
			matte_ptr2->set_cd(0.5);
	
			Plane* plane_ptr2 = new Plane(Point3D(0, -2, 0), Normal(0, 1, 0));
			plane_ptr2->set_material(matte_ptr2);
			add_object(plane_ptr2);
	
			// plane perpendicular to z axis
	
			Matte* matte_ptr3 = new Matte;		
			matte_ptr3->set_ka(0.15);
			matte_ptr3->set_kd(0.6);
			matte_ptr3->set_cd(0.5);
	
			Plane* plane_ptr3 = new Plane(Point3D(0, 0, -2), Normal(0, 0, 1));
			plane_ptr3->set_material(matte_ptr3);
			add_object(plane_ptr3);
			break;
		}
	case 183:
		{
			//23.01a
			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);

			background_color = RGBColour(0.9);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 12, 18); 
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->set_view_distance(4000); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
			

			Directional* light_ptr = new Directional;
			light_ptr->set_direction(20, 25, 5);
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);	
	
	
			Phong* phong_ptr = new Phong;
			phong_ptr->set_ka(0.25);
			phong_ptr->set_kd(0.75);
			phong_ptr->set_cd(0.5);
			phong_ptr->set_cd(0.2, 0.5, 0.4);
			phong_ptr->set_ks(0.2);
			phong_ptr->set_exp(20.0);
	
			// 360 must be divisible by num_horizontal_steps
			// 180 must be divisible by num_vertical_steps
	
			int num_horizontal_steps = 3;    	// for Figure 23.1(a)
			int num_vertical_steps = 2;
	
		//	int num_horizontal_steps = 4;		// for Figure 23.1(b)
		//	int num_vertical_steps = 2;
	
		//	int num_horizontal_steps = 10;		// for Figure 23.1(c)
		//	int num_vertical_steps = 5;
	
		//	int num_horizontal_steps = 100;		// for Figure 23.1(d)
		//	int num_vertical_steps = 50;
		
			Grid* grid_ptr = new Grid;
			grid_ptr->tessellate_flat_sphere(num_horizontal_steps, num_vertical_steps); 
			grid_ptr->set_material(phong_ptr);
			grid_ptr->setup_cells();
			add_object(grid_ptr);	
			break;
		}
	case 184:
		{
			//23.01b
			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);

			background_color = RGBColour(0.9);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 12, 18); 
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->set_view_distance(4000); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
			

			Directional* light_ptr = new Directional;
			light_ptr->set_direction(20, 25, 5);
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);	
	
	
			Phong* phong_ptr = new Phong;
			phong_ptr->set_ka(0.25);
			phong_ptr->set_kd(0.75);
			phong_ptr->set_cd(0.5);
			phong_ptr->set_cd(0.2, 0.5, 0.4);
			phong_ptr->set_ks(0.2);
			phong_ptr->set_exp(20.0);
	
			// 360 must be divisible by num_horizontal_steps
			// 180 must be divisible by num_vertical_steps
	
		//	int num_horizontal_steps = 3;    	// for Figure 23.1(a)
		//	int num_vertical_steps = 2;
	
			int num_horizontal_steps = 4;		// for Figure 23.1(b)
			int num_vertical_steps = 2;
	
		//	int num_horizontal_steps = 10;		// for Figure 23.1(c)
		//	int num_vertical_steps = 5;
	
		//	int num_horizontal_steps = 100;		// for Figure 23.1(d)
		//	int num_vertical_steps = 50;
		
			Grid* grid_ptr = new Grid;
			grid_ptr->tessellate_flat_sphere(num_horizontal_steps, num_vertical_steps); 
			grid_ptr->set_material(phong_ptr);
			grid_ptr->setup_cells();
			add_object(grid_ptr);	
			break;
		}
	case 185:
		{
			//23.01c
			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);

			background_color = RGBColour(0.9);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 12, 18); 
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->set_view_distance(4000); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
			

			Directional* light_ptr = new Directional;
			light_ptr->set_direction(20, 25, 5);
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);	
	
	
			Phong* phong_ptr = new Phong;
			phong_ptr->set_ka(0.25);
			phong_ptr->set_kd(0.75);
			phong_ptr->set_cd(0.5);
			phong_ptr->set_cd(0.2, 0.5, 0.4);
			phong_ptr->set_ks(0.2);
			phong_ptr->set_exp(20.0);
	
			// 360 must be divisible by num_horizontal_steps
			// 180 must be divisible by num_vertical_steps
	
		//	int num_horizontal_steps = 3;    	// for Figure 23.1(a)
		//	int num_vertical_steps = 2;
	
		//	int num_horizontal_steps = 4;		// for Figure 23.1(b)
		//	int num_vertical_steps = 2;
	
			int num_horizontal_steps = 10;		// for Figure 23.1(c)
			int num_vertical_steps = 5;
	
		//	int num_horizontal_steps = 100;		// for Figure 23.1(d)
		//	int num_vertical_steps = 50;
		
			Grid* grid_ptr = new Grid;
			grid_ptr->tessellate_flat_sphere(num_horizontal_steps, num_vertical_steps); 
			grid_ptr->set_material(phong_ptr);
			grid_ptr->setup_cells();
			add_object(grid_ptr);	
			break;
		}
	case 186:
		{
			//23.01d
			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);

			background_color = RGBColour(0.9);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 12, 18); 
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->set_view_distance(4000); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
			

			Directional* light_ptr = new Directional;
			light_ptr->set_direction(20, 25, 5);
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);	
	
	
			Phong* phong_ptr = new Phong;
			phong_ptr->set_ka(0.25);
			phong_ptr->set_kd(0.75);
			phong_ptr->set_cd(0.5);
			phong_ptr->set_cd(0.2, 0.5, 0.4);
			phong_ptr->set_ks(0.2);
			phong_ptr->set_exp(20.0);
	
			// 360 must be divisible by num_horizontal_steps
			// 180 must be divisible by num_vertical_steps
	
		//	int num_horizontal_steps = 3;    	// for Figure 23.1(a)
		//	int num_vertical_steps = 2;
	
		//	int num_horizontal_steps = 4;		// for Figure 23.1(b)
		//	int num_vertical_steps = 2;
	
		//	int num_horizontal_steps = 10;		// for Figure 23.1(c)
		//	int num_vertical_steps = 5;
	
			int num_horizontal_steps = 100;		// for Figure 23.1(d)
			int num_vertical_steps = 50;
		
			Grid* grid_ptr = new Grid;
			grid_ptr->tessellate_flat_sphere(num_horizontal_steps, num_vertical_steps); 
			grid_ptr->set_material(phong_ptr);
			grid_ptr->setup_cells();
			add_object(grid_ptr);	
			break;
		}
	case 187:
		{
			//23.03a
			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);

			background_color = RGBColour(0.9);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 12, 18); 
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->set_view_distance(4000); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
			

			Directional* light_ptr = new Directional;
			light_ptr->set_direction(20, 25, 5);
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);	
	
	
			Phong* phong_ptr = new Phong;
			phong_ptr->set_ka(0.25);
			phong_ptr->set_kd(0.75);
			phong_ptr->set_cd(0.5);
			phong_ptr->set_cd(0.2, 0.5, 0.4);
			phong_ptr->set_ks(0.2);
			phong_ptr->set_exp(20.0);
	
			// 360 must be divisible by num_horizontal_steps
			// 180 must be divisible by num_vertical_steps
	
			int num_horizontal_steps = 3;    	// for Figure 23.3(a)
			int num_vertical_steps = 2;
	
		//	int num_horizontal_steps = 4;		// for Figure 23.3(b)
		//	int num_vertical_steps = 2;
	
		//	int num_horizontal_steps = 10;		// for Figure 23.3(c)
		//	int num_vertical_steps = 5;
	
		//	int num_horizontal_steps = 100;		// for Figure 23.3(d)
		//	int num_vertical_steps = 50;
		
			Grid* grid_ptr = new Grid;
			grid_ptr->tessellate_smooth_sphere(num_horizontal_steps, num_vertical_steps); 
			grid_ptr->set_material(phong_ptr);
			grid_ptr->setup_cells();
			add_object(grid_ptr);	
			break;
		}
	case 188:
		{
			//23.03b
			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);

			background_color = RGBColour(0.9);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 12, 18); 
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->set_view_distance(4000); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
			

			Directional* light_ptr = new Directional;
			light_ptr->set_direction(20, 25, 5);
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);	
	
	
			Phong* phong_ptr = new Phong;
			phong_ptr->set_ka(0.25);
			phong_ptr->set_kd(0.75);
			phong_ptr->set_cd(0.5);
			phong_ptr->set_cd(0.2, 0.5, 0.4);
			phong_ptr->set_ks(0.2);
			phong_ptr->set_exp(20.0);
	
			// 360 must be divisible by num_horizontal_steps
			// 180 must be divisible by num_vertical_steps
	
		//	int num_horizontal_steps = 3;    	// for Figure 23.3(a)
		//	int num_vertical_steps = 2;
	
			int num_horizontal_steps = 4;		// for Figure 23.3(b)
			int num_vertical_steps = 2;
	
		//	int num_horizontal_steps = 10;		// for Figure 23.3(c)
		//	int num_vertical_steps = 5;
	
		//	int num_horizontal_steps = 100;		// for Figure 23.3(d)
		//	int num_vertical_steps = 50;
		
			Grid* grid_ptr = new Grid;
			grid_ptr->tessellate_smooth_sphere(num_horizontal_steps, num_vertical_steps); 
			grid_ptr->set_material(phong_ptr);
			grid_ptr->setup_cells();
			add_object(grid_ptr);	
			break;
		}
	case 189:
		{
			//23.03c
			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);

			background_color = RGBColour(0.9);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 12, 18); 
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->set_view_distance(4000); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
			

			Directional* light_ptr = new Directional;
			light_ptr->set_direction(20, 25, 5);
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);	
	
	
			Phong* phong_ptr = new Phong;
			phong_ptr->set_ka(0.25);
			phong_ptr->set_kd(0.75);
			phong_ptr->set_cd(0.5);
			phong_ptr->set_cd(0.2, 0.5, 0.4);
			phong_ptr->set_ks(0.2);
			phong_ptr->set_exp(20.0);
	
			// 360 must be divisible by num_horizontal_steps
			// 180 must be divisible by num_vertical_steps
	
		//	int num_horizontal_steps = 3;    	// for Figure 23.3(a)
		//	int num_vertical_steps = 2;
	
		//	int num_horizontal_steps = 4;		// for Figure 23.3(b)
		//	int num_vertical_steps = 2;
	
			int num_horizontal_steps = 10;		// for Figure 23.3(c)
			int num_vertical_steps = 5;
	
		//	int num_horizontal_steps = 100;		// for Figure 23.3(d)
		//	int num_vertical_steps = 50;
		
			Grid* grid_ptr = new Grid;
			grid_ptr->tessellate_smooth_sphere(num_horizontal_steps, num_vertical_steps); 
			grid_ptr->set_material(phong_ptr);
			grid_ptr->setup_cells();
			add_object(grid_ptr);	
			break;
		}
	case 190:
		{
			//23.03d
			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);

			background_color = RGBColour(0.9);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 12, 18); 
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->set_view_distance(4000); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
			

			Directional* light_ptr = new Directional;
			light_ptr->set_direction(20, 25, 5);
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);	
	
	
			Phong* phong_ptr = new Phong;
			phong_ptr->set_ka(0.25);
			phong_ptr->set_kd(0.75);
			phong_ptr->set_cd(0.5);
			phong_ptr->set_cd(0.2, 0.5, 0.4);
			phong_ptr->set_ks(0.2);
			phong_ptr->set_exp(20.0);
	
			// 360 must be divisible by num_horizontal_steps
			// 180 must be divisible by num_vertical_steps
	
		//	int num_horizontal_steps = 3;    	// for Figure 23.3(a)
		//	int num_vertical_steps = 2;
	
		//	int num_horizontal_steps = 4;		// for Figure 23.3(b)
		//	int num_vertical_steps = 2;
	
		//	int num_horizontal_steps = 10;		// for Figure 23.3(c)
		//	int num_vertical_steps = 5;
	
			int num_horizontal_steps = 100;		// for Figure 23.3(d)
			int num_vertical_steps = 50;
		
			Grid* grid_ptr = new Grid;
			grid_ptr->tessellate_smooth_sphere(num_horizontal_steps, num_vertical_steps); 
			grid_ptr->set_material(phong_ptr);
			grid_ptr->setup_cells();
			add_object(grid_ptr);	
			break;
		}
	case 191:
		{
			//23.07a
			if( !CheckFile(QString(plyfile+"TwoTriangles.ply").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(400);      
			vp.set_vres(400);    
			vp.set_samples(num_samples);	
	
			tracer_ptr = new RayCast(this);
	
			background_color = black;

			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 50, 90);
			pinhole_ptr->set_lookat(0, -0.5, 0);
			pinhole_ptr->set_view_distance(16000);  	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
		
			Directional* directional_ptr = new Directional;
			directional_ptr->set_direction(0.75, 1, -0.15);     
			directional_ptr->scale_radiance(4.5);  
			directional_ptr->set_shadows(true);
			add_light(directional_ptr);
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.1); 
			matte_ptr1->set_kd(0.75);   
			matte_ptr1->set_cd(0.1, 0.5, 1.0);
	
			Grid* grid_ptr = new Grid(new Mesh);
			grid_ptr->read_flat_triangles(QString(plyfile+"TwoTriangles.ply").toLatin1().data());		// for Figure 23.7(a)
		//	grid_ptr->read_smooth_triangles(file_name);		// for Figure 23.7(b)
			grid_ptr->set_material(matte_ptr1);   
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_cd(1, 0.9, 0.6);
			matte_ptr2->set_ka(0.25); 
			matte_ptr2->set_kd(0.4);
		
			Plane* plane_ptr1 = new Plane(Point3D(0, -2.0, 0), Normal(0, 1, 0));  
			plane_ptr1->set_material(matte_ptr2);
			add_object(plane_ptr1);	
			break;
		}
	case 192:
		{
			//23.07b
			if( !CheckFile(QString(plyfile+"TwoTriangles.ply").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(400);      
			vp.set_vres(400);    
			vp.set_samples(num_samples);	
	
			tracer_ptr = new RayCast(this);
	
			background_color = black;

			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 50, 90);
			pinhole_ptr->set_lookat(0, -0.5, 0);
			pinhole_ptr->set_view_distance(16000);  	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
		
			Directional* directional_ptr = new Directional;
			directional_ptr->set_direction(0.75, 1, -0.15);     
			directional_ptr->scale_radiance(4.5);  
			directional_ptr->set_shadows(true);
			add_light(directional_ptr);
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.1); 
			matte_ptr1->set_kd(0.75);   
			matte_ptr1->set_cd(0.1, 0.5, 1.0);
	
			Grid* grid_ptr = new Grid(new Mesh);
		//	grid_ptr->read_flat_triangles(QString(plyfile+"TwoTriangles.ply").toLatin1().data());		// for Figure 23.7(a)
			grid_ptr->read_smooth_triangles(QString(plyfile+"TwoTriangles.ply").toLatin1().data());		// for Figure 23.7(b)
			grid_ptr->set_material(matte_ptr1);   
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_cd(1, 0.9, 0.6);
			matte_ptr2->set_ka(0.25); 
			matte_ptr2->set_kd(0.4);
		
			Plane* plane_ptr1 = new Plane(Point3D(0, -2.0, 0), Normal(0, 1, 0));  
			plane_ptr1->set_material(matte_ptr2);
			add_object(plane_ptr1);	
			break;
		}
	case 193:
		{
			//23.09b
			//Note that here we choose dragon_vrip.ply instead of original files, it may have some problem in my application, so I take the earliest model from http://graphics.stanford.edu/data/3Dscanrep/ directly, you can put the new model dragon_vrip.ply in the same directory with dragon.ply
			if( !CheckFile(QString(plyfile+"dragon_vrip.ply").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);      
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_max_depth(1);	
	
			tracer_ptr = new Whitted(this);
			background_color = black;
	
			MultiJittered* sampler_ptr = new MultiJittered(num_samples);
		
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(1.0);
		//	set_ambient_light(ambient_ptr);
		
			AmbientOccluder* occluder_ptr = new AmbientOccluder;
			occluder_ptr->set_min_amount(0.25);		
			occluder_ptr->set_sampler(sampler_ptr);
			set_ambient_light(occluder_ptr);

	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-6, 5, 11);    	
			pinhole_ptr->set_lookat(-0.009 , 0.11, 0);
			pinhole_ptr->set_view_distance(37500);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0.5, 1, 0.75);
			light_ptr->scale_radiance(1.0);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			Phong* phong_ptr = new Phong;			
			phong_ptr->set_ka(0.2); 
			phong_ptr->set_kd(0.95); 
			phong_ptr->set_cd(1, 0.6, 0);   // orange
			phong_ptr->set_ks(0.5);  
			phong_ptr->set_exp(20); 
			phong_ptr->set_cs(1, 0.6, 0);   // orange   
			
			Grid* dragon_ptr = new Grid(new Mesh);
			dragon_ptr->read_flat_triangles(QString(plyfile+"dragon_vrip.ply").toLatin1().data());		
		//	dragon_ptr->read_smooth_triangles(file_name);
			dragon_ptr->set_material(phong_ptr); 
			dragon_ptr->setup_cells();
			add_object(dragon_ptr);

	
			Reflective*	reflective_ptr = new Reflective;			
			reflective_ptr->set_ka(0.2); 
			reflective_ptr->set_kd(0.75);
			reflective_ptr->set_cd(0.5);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_exp(20);
			reflective_ptr->set_kr(0.5);  
			reflective_ptr->set_cr(0.8, 1.0, 0.8);    
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.055, 0), Normal(0, 1, 0)); 	
			plane_ptr->set_material(reflective_ptr);
			add_object(plane_ptr);	
			break;
		}
	case 194:
		{
			//23.10a
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_body.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_left_wing.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_right_wing.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_left_foot.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_right_foot.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_left_eyeball.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_right_eyeball.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_left_lower_eyelid.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_right_lower_eyelid.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_left_upper_eyelid.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_right_upper_eyelid.ply").toLatin1().data()))
				return;

			int num_samples = 16;
	  
			vp.set_hres(400);      
			vp.set_vres(400);    
			vp.set_max_depth(0);
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);	
	
			background_color = black;
	
			tracer_ptr = new RayCast(this);

			Pinhole* pinhole_ptr = new Pinhole;	    
			pinhole_ptr->set_eye(50, 40, 110);
			pinhole_ptr->set_lookat(1, 0, 0);
			pinhole_ptr->set_view_distance(1500);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
			Directional* directional_ptr = new Directional;    
			directional_ptr->set_direction(0.75, 1, 1);  
			directional_ptr->scale_radiance(2.5);
			directional_ptr->set_shadows(true);
			add_light(directional_ptr);
	
	
			float ka = 0.25;   	
			float kd = 0.75;	
	
			RGBColour body_color(0.5, 0.5, 1.0);
			RGBColour wing_color(0.5, 1.0, 0.4);
			RGBColour feet_color(1.0, 0.8, 0.34);
			RGBColour eyeball_color(1.0);
			RGBColour eyelid_color(1, 0, 0);
		
			// body
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(ka);
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(body_color);
	
			Grid* body_ptr = new Grid;
			body_ptr->read_flat_triangles(QString(plyfile+"Penguin\\penguin_body.ply").toLatin1().data());
			body_ptr->set_material(matte_ptr1);  
			body_ptr->setup_cells();
			add_object(body_ptr);
	
			// wings
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(ka);
			matte_ptr2->set_kd(0.5);    
			matte_ptr2->set_cd(wing_color);
	
			Grid* left_wing_ptr = new Grid;
			left_wing_ptr->read_flat_triangles(QString(plyfile+"Penguin\\penguin_left_wing.ply").toLatin1().data());
			left_wing_ptr->set_material(matte_ptr2);  
			left_wing_ptr->setup_cells();
	
			Grid* right_wing_ptr = new Grid;
			right_wing_ptr->read_flat_triangles(QString(plyfile+"Penguin\\penguin_right_wing.ply").toLatin1().data());
			right_wing_ptr->set_material(matte_ptr2);  
			right_wing_ptr->setup_cells();
	
	
			// feet
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(ka);
			matte_ptr3->set_kd(0.5);    
			matte_ptr3->set_cd(feet_color);
	
			Grid* left_foot_ptr = new Grid;
			left_foot_ptr->read_flat_triangles(QString(plyfile+"Penguin\\penguin_left_foot.ply").toLatin1().data());
			left_foot_ptr->set_material(matte_ptr3);  
			left_foot_ptr->setup_cells();
	
			Grid* right_foot_ptr = new Grid;
			right_foot_ptr->read_flat_triangles(QString(plyfile+"Penguin\\penguin_right_foot.ply").toLatin1().data());
			right_foot_ptr->set_material(matte_ptr3);  
			right_foot_ptr->setup_cells();
	
	
			// eyeballs
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(ka);
			matte_ptr4->set_kd(kd);    
			matte_ptr4->set_cd(eyeball_color);
	
			Grid* left_eyeball_ptr = new Grid;
			left_eyeball_ptr->read_flat_triangles(QString(plyfile+"Penguin\\penguin_left_eyeball.ply").toLatin1().data());
			left_eyeball_ptr->set_material(matte_ptr4);  
			left_eyeball_ptr->setup_cells();
	
			Grid* right_eyeball_ptr = new Grid;
			right_eyeball_ptr->read_flat_triangles(QString(plyfile+"Penguin\\penguin_right_eyeball.ply").toLatin1().data());
			right_eyeball_ptr->set_material(matte_ptr4);  
			right_eyeball_ptr->setup_cells();
	
	
			// eyelids
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(ka);
			matte_ptr5->set_kd(kd);    
			matte_ptr5->set_cd(eyelid_color);
	
			Grid* left_lower_eyelid_ptr = new Grid;
			left_lower_eyelid_ptr->read_flat_triangles(QString(plyfile+"Penguin\\penguin_left_lower_eyelid.ply").toLatin1().data());
			left_lower_eyelid_ptr->set_material(matte_ptr5);  
			left_lower_eyelid_ptr->setup_cells();
	
			Grid* right_lower_eyelid_ptr = new Grid;
			right_lower_eyelid_ptr->read_flat_triangles(QString(plyfile+"Penguin\\penguin_right_lower_eyelid.ply").toLatin1().data());
			right_lower_eyelid_ptr->set_material(matte_ptr5);  
			right_lower_eyelid_ptr->setup_cells();
	
	
			Grid* left_upper_eyelid_ptr = new Grid;
			left_upper_eyelid_ptr->read_flat_triangles(QString(plyfile+"Penguin\\penguin_left_upper_eyelid.ply").toLatin1().data());
			left_upper_eyelid_ptr->set_material(matte_ptr5);  
			left_upper_eyelid_ptr->setup_cells();
	
			Grid* right_upper_eyelid_ptr = new Grid;
			right_upper_eyelid_ptr->read_flat_triangles(QString(plyfile+"Penguin\\penguin_right_upper_eyelid.ply").toLatin1().data());
			right_upper_eyelid_ptr->set_material(matte_ptr5);  
			right_upper_eyelid_ptr->setup_cells();
	
			// complete penguin
	
			Grid* penguin_ptr = new Grid;
			penguin_ptr->add_object(body_ptr);
			penguin_ptr->add_object(left_wing_ptr);
			penguin_ptr->add_object(right_wing_ptr);
			penguin_ptr->add_object(left_foot_ptr);
			penguin_ptr->add_object(right_foot_ptr);
			penguin_ptr->add_object(left_eyeball_ptr);
			penguin_ptr->add_object(right_eyeball_ptr);
			penguin_ptr->add_object(left_lower_eyelid_ptr);
			penguin_ptr->add_object(right_lower_eyelid_ptr);
			penguin_ptr->add_object(left_upper_eyelid_ptr);
			penguin_ptr->add_object(right_upper_eyelid_ptr);
	
			penguin_ptr->setup_cells();
			add_object(penguin_ptr);
			break;
		}
	case 195:
		{
			//23.10b
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_body.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_left_wing.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_right_wing.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_left_foot.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_right_foot.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_left_eyeball.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_right_eyeball.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_left_lower_eyelid.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_right_lower_eyelid.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_left_upper_eyelid.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(plyfile+"Penguin\\penguin_right_upper_eyelid.ply").toLatin1().data()))
				return;

			int num_samples = 16;
	  
			vp.set_hres(400);      
			vp.set_vres(400);    
			vp.set_max_depth(0);
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);	
	
			background_color = black;
	
			tracer_ptr = new RayCast(this);

			Pinhole* pinhole_ptr = new Pinhole;	    
			pinhole_ptr->set_eye(50, 40, 110);
			pinhole_ptr->set_lookat(1, 0, 0);
			pinhole_ptr->set_view_distance(1500);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
			Directional* directional_ptr = new Directional;    
			directional_ptr->set_direction(0.75, 1, 1);  
			directional_ptr->scale_radiance(2.5);
			directional_ptr->set_shadows(true);
			add_light(directional_ptr);
	
	
			float ka = 0.25;   	
			float kd = 0.75;	
	
			RGBColour body_color(0.5, 0.5, 1.0);
			RGBColour wing_color(0.5, 1.0, 0.4);
			RGBColour feet_color(1.0, 0.8, 0.34);
			RGBColour eyeball_color(1.0);
			RGBColour eyelid_color(1, 0, 0);
		
			// body
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(ka);
			matte_ptr1->set_kd(0.75);    
			matte_ptr1->set_cd(body_color);		
	
			Grid* body_ptr = new Grid;
			body_ptr->read_smooth_triangles(QString(plyfile+"Penguin\\penguin_body.ply").toLatin1().data());
			body_ptr->set_material(matte_ptr1);  
			body_ptr->setup_cells();
			add_object(body_ptr);
	
			// wings
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(ka);
			matte_ptr2->set_kd(0.5);    
			matte_ptr2->set_cd(wing_color);
	
			Grid* left_wing_ptr = new Grid;
			left_wing_ptr->read_smooth_triangles(QString(plyfile+"Penguin\\penguin_left_wing.ply").toLatin1().data());
			left_wing_ptr->set_material(matte_ptr2);  
			left_wing_ptr->setup_cells();
	
			Grid* right_wing_ptr = new Grid;
			right_wing_ptr->read_smooth_triangles(QString(plyfile+"Penguin\\penguin_right_wing.ply").toLatin1().data());
			right_wing_ptr->set_material(matte_ptr2);  
			right_wing_ptr->setup_cells();
	
	
			// feet
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(ka);
			matte_ptr3->set_kd(0.5);    
			matte_ptr3->set_cd(feet_color);
	
			Grid* left_foot_ptr = new Grid;
			left_foot_ptr->read_smooth_triangles(QString(plyfile+"Penguin\\penguin_left_foot.ply").toLatin1().data());
			left_foot_ptr->set_material(matte_ptr3);  
			left_foot_ptr->setup_cells();
	
			Grid* right_foot_ptr = new Grid;
			right_foot_ptr->read_smooth_triangles(QString(plyfile+"Penguin\\penguin_right_foot.ply").toLatin1().data());
			right_foot_ptr->set_material(matte_ptr3);  
			right_foot_ptr->setup_cells();
	
	
			// eyeballs
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(ka);
			matte_ptr4->set_kd(kd);    
			matte_ptr4->set_cd(eyeball_color);
	
			Grid* left_eyeball_ptr = new Grid;
			left_eyeball_ptr->read_smooth_triangles(QString(plyfile+"Penguin\\penguin_left_eyeball.ply").toLatin1().data());
			left_eyeball_ptr->set_material(matte_ptr4);  
			left_eyeball_ptr->setup_cells();
	
			Grid* right_eyeball_ptr = new Grid;
			right_eyeball_ptr->read_smooth_triangles(QString(plyfile+"Penguin\\penguin_right_eyeball.ply").toLatin1().data());
			right_eyeball_ptr->set_material(matte_ptr4);  
			right_eyeball_ptr->setup_cells();
	
	
			// eyelids
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(ka);
			matte_ptr5->set_kd(kd);    
			matte_ptr5->set_cd(eyelid_color);
	
			Grid* left_lower_eyelid_ptr = new Grid;
			left_lower_eyelid_ptr->read_smooth_triangles(QString(plyfile+"Penguin\\penguin_left_lower_eyelid.ply").toLatin1().data());
			left_lower_eyelid_ptr->set_material(matte_ptr5);  
			left_lower_eyelid_ptr->setup_cells();
	
			Grid* right_lower_eyelid_ptr = new Grid;
			right_lower_eyelid_ptr->read_smooth_triangles(QString(plyfile+"Penguin\\penguin_right_lower_eyelid.ply").toLatin1().data());
			right_lower_eyelid_ptr->set_material(matte_ptr5);  
			right_lower_eyelid_ptr->setup_cells();
	
	
			Grid* left_upper_eyelid_ptr = new Grid;
			left_upper_eyelid_ptr->read_smooth_triangles(QString(plyfile+"Penguin\\penguin_left_upper_eyelid.ply").toLatin1().data());
			left_upper_eyelid_ptr->set_material(matte_ptr5);  
			left_upper_eyelid_ptr->setup_cells();
	
			Grid* right_upper_eyelid_ptr = new Grid;
			right_upper_eyelid_ptr->read_smooth_triangles(QString(plyfile+"Penguin\\penguin_right_upper_eyelid.ply").toLatin1().data());
			right_upper_eyelid_ptr->set_material(matte_ptr5);  
			right_upper_eyelid_ptr->setup_cells();
			// complete penguin
	
			Grid* penguin_ptr = new Grid;
			penguin_ptr->add_object(body_ptr);
			penguin_ptr->add_object(left_wing_ptr);
			penguin_ptr->add_object(right_wing_ptr);
			penguin_ptr->add_object(left_foot_ptr);
			penguin_ptr->add_object(right_foot_ptr);
			penguin_ptr->add_object(left_eyeball_ptr);
			penguin_ptr->add_object(right_eyeball_ptr);
			penguin_ptr->add_object(left_lower_eyelid_ptr);
			penguin_ptr->add_object(right_lower_eyelid_ptr);
			penguin_ptr->add_object(left_upper_eyelid_ptr);
			penguin_ptr->add_object(right_upper_eyelid_ptr);
	
			penguin_ptr->setup_cells();
			add_object(penguin_ptr);
			break;
		}
	case 196:
		{
			//23.12a
			//Note that the final image of 23.12a-e are from the Extra Image Parts in the original resouce, it is a little different with normal picture. 
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data()))
				return;

			int num_samples = 1;
	
			vp.set_hres(500);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			// the camera is defined at the bottom
		
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(20, 40, 20);
			light_ptr1->scale_radiance(3.0); 
			add_light(light_ptr1);
	
	
			Phong* phong_ptr = new Phong;
			phong_ptr->set_ka(0.2);
			phong_ptr->set_kd(0.5);
			phong_ptr->set_cd(1.0);
			phong_ptr->set_ks(0.4);
			phong_ptr->set_exp(20);
	
		//	const char* fileName = "Bunny4K.ply";			// low res Stanford bunny
		//	const char* fileName = "Bunny16K.ply";			// medium res Stanford bunny
		//	const char* fileName = "Bunny69K.ply";			// high res Stanford bunny

			Grid* bunny_ptr = new Grid(new Mesh);
			bunny_ptr->read_flat_triangles(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data());		// read PLY file
		//	bunny_ptr->read_smooth_triangles(fileName);		// read PLY file
			bunny_ptr->set_material(phong_ptr);				// only use this if you want white bunnies
			bunny_ptr->setup_cells();
		
			int 	num_levels 			= 6;		// number of levels
			int 	instances_grid_res 	= 10; 		// each level consists of instances_grid_res x instances_grid_res instances
			double 	delta 				= 0.1; 		// gap between instances
			double 	gap 				= 0.08; 	// gap between bunnies in the level 0 grid
			double 	size 				= 0.1;    	// bunny size
			double 	mcx 				= 0.5; 		// camera coordinates as multiple mcx of grid size - allows us to keep the whole grid in view
	
			set_rand_seed(1000);
	
			Grid* current_grid_ptr = bunny_ptr;							// just the bunny
	
			for (int level = 0; level < num_levels; level++) {	
				Grid* instance_grid_ptr = new Grid;						// temporary grid
		
				for (int i = 0; i < instances_grid_res; i++) {   		// xw direction
					for (int k = 0; k < instances_grid_res; k++) {   	// zw direction
			
						Phong* phong_ptr = new Phong;
						phong_ptr->set_ka(0.2);
						phong_ptr->set_kd(0.5);
						phong_ptr->set_cd(rand_float(), rand_float(), rand_float());
						phong_ptr->set_ks(0.4);
						phong_ptr->set_exp(20);
			
						Instance* instance_ptr = new Instance;
						instance_ptr->set_object(current_grid_ptr); 	// add whole grid up to this level
						instance_ptr->set_material(phong_ptr);
						instance_ptr->translate(i * (size + gap), 0.0, k * (size + gap)); 
						instance_ptr->compute_bounding_box();
						instance_grid_ptr->add_object(instance_ptr);
					}
				}
		
				size = instances_grid_res * size + (instances_grid_res - 1) * gap;  
				gap = delta * size;
				instance_grid_ptr->setup_cells();
				current_grid_ptr = instance_grid_ptr;					// now the whole grid up to this level	
			}
	
			add_object(current_grid_ptr); 								// the whole n-level grid
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7 * mcx * size, 4 * mcx * size, 5 * mcx * size); 
			pinhole_ptr->set_lookat(mcx * size, 0.0, mcx * size);     				// use this for the whole grid 
		//	pinhole_ptr->set_lookat(mcx * size, 0.4 * mcx * size, mcx * size);   	// use this for the zooms
			pinhole_ptr->set_view_distance(1400);   		// Figure 23.12(a) the whole grid
		//	pinhole_ptr->set_view_distance(140000);  		// Figure 23.12(b)
		//	pinhole_ptr->set_view_distance(14000000);  		// Figure 23.12(c)
		//	pinhole_ptr->set_view_distance(300000000);   	// Figure 23.12(d)
		//	pinhole_ptr->set_view_distance(100000000);   	// extra image
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr); 
			break;
		}
	case 197:
		{
			//23.12b
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data()))
				return;

			int num_samples = 1;
	
			vp.set_hres(500);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			// the camera is defined at the bottom
		
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(20, 40, 20);
			light_ptr1->scale_radiance(3.0); 
			add_light(light_ptr1);
	
	
			Phong* phong_ptr = new Phong;
			phong_ptr->set_ka(0.2);
			phong_ptr->set_kd(0.5);
			phong_ptr->set_cd(1.0);
			phong_ptr->set_ks(0.4);
			phong_ptr->set_exp(20);
	
		//	const char* fileName = "Bunny4K.ply";			// low res Stanford bunny
		//	const char* fileName = "Bunny16K.ply";			// medium res Stanford bunny
		//	const char* fileName = "Bunny69K.ply";			// high res Stanford bunny

			Grid* bunny_ptr = new Grid(new Mesh);
			bunny_ptr->read_flat_triangles(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data());		// read PLY file
		//	bunny_ptr->read_smooth_triangles(fileName);		// read PLY file
			bunny_ptr->set_material(phong_ptr);				// only use this if you want white bunnies
			bunny_ptr->setup_cells();
		
			int 	num_levels 			= 6;		// number of levels
			int 	instances_grid_res 	= 10; 		// each level consists of instances_grid_res x instances_grid_res instances
			double 	delta 				= 0.1; 		// gap between instances
			double 	gap 				= 0.08; 	// gap between bunnies in the level 0 grid
			double 	size 				= 0.1;    	// bunny size
			double 	mcx 				= 0.5; 		// camera coordinates as multiple mcx of grid size - allows us to keep the whole grid in view
	
			set_rand_seed(1000);
	
			Grid* current_grid_ptr = bunny_ptr;							// just the bunny
	
			for (int level = 0; level < num_levels; level++) {	
				Grid* instance_grid_ptr = new Grid;						// temporary grid
		
				for (int i = 0; i < instances_grid_res; i++) {   		// xw direction
					for (int k = 0; k < instances_grid_res; k++) {   	// zw direction
			
						Phong* phong_ptr = new Phong;
						phong_ptr->set_ka(0.2);
						phong_ptr->set_kd(0.5);
						phong_ptr->set_cd(rand_float(), rand_float(), rand_float());
						phong_ptr->set_ks(0.4);
						phong_ptr->set_exp(20);
			
						Instance* instance_ptr = new Instance;
						instance_ptr->set_object(current_grid_ptr); 	// add whole grid up to this level
						instance_ptr->set_material(phong_ptr);
						instance_ptr->translate(i * (size + gap), 0.0, k * (size + gap)); 
						instance_ptr->compute_bounding_box();
						instance_grid_ptr->add_object(instance_ptr);
					}
				}
		
				size = instances_grid_res * size + (instances_grid_res - 1) * gap;  
				gap = delta * size;
				instance_grid_ptr->setup_cells();
				current_grid_ptr = instance_grid_ptr;					// now the whole grid up to this level	
			}
	
			add_object(current_grid_ptr); 								// the whole n-level grid
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7 * mcx * size, 4 * mcx * size, 5 * mcx * size); 
		//	pinhole_ptr->set_lookat(mcx * size, 0.0, mcx * size);     				// use this for the whole grid 
			pinhole_ptr->set_lookat(mcx * size, 0.4 * mcx * size, mcx * size);   	// use this for the zooms
		//	pinhole_ptr->set_view_distance(1400);   		// Figure 23.12(a) the whole grid
			pinhole_ptr->set_view_distance(140000);  		// Figure 23.12(b)
		//	pinhole_ptr->set_view_distance(14000000);  		// Figure 23.12(c)
		//	pinhole_ptr->set_view_distance(300000000);   	// Figure 23.12(d)
		//	pinhole_ptr->set_view_distance(100000000);   	// extra image
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr); 
			break;
		}
	case 198:
		{
			//23.12c
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data()))
				return;

			int num_samples = 1;
	
			vp.set_hres(500);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			// the camera is defined at the bottom
		
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(20, 40, 20);
			light_ptr1->scale_radiance(3.0); 
			add_light(light_ptr1);
	
	
			Phong* phong_ptr = new Phong;
			phong_ptr->set_ka(0.2);
			phong_ptr->set_kd(0.5);
			phong_ptr->set_cd(1.0);
			phong_ptr->set_ks(0.4);
			phong_ptr->set_exp(20);
	
		//	const char* fileName = "Bunny4K.ply";			// low res Stanford bunny
		//	const char* fileName = "Bunny16K.ply";			// medium res Stanford bunny
		//	const char* fileName = "Bunny69K.ply";			// high res Stanford bunny

			Grid* bunny_ptr = new Grid(new Mesh);
			bunny_ptr->read_flat_triangles(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data());		// read PLY file
		//	bunny_ptr->read_smooth_triangles(fileName);		// read PLY file
			bunny_ptr->set_material(phong_ptr);				// only use this if you want white bunnies
			bunny_ptr->setup_cells();
		
			int 	num_levels 			= 6;		// number of levels
			int 	instances_grid_res 	= 10; 		// each level consists of instances_grid_res x instances_grid_res instances
			double 	delta 				= 0.1; 		// gap between instances
			double 	gap 				= 0.08; 	// gap between bunnies in the level 0 grid
			double 	size 				= 0.1;    	// bunny size
			double 	mcx 				= 0.5; 		// camera coordinates as multiple mcx of grid size - allows us to keep the whole grid in view
	
			set_rand_seed(1000);
	
			Grid* current_grid_ptr = bunny_ptr;							// just the bunny
	
			for (int level = 0; level < num_levels; level++) {	
				Grid* instance_grid_ptr = new Grid;						// temporary grid
		
				for (int i = 0; i < instances_grid_res; i++) {   		// xw direction
					for (int k = 0; k < instances_grid_res; k++) {   	// zw direction
			
						Phong* phong_ptr = new Phong;
						phong_ptr->set_ka(0.2);
						phong_ptr->set_kd(0.5);
						phong_ptr->set_cd(rand_float(), rand_float(), rand_float());
						phong_ptr->set_ks(0.4);
						phong_ptr->set_exp(20);
			
						Instance* instance_ptr = new Instance;
						instance_ptr->set_object(current_grid_ptr); 	// add whole grid up to this level
						instance_ptr->set_material(phong_ptr);
						instance_ptr->translate(i * (size + gap), 0.0, k * (size + gap)); 
						instance_ptr->compute_bounding_box();
						instance_grid_ptr->add_object(instance_ptr);
					}
				}
		
				size = instances_grid_res * size + (instances_grid_res - 1) * gap;  
				gap = delta * size;
				instance_grid_ptr->setup_cells();
				current_grid_ptr = instance_grid_ptr;					// now the whole grid up to this level	
			}
	
			add_object(current_grid_ptr); 								// the whole n-level grid
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7 * mcx * size, 4 * mcx * size, 5 * mcx * size); 
		//	pinhole_ptr->set_lookat(mcx * size, 0.0, mcx * size);     				// use this for the whole grid 
			pinhole_ptr->set_lookat(mcx * size, 0.4 * mcx * size, mcx * size);   	// use this for the zooms
		//	pinhole_ptr->set_view_distance(1400);   		// Figure 23.12(a) the whole grid
		//	pinhole_ptr->set_view_distance(140000);  		// Figure 23.12(b)
			pinhole_ptr->set_view_distance(14000000);  		// Figure 23.12(c)
		//	pinhole_ptr->set_view_distance(300000000);   	// Figure 23.12(d)
		//	pinhole_ptr->set_view_distance(100000000);   	// extra image
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr); 
			break;
		}
	case 199:
		{
			//23.12d
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data()))
				return;

			int num_samples = 1;
	
			vp.set_hres(500);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			// the camera is defined at the bottom
		
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(20, 40, 20);
			light_ptr1->scale_radiance(3.0); 
			add_light(light_ptr1);
	
	
			Phong* phong_ptr = new Phong;
			phong_ptr->set_ka(0.2);
			phong_ptr->set_kd(0.5);
			phong_ptr->set_cd(1.0);
			phong_ptr->set_ks(0.4);
			phong_ptr->set_exp(20);
	
		//	const char* fileName = "Bunny4K.ply";			// low res Stanford bunny
		//	const char* fileName = "Bunny16K.ply";			// medium res Stanford bunny
		//	const char* fileName = "Bunny69K.ply";			// high res Stanford bunny

			Grid* bunny_ptr = new Grid(new Mesh);
			bunny_ptr->read_flat_triangles(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data());		// read PLY file
		//	bunny_ptr->read_smooth_triangles(fileName);		// read PLY file
			bunny_ptr->set_material(phong_ptr);				// only use this if you want white bunnies
			bunny_ptr->setup_cells();
		
			int 	num_levels 			= 6;		// number of levels
			int 	instances_grid_res 	= 10; 		// each level consists of instances_grid_res x instances_grid_res instances
			double 	delta 				= 0.1; 		// gap between instances
			double 	gap 				= 0.08; 	// gap between bunnies in the level 0 grid
			double 	size 				= 0.1;    	// bunny size
			double 	mcx 				= 0.5; 		// camera coordinates as multiple mcx of grid size - allows us to keep the whole grid in view
	
			set_rand_seed(1000);
	
			Grid* current_grid_ptr = bunny_ptr;							// just the bunny
	
			for (int level = 0; level < num_levels; level++) {	
				Grid* instance_grid_ptr = new Grid;						// temporary grid
		
				for (int i = 0; i < instances_grid_res; i++) {   		// xw direction
					for (int k = 0; k < instances_grid_res; k++) {   	// zw direction
			
						Phong* phong_ptr = new Phong;
						phong_ptr->set_ka(0.2);
						phong_ptr->set_kd(0.5);
						phong_ptr->set_cd(rand_float(), rand_float(), rand_float());
						phong_ptr->set_ks(0.4);
						phong_ptr->set_exp(20);
			
						Instance* instance_ptr = new Instance;
						instance_ptr->set_object(current_grid_ptr); 	// add whole grid up to this level
						instance_ptr->set_material(phong_ptr);
						instance_ptr->translate(i * (size + gap), 0.0, k * (size + gap)); 
						instance_ptr->compute_bounding_box();
						instance_grid_ptr->add_object(instance_ptr);
					}
				}
		
				size = instances_grid_res * size + (instances_grid_res - 1) * gap;  
				gap = delta * size;
				instance_grid_ptr->setup_cells();
				current_grid_ptr = instance_grid_ptr;					// now the whole grid up to this level	
			}
	
			add_object(current_grid_ptr); 								// the whole n-level grid
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7 * mcx * size, 4 * mcx * size, 5 * mcx * size); 
		//	pinhole_ptr->set_lookat(mcx * size, 0.0, mcx * size);     				// use this for the whole grid 
			pinhole_ptr->set_lookat(mcx * size, 0.4 * mcx * size, mcx * size);   	// use this for the zooms
		//	pinhole_ptr->set_view_distance(1400);   		// Figure 23.12(a) the whole grid
		//	pinhole_ptr->set_view_distance(140000);  		// Figure 23.12(b)
		//	pinhole_ptr->set_view_distance(14000000);  		// Figure 23.12(c)
			pinhole_ptr->set_view_distance(300000000);   	// Figure 23.12(d)
		//	pinhole_ptr->set_view_distance(100000000);   	// extra image
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr); 
			break;
		}
	case 200:
		{
			//23.12Extra
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data()))
				return;

			int num_samples = 1;
	
			vp.set_hres(500);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			// the camera is defined at the bottom
		
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(20, 40, 20);
			light_ptr1->scale_radiance(3.0); 
			add_light(light_ptr1);
	
	
			Phong* phong_ptr = new Phong;
			phong_ptr->set_ka(0.2);
			phong_ptr->set_kd(0.5);
			phong_ptr->set_cd(1.0);
			phong_ptr->set_ks(0.4);
			phong_ptr->set_exp(20);
	
		//	const char* fileName = "Bunny4K.ply";			// low res Stanford bunny
		//	const char* fileName = "Bunny16K.ply";			// medium res Stanford bunny
		//	const char* fileName = "Bunny69K.ply";			// high res Stanford bunny

			Grid* bunny_ptr = new Grid(new Mesh);
			bunny_ptr->read_flat_triangles(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data());		// read PLY file
		//	bunny_ptr->read_smooth_triangles(fileName);		// read PLY file
			bunny_ptr->set_material(phong_ptr);				// only use this if you want white bunnies
			bunny_ptr->setup_cells();
		
			int 	num_levels 			= 6;		// number of levels
			int 	instances_grid_res 	= 10; 		// each level consists of instances_grid_res x instances_grid_res instances
			double 	delta 				= 0.1; 		// gap between instances
			double 	gap 				= 0.08; 	// gap between bunnies in the level 0 grid
			double 	size 				= 0.1;    	// bunny size
			double 	mcx 				= 0.5; 		// camera coordinates as multiple mcx of grid size - allows us to keep the whole grid in view
	
			set_rand_seed(1000);
	
			Grid* current_grid_ptr = bunny_ptr;							// just the bunny
	
			for (int level = 0; level < num_levels; level++) {	
				Grid* instance_grid_ptr = new Grid;						// temporary grid
		
				for (int i = 0; i < instances_grid_res; i++) {   		// xw direction
					for (int k = 0; k < instances_grid_res; k++) {   	// zw direction
			
						Phong* phong_ptr = new Phong;
						phong_ptr->set_ka(0.2);
						phong_ptr->set_kd(0.5);
						phong_ptr->set_cd(rand_float(), rand_float(), rand_float());
						phong_ptr->set_ks(0.4);
						phong_ptr->set_exp(20);
			
						Instance* instance_ptr = new Instance;
						instance_ptr->set_object(current_grid_ptr); 	// add whole grid up to this level
						instance_ptr->set_material(phong_ptr);
						instance_ptr->translate(i * (size + gap), 0.0, k * (size + gap)); 
						instance_ptr->compute_bounding_box();
						instance_grid_ptr->add_object(instance_ptr);
					}
				}
		
				size = instances_grid_res * size + (instances_grid_res - 1) * gap;  
				gap = delta * size;
				instance_grid_ptr->setup_cells();
				current_grid_ptr = instance_grid_ptr;					// now the whole grid up to this level	
			}
	
			add_object(current_grid_ptr); 								// the whole n-level grid
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7 * mcx * size, 4 * mcx * size, 5 * mcx * size); 
		//	pinhole_ptr->set_lookat(mcx * size, 0.0, mcx * size);     				// use this for the whole grid 
			pinhole_ptr->set_lookat(mcx * size, 0.4 * mcx * size, mcx * size);   	// use this for the zooms
		//	pinhole_ptr->set_view_distance(1400);   		// Figure 23.12(a) the whole grid
		//	pinhole_ptr->set_view_distance(140000);  		// Figure 23.12(b)
		//	pinhole_ptr->set_view_distance(14000000);  		// Figure 23.12(c)
		//	pinhole_ptr->set_view_distance(300000000);   	// Figure 23.12(d)
			pinhole_ptr->set_view_distance(100000000);   	// extra image
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr); 
			break;
		}
	case 201:
		{
			//23.13
			if( !CheckFile(QString(plyfile+"goldfish_high_res.ply").toLatin1().data()))
				return;

			int num_samples = 1;
	
			vp.set_hres(400);      
			vp.set_vres(400);    
			vp.set_samples(1);	
	
			tracer_ptr = new RayCast(this);
	
			background_color = black;

			Pinhole* pinhole_ptr = new Pinhole;	
			pinhole_ptr->set_eye(75, 20, 80);
			pinhole_ptr->set_lookat(-0.05, -0.5, 0);
			pinhole_ptr->set_view_distance(1600);  	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
		
			Directional* directional_ptr = new Directional;
			directional_ptr->set_direction(0.75, 0.5, -0.15);     
			directional_ptr->scale_radiance(2.0); 
			directional_ptr->set_shadows(true);
			add_light(directional_ptr);
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(0.4); 
			phong_ptr1->set_kd(0.8);
			phong_ptr1->set_cd(1.0, 0.2, 0.0); 
			phong_ptr1->set_ks(0.5); 
			phong_ptr1->set_cs(1.0, 1.0, 0.0);
			phong_ptr1->set_exp(50.0);
	
		//	const char* file_name = "goldfish_low_res.ply";
		//	const char* file_name = "goldfish_high_res.ply";
			Grid* grid_ptr = new Grid(new Mesh);
			grid_ptr->read_smooth_triangles(QString(plyfile+"goldfish_high_res.ply").toLatin1().data());		
		//	grid_ptr->read_flat_triangles(file_name);		
			grid_ptr->set_material(phong_ptr1);    
			grid_ptr->setup_cells();
			add_object(grid_ptr);
			break;
		}
	case 202:
		{
			//24.06a
			int num_samples = 16;
	
			vp.set_hres(600); 
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_max_depth(0);			// for Figure 24.6(a)
			//vp.set_max_depth(1);			// for Figure 24.6(b)
	
			tracer_ptr = new Whitted(this);	
			background_color = RGBColor(0.15); 
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(75, 40, 100); 
			pinhole_ptr->set_lookat(-10, 39, 0);  
			pinhole_ptr->set_view_distance(360);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(150, 150, 0);  
			light_ptr->scale_radiance(3.0);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
			// yellow-green reflective sphere
	
			Reflective* reflective_ptr1 = new Reflective;			
			reflective_ptr1->set_ka(0.25); 
			reflective_ptr1->set_kd(0.5);
			reflective_ptr1->set_cd(0.75, 0.75, 0);    	// yellow
			reflective_ptr1->set_ks(0.15);
			reflective_ptr1->set_exp(100.0);
			reflective_ptr1->set_kr(0.75);
			reflective_ptr1->set_cr(white); 			// default color
	
			float radius = 23.0;
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, radius, -25), radius); 
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
	
	
			// orange non-reflective sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.45); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.75, 0.25, 0);   // orange
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-7, 10, 42), 20);
			sphere_ptr2->set_material(matte_ptr1);      
			add_object(sphere_ptr2);
	
	
			// sphere on top of box

			Reflective* reflective_ptr2 = new Reflective;			
			reflective_ptr2->set_ka(0.35); 
			reflective_ptr2->set_kd(0.75);
			reflective_ptr2->set_cd(black); 
			reflective_ptr2->set_ks(0.0);		// default value
			reflective_ptr2->set_exp(1.0);		// default value, but irrelevant in this case
			reflective_ptr2->set_kr(0.75);
			reflective_ptr2->set_cr(white); 

			Sphere* sphere_ptr3 = new Sphere(Point3D(-30, 59, 35), 20);
			sphere_ptr3->set_material(reflective_ptr2);     
			add_object(sphere_ptr3);

	
			// cylinder
	
			Reflective* reflective_ptr3 = new Reflective;			
			reflective_ptr3->set_ka(0.35); 
			reflective_ptr3->set_kd(0.5);
			reflective_ptr3->set_cd(0, 0.5, 0.75);   // cyan
			reflective_ptr3->set_ks(0.2);
			reflective_ptr3->set_exp(100.0);
			reflective_ptr3->set_kr(0.75);
			reflective_ptr3->set_cr(white);
	
			double bottom 			= 0.0;
			double top 				= 85;   
			double cylinder_radius	= 22;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, cylinder_radius);
			cylinder_ptr->set_material(reflective_ptr3);
			add_object(cylinder_ptr);
	
	
			// box
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.15); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.75, 1.0, 0.75);   // light green
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(matte_ptr2);
			add_object(box_ptr);

	
			// ground plane
	
			PlaneChecker* checker_ptr = new PlaneChecker;
			checker_ptr->set_size(20.0);		
			checker_ptr->set_outline_width(2.0);
			checker_ptr->set_color1(white);
			checker_ptr->set_color2(white);
			checker_ptr->set_outline_color(black); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.30);
			sv_matte_ptr->set_kd(0.9);
			sv_matte_ptr->set_cd(checker_ptr); 
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 203:
		{
			//24.06b
			int num_samples = 16;
	
			vp.set_hres(600); 
			vp.set_vres(400);
			vp.set_samples(num_samples);
			//vp.set_max_depth(0);			// for Figure 24.6(a)
			vp.set_max_depth(1);			// for Figure 24.6(b)
	
			tracer_ptr = new Whitted(this);	
			background_color = RGBColor(0.15); 
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(75, 40, 100); 
			pinhole_ptr->set_lookat(-10, 39, 0);  
			pinhole_ptr->set_view_distance(360);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(150, 150, 0);  
			light_ptr->scale_radiance(3.0);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
			// yellow-green reflective sphere
	
			Reflective* reflective_ptr1 = new Reflective;			
			reflective_ptr1->set_ka(0.25); 
			reflective_ptr1->set_kd(0.5);
			reflective_ptr1->set_cd(0.75, 0.75, 0);    	// yellow
			reflective_ptr1->set_ks(0.15);
			reflective_ptr1->set_exp(100.0);
			reflective_ptr1->set_kr(0.75);
			reflective_ptr1->set_cr(white); 			// default color
	
			float radius = 23.0;
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, radius, -25), radius); 
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
	
	
			// orange non-reflective sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.45); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.75, 0.25, 0);   // orange
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-7, 10, 42), 20);
			sphere_ptr2->set_material(matte_ptr1);      
			add_object(sphere_ptr2);
	
	
			// sphere on top of box

			Reflective* reflective_ptr2 = new Reflective;			
			reflective_ptr2->set_ka(0.35); 
			reflective_ptr2->set_kd(0.75);
			reflective_ptr2->set_cd(black); 
			reflective_ptr2->set_ks(0.0);		// default value
			reflective_ptr2->set_exp(1.0);		// default value, but irrelevant in this case
			reflective_ptr2->set_kr(0.75);
			reflective_ptr2->set_cr(white); 

			Sphere* sphere_ptr3 = new Sphere(Point3D(-30, 59, 35), 20);
			sphere_ptr3->set_material(reflective_ptr2);     
			add_object(sphere_ptr3);

	
			// cylinder
	
			Reflective* reflective_ptr3 = new Reflective;			
			reflective_ptr3->set_ka(0.35); 
			reflective_ptr3->set_kd(0.5);
			reflective_ptr3->set_cd(0, 0.5, 0.75);   // cyan
			reflective_ptr3->set_ks(0.2);
			reflective_ptr3->set_exp(100.0);
			reflective_ptr3->set_kr(0.75);
			reflective_ptr3->set_cr(white);
	
			double bottom 			= 0.0;
			double top 				= 85;   
			double cylinder_radius	= 22;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, cylinder_radius);
			cylinder_ptr->set_material(reflective_ptr3);
			add_object(cylinder_ptr);
	
	
			// box
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.15); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.75, 1.0, 0.75);   // light green
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(matte_ptr2);
			add_object(box_ptr);

	
			// ground plane
	
			PlaneChecker* checker_ptr = new PlaneChecker;
			checker_ptr->set_size(20.0);		
			checker_ptr->set_outline_width(2.0);
			checker_ptr->set_color1(white);
			checker_ptr->set_color2(white);
			checker_ptr->set_outline_color(black); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.30);
			sv_matte_ptr->set_kd(0.9);
			sv_matte_ptr->set_cd(checker_ptr); 
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 204:
		{
			//24.07a
			int num_samples = 16;
	
			vp.set_hres(600); 
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_max_depth(10);
	
			tracer_ptr = new Whitted(this);	
			background_color = RGBColor(0.15); 
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(75, 40, 100); 
			pinhole_ptr->set_lookat(-10, 39, 0);  
			pinhole_ptr->set_view_distance(360);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(150, 150, 0);  
			light_ptr->scale_radiance(3.0);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
			// yellow-green reflective sphere
	
			Reflective* reflective_ptr1 = new Reflective;			
			reflective_ptr1->set_ka(0.25); 
			reflective_ptr1->set_kd(0.5);
			reflective_ptr1->set_cd(0.75, 0.75, 0);    	// yellow
			reflective_ptr1->set_ks(0.15);
			reflective_ptr1->set_exp(100.0);
			reflective_ptr1->set_kr(0.75);
			reflective_ptr1->set_cr(white); 			// default color
	
			float radius = 23.0;
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, radius, -25), radius); 
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
	
	
			// orange non-reflective sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.45); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.75, 0.25, 0);   // orange
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-7, 10, 42), 20);
			sphere_ptr2->set_material(matte_ptr1);      
			add_object(sphere_ptr2);
	
	
			// sphere on top of box

			Reflective* reflective_ptr2 = new Reflective;			
			reflective_ptr2->set_ka(0.35); 
			reflective_ptr2->set_kd(0.75);
			reflective_ptr2->set_cd(black); 
			reflective_ptr2->set_ks(0.0);		// default value
			reflective_ptr2->set_exp(1.0);		// default value, but irrelevant in this case
			reflective_ptr2->set_kr(0.75);
			reflective_ptr2->set_cr(white); 

			Sphere* sphere_ptr3 = new Sphere(Point3D(-30, 59, 35), 20);
			sphere_ptr3->set_material(reflective_ptr2);     
			add_object(sphere_ptr3);

	
			// cylinder
	
			Reflective* reflective_ptr3 = new Reflective;			
			reflective_ptr3->set_ka(0.35); 
			reflective_ptr3->set_kd(0.5);
			reflective_ptr3->set_cd(0, 0.5, 0.75);   // cyan
			reflective_ptr3->set_ks(0.2);
			reflective_ptr3->set_exp(100.0);
			reflective_ptr3->set_kr(0.75);
			reflective_ptr3->set_cr(white);
	
			double bottom 			= 0.0;
			double top 				= 85;   
			double cylinder_radius	= 22;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, cylinder_radius);
			cylinder_ptr->set_material(reflective_ptr3);
			add_object(cylinder_ptr);
	
	
			// box
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.15); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.75, 1.0, 0.75);   // light green
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(matte_ptr2);
			add_object(box_ptr);

	
			// ground plane
	
			PlaneChecker* checker_ptr = new PlaneChecker;
			checker_ptr->set_size(20.0);		
			checker_ptr->set_outline_width(2.0);
			checker_ptr->set_color1(white);
			checker_ptr->set_color2(white);
			checker_ptr->set_outline_color(black); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.30);
			sv_matte_ptr->set_kd(0.9);
			sv_matte_ptr->set_cd(checker_ptr); 
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 205:
		{
			//24.07b
			int num_samples = 16;
	
			vp.set_hres(600);  
			vp.set_vres(600);  
			vp.set_samples(num_samples);
			vp.set_max_depth(10);
	
			tracer_ptr = new Whitted(this);	
			background_color = RGBColor(0.15); 
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(2000, 4000, -1000);
			pinhole_ptr->set_lookat(38, 75, -20);
			pinhole_ptr->set_view_distance(45000);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(150, 150, 0);  
			light_ptr->scale_radiance(3.0);
			light_ptr->set_shadows(true);
			add_light(light_ptr);

	
			// yellow-green reflective sphere
	
			Reflective* reflective_ptr1 = new Reflective;			
			reflective_ptr1->set_ka(0.25); 
			reflective_ptr1->set_kd(0.5);
			reflective_ptr1->set_cd(0.75, 0.75, 0);    	// yellow
			reflective_ptr1->set_ks(0.15);
			reflective_ptr1->set_exp(100.0);
			reflective_ptr1->set_kr(0.75);
			reflective_ptr1->set_cr(white); 			// default color
	
			float radius = 23.0;
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, radius, -25), radius); 
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
	
	
			// orange non-reflective sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.45); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.75, 0.25, 0);   // orange
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-7, 10, 42), 20);
			sphere_ptr2->set_material(matte_ptr1);      
			add_object(sphere_ptr2);
	
	
			// sphere on top of box

			Reflective* reflective_ptr2 = new Reflective;			
			reflective_ptr2->set_ka(0.35); 
			reflective_ptr2->set_kd(0.75);
			reflective_ptr2->set_cd(black); 
			reflective_ptr2->set_ks(0.0);		// default value
			reflective_ptr2->set_exp(1.0);		// default value, but irrelevant in this case
			reflective_ptr2->set_kr(0.75);
			reflective_ptr2->set_cr(white); 

			Sphere* sphere_ptr3 = new Sphere(Point3D(-30, 59, 35), 20);
			sphere_ptr3->set_material(reflective_ptr2);     
			add_object(sphere_ptr3);

	
			// cylinder
	
			Reflective* reflective_ptr3 = new Reflective;			
			reflective_ptr3->set_ka(0.35); 
			reflective_ptr3->set_kd(0.5);
			reflective_ptr3->set_cd(0, 0.5, 0.75);   // cyan
			reflective_ptr3->set_ks(0.2);
			reflective_ptr3->set_exp(100.0);
			reflective_ptr3->set_kr(0.75);
			reflective_ptr3->set_cr(white);
	
			double bottom 			= 0.0;
			double top 				= 85;   
			double cylinder_radius	= 22;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, cylinder_radius);
			cylinder_ptr->set_material(reflective_ptr3);
			add_object(cylinder_ptr);
	
	
			// box
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.15); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.75, 1.0, 0.75);   // light green
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(matte_ptr2);
			add_object(box_ptr);

	
			// ground plane
	
			PlaneChecker* checker_ptr = new PlaneChecker;
			checker_ptr->set_size(20.0);		
			checker_ptr->set_outline_width(2.0);
			checker_ptr->set_color1(white);
			checker_ptr->set_color2(white);
			checker_ptr->set_outline_color(black); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.30);
			sv_matte_ptr->set_kd(0.9);
			sv_matte_ptr->set_cd(checker_ptr); 
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 206:
		{
			//24.10
			if( !CheckFile(QString(ppmfile+"uffizi_probe_large.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);			
			vp.set_vres(600);  
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);
			vp.set_max_depth(10);
	
			tracer_ptr = new Whitted(this);		
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(400, 125, 500);   
			pinhole_ptr->set_lookat(0.0, -50, 0);
			pinhole_ptr->set_view_distance(550);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Compound* spheres = new Compound;
		
			float  kr = 0.9;
			double radius = 100.0;
	
			// reflective sphere centered at the origin

			Reflective* reflective_ptrc = new Reflective;			
			reflective_ptrc->set_ka(0.0); 
			reflective_ptrc->set_kd(0.0);
			reflective_ptrc->set_ks(0.0);
			reflective_ptrc->set_cd(0.0);
			reflective_ptrc->set_kr(kr);
			reflective_ptrc->set_cr(0.65, 0.75, 1.0);   // pale blue
		
			Sphere* sphere_ptr = new Sphere(Point3D(0.0), radius);
			sphere_ptr->set_shadows(false);
			sphere_ptr->set_material(reflective_ptrc);
			spheres->add_object(sphere_ptr);
	
			// define materials for the surrounding spheres
	
			vector<Reflective*> materials;	
	
			Reflective* reflective_ptr0 = new Reflective;			
			reflective_ptr0->set_ka(0.0); 
			reflective_ptr0->set_kd(0.0);
			reflective_ptr0->set_ks(0.0);
			reflective_ptr0->set_cd(0.0);
			reflective_ptr0->set_kr(kr);
			reflective_ptr0->set_cr(0.5, 1.0, 0.5);  // light green
			materials.push_back(reflective_ptr0);

			Reflective* reflective_ptr1 = new Reflective;			
			reflective_ptr1->set_ka(0.0); 
			reflective_ptr1->set_kd(0.0);
			reflective_ptr1->set_ks(0.0);
			reflective_ptr1->set_cd(0.0);
			reflective_ptr1->set_kr(kr);
			reflective_ptr1->set_cr(0.4, 1.0, 1.0);  // cyan
			materials.push_back(reflective_ptr1);
	
			Reflective* reflective_ptr2 = new Reflective;			
			reflective_ptr2->set_ka(0.0); 
			reflective_ptr2->set_kd(0.0);
			reflective_ptr2->set_ks(0.0);
			reflective_ptr2->set_cd(0.0);
			reflective_ptr2->set_kr(kr);
			reflective_ptr2->set_cr(1.0, 1.0, 0.4);  // lemon
			materials.push_back(reflective_ptr2);
	
			Reflective* reflective_ptr3 = new Reflective;			
			reflective_ptr3->set_ka(0.0); 
			reflective_ptr3->set_kd(0.0);
			reflective_ptr3->set_ks(0.0);
			reflective_ptr3->set_cd(0.0);
			reflective_ptr3->set_kr(kr);
			reflective_ptr3->set_cr(1.0, 0.5, 1.0);  // mauve
			materials.push_back(reflective_ptr3);
	
			Reflective* reflective_ptr4 = new Reflective;			
			reflective_ptr4->set_ka(0.0); 
			reflective_ptr4->set_kd(0.0);
			reflective_ptr4->set_ks(0.0);
			reflective_ptr4->set_cd(0.0);
			reflective_ptr4->set_kr(kr);
			reflective_ptr4->set_cr(1.0, 0.75, 0.25);  // orange
			materials.push_back(reflective_ptr4);
	
			Reflective* reflective_ptr5 = new Reflective;			
			reflective_ptr5->set_ka(0.0); 
			reflective_ptr5->set_kd(0.0);
			reflective_ptr5->set_ks(0.0);
			reflective_ptr5->set_cd(0.0);
			reflective_ptr5->set_kr(kr);
			reflective_ptr5->set_cr(0.5, 0.5, 1.0);  // blue
			materials.push_back(reflective_ptr5);
	

			// define ring of reflective spheres that just touch the center sphere
			// these are initially in the (x, z) plane
	
			float  num_spheres = 6;
			double theta = 0.0;
			double delta_theta = 2.0 * PI / num_spheres;
	
			for (int j = 0; j < num_spheres; j++) {
				Point3D center((2.0 * radius) * sin(theta), 0.0, (2.0 * radius) * cos(theta));
				Sphere* sphere_ptr = new Sphere(center, radius);
				sphere_ptr->set_material(materials[j]);
				spheres->add_object(sphere_ptr);
				theta += delta_theta;
			}
		
			// now rotate the spheres

			Instance* rotated_spheres_ptr = new Instance(spheres);
			rotated_spheres_ptr->rotate_x(40.0);
			rotated_spheres_ptr->rotate_z(-40.0);
			add_object(rotated_spheres_ptr);

	
			// large sphere with Uffizi image
	
			Image* image_ptr = new Image;
		//	image_ptr->read_ppm_file("uffizi_probe_small.ppm");   // for testing 
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_large.ppm").toLatin1().data());   // for production
	
			//THis should be LightProbeMap but not LightProbe
			LightProbeMap* light_probe_ptr = new LightProbeMap;     		
	
			ImageTexture* texture_ptr = new ImageTexture(image_ptr); 
			texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr1 = new Instance(unit_sphere_ptr); 
			sphere_ptr1->set_material(sv_matte_ptr);
			sphere_ptr1->scale(1000000.0);
			add_object(sphere_ptr1);

			break;
		}
	case 207:
		{
			//24.11
			if( !CheckFile(QString(ppmfile+"MorningSky.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(900);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);
			vp.set_max_depth(20);
	
			tracer_ptr = new Whitted(this);	
	
			Spherical* spherical_ptr = new Spherical;
			spherical_ptr->set_eye(10, 15, 13);     
			spherical_ptr->set_lookat(34, 15, 0);
			spherical_ptr->set_horizontal_fov(180);  
			spherical_ptr->set_vertical_fov(120);  
			spherical_ptr->compute_uvw(); 
			set_camera(spherical_ptr);
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(150, 500, 300);  
			light_ptr2->scale_radiance(3.75);  
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// city parameters
	
			float 	a					= 10;   // city block width:  xw extent
			float 	b   				= 12;	// city block length:  yw extent
			int 	num_rows			= 10;  	// number of blocks in the xw direction
			int 	num_columns			= 12; 	// number of blocks in the zw direction
			float	width				= 7;	// building width: xw extent in range [min, a - offset]
			float 	length				= 7;	// building length: zw extent in range [min, b - offset]
			float 	min_size			= 6;	// mininum building extent in xw and yw directions
			float 	offset				= 1.0;	// half the minimum distance between buildings
			float 	min_height			= 0.0; 	// minimum building height
			float 	max_height			= 30; 	// maximum bulding height
			float 	height;						// the building height in range [min_height, max_height]
			int		num_park_rows		= 4;  	// number of blocks of park in xw direction
			int		num_park_columns	= 6;  	// number of blocks of park in xw direction
			int 	row_test;					// there are no buildings in the park
			int 	column_test;				// there are no buildings in the park
			float 	min_color			= 0.5;  // prevents black buildings
			float 	max_color			= 0.9;	// prevents white buildings
			
			set_rand_seed(15);  				// as the buildings' dimensions and colors are random, it's necessary to 
												// seed rand to keep these quantities the same at each run
												// if you leave this out, and change the number of samples per pixel,
												// these will change
	
			// the buildings are stored in a grid
	
			Grid* grid_ptr = new Grid;
	
			for (int r = 0; r < num_rows; r++)  			// xw direction
				for (int c = 0; c < num_columns; c++) {		// zw direction
					// determine if the block is in the park
		
					if ((r - num_rows / 2) >= 0)
						row_test = r -  num_rows / 2;
					else
						row_test = r -  num_rows / 2 + 1;
				
					if ((c - num_columns / 2) >= 0)
						column_test = c - num_columns / 2;
					else
						column_test = c - num_columns / 2 + 1;
			
					if (abs(row_test) >= (num_park_rows / 2) || abs(column_test) >= (num_park_columns / 2)) {
		
						Reflective* reflective_ptr = new Reflective;			
						reflective_ptr->set_ka(0.0); 
						reflective_ptr->set_kd(0.0);
						reflective_ptr->set_ks(0.0);
						reflective_ptr->set_cd(0.0);
						reflective_ptr->set_kr(1.0);
						reflective_ptr->set_cr(	min_color + rand_float() * (max_color - min_color), 
												min_color + rand_float() * (max_color - min_color), 
												min_color + rand_float() * (max_color - min_color));				 
			
						// block center coordinates
				
						float xc = a * (r - num_rows / 2.0 + 0.5);
						float zc = b * (c - num_columns / 2.0 + 0.5);
				
						width = min_size + rand_float() * (a - 2 * offset - min_size);
						length = min_size + rand_float() * (b - 2 * offset - min_size);
				
						// minimum building coordinates
				
						float xmin = xc - width / 2.0;
						float ymin = 0.0;
						float zmin = zc - length / 2.0;
				
						// maximum building coordinates
				
						height = min_height + rand_float() * (max_height - min_height);
				
						// The following is a hack to make the middle row and column of buildings higher
						// on average than the other buildings. 
						// This only works properly when there are three rows and columns of buildings
				
						if (r == 1 || r == num_rows - 2 || c == 1 || c == num_columns - 2)
							height *= 1.5;
				
						float xmax = xc + width / 2.0;
						float ymax = height;
						float zmax = zc + length / 2.0;
				
						Box* building_ptr = new  Box(Point3D(xmin, ymin, zmin), Point3D(xmax, ymax, zmax));
			//			building_ptr->set_material(matte_ptr);
						building_ptr->set_material(reflective_ptr);
						grid_ptr->add_object(building_ptr);
					}
				}
		
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
	
			// render the park with small green checkers
	
			Checker3D* checker3D_ptr1 = new Checker3D;
			checker3D_ptr1->set_size(5); 
			checker3D_ptr1->set_color1(0.35, 0.75, 0.35);  
			checker3D_ptr1->set_color2(0.3, 0.5, 0.3);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.3);
			sv_matte_ptr1->set_kd(0.50);  
			sv_matte_ptr1->set_cd(checker3D_ptr1);
											
			Box* park_ptr = new Box( Point3D(-a * num_park_rows / 2, 0.0, -b * num_park_columns / 2), 
									Point3D(a * num_park_rows / 2, 0.1, b * num_park_columns / 2)  );										
			park_ptr->set_material(sv_matte_ptr1);
			add_object(park_ptr);
											
	
			// ground plane with checkers:
	
			Checker3D* checker3D_ptr2 = new Checker3D;
			checker3D_ptr2->set_size(50); 
			checker3D_ptr2->set_color1(RGBColor(0.7));  
			checker3D_ptr2->set_color2(RGBColor(1));
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.30);
			sv_matte_ptr2->set_kd(0.40);  
			sv_matte_ptr2->set_cd(checker3D_ptr2);
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr2);
			add_object(plane_ptr);

	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"MorningSky.ppm").toLatin1().data());	
	
			SphericalMap* spherical_map_ptr = new SphericalMap; 
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(spherical_map_ptr); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85); 
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr = new Instance(unit_sphere_ptr); 
			sphere_ptr->scale(1000000);
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 208:
		{
			//24.15a
			int num_samples = 25;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_max_depth(10);
	
			tracer_ptr = new Whitted(this);
	
			background_color = black; 
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);	


			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-200, 100, -100);   
			pinhole_ptr->set_lookat(0, 40, 30);    
			pinhole_ptr->set_view_distance(1000);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(5.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.0);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.0);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// large emissive sphere with lines 
			// this is not a light source
	
			SphereChecker* checker_ptr1 = new SphereChecker;  // can only be applied to a generic sphere
			checker_ptr1->set_num_horizontal(16);
			checker_ptr1->set_num_vertical(16);    
			checker_ptr1->set_horizontal_line_width(0.075);
			checker_ptr1->set_vertical_line_width(0.075);
			checker_ptr1->set_color1(0.75, 1.0, 0.25);   // yellow
			checker_ptr1->set_color2(0.75, 1.0, 0.25);   // yellow
			checker_ptr1->set_line_color(black);
	
			SV_Emissive* sv_emissive_ptr = new SV_Emissive;
			sv_emissive_ptr->set_ce(checker_ptr1);
			sv_emissive_ptr->scale_radiance(1.5);
	
		
			Sphere* sphere_ptr1 = new Sphere;
			sphere_ptr1->set_material(sv_emissive_ptr);
	
			Instance* sphere_ptr2 = new Instance(sphere_ptr1);
			sphere_ptr2->scale(30);
			sphere_ptr2->translate(0, 50, 45);
			add_object(sphere_ptr2);
	
	
			// reflective sphere
	
			Reflective* reflective_ptr = new Reflective;			
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0); 
			reflective_ptr->set_cd(1.0);
			reflective_ptr->set_ks(0.15);
			reflective_ptr->set_exp(300.0);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 0.75, 0.25);  // orange
	
			Sphere* sphere_ptr3 = new Sphere;
			sphere_ptr3->set_material(reflective_ptr);

			// we are using a transformed generic sphere here because it will
			// have a textured material in Figure 24.15(c) and Figure 24.16.

			Instance* sphere_ptr4 = new Instance(sphere_ptr3);
			sphere_ptr4->scale(3.0);
			sphere_ptr4->translate(0.0, 4.5, 0.0);
			add_object(sphere_ptr4);
	
	
			// rectangle
	
			Checker3D* checker_ptr2 = new Checker3D;
			checker_ptr2->set_size(4.0);
			checker_ptr2->set_color1(0.5);  
			checker_ptr2->set_color2(white);	 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr2);		
		
			TRectangle* rectangle_ptr = new TRectangle(Point3D(-20, -0.001, -100), Vector3D(0, 0, 120), Vector3D(40, 0, 0)); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);
			break;
		}
	case 209:
		{
			//24.15b
			int num_samples = 25;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_max_depth(10);
	
			tracer_ptr = new Whitted(this);
	
			background_color = black; 
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);	


			// the camera is looking at the center of the reflective sphere

			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-8, 20, 40);   
			pinhole_ptr->set_lookat(0, 4.5, 0);     
			pinhole_ptr->set_view_distance(2700);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(5.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.0);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.0);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
	
			// large emissive sphere with lines
			// this is not a light source 
	
			SphereChecker* checker_ptr1 = new SphereChecker;  // can only be applied to a generic sphere
			checker_ptr1->set_num_horizontal(16);
			checker_ptr1->set_num_vertical(16);    
			checker_ptr1->set_horizontal_line_width(0.075);
			checker_ptr1->set_vertical_line_width(0.075);
			checker_ptr1->set_color1(0.75, 1.0, 0.25);   // yellow
			checker_ptr1->set_color2(0.75, 1.0, 0.25);   // yellow
			checker_ptr1->set_line_color(black);
	
			SV_Emissive* sv_emissive_ptr = new SV_Emissive;
			sv_emissive_ptr->set_ce(checker_ptr1);
			sv_emissive_ptr->scale_radiance(1.5);      
	
		
			Sphere* sphere_ptr1 = new Sphere;
			sphere_ptr1->set_material(sv_emissive_ptr);
	
			Instance* sphere_ptr2 = new Instance(sphere_ptr1);
			sphere_ptr2->scale(30);
			sphere_ptr2->translate(0, 50, 45);
			add_object(sphere_ptr2);
	
	
			// reflective sphere
	
			Reflective* reflective_ptr = new Reflective;			
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0); 
			reflective_ptr->set_cd(1.0);
			reflective_ptr->set_ks(0.15);
			reflective_ptr->set_exp(300.0);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 0.75, 0.25);  // orange
	
			Sphere* sphere_ptr3 = new Sphere;
			sphere_ptr3->set_material(reflective_ptr);

			// we are using a transformed generic sphere here, because it will
			// have a textured material in Figure 24.15(c) and Figure 24.16.

			Instance* sphere_ptr4 = new Instance(sphere_ptr3);
			sphere_ptr4->scale(3.0);
			sphere_ptr4->translate(0.0, 4.5, 0.0);
			add_object(sphere_ptr4);
	
	
			// rectangle
	
			Checker3D* checker_ptr2 = new Checker3D;
			checker_ptr2->set_size(4.0);
			checker_ptr2->set_color1(0.5);  
			checker_ptr2->set_color2(white);	 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr2);		
		
			TRectangle* rectangle_ptr = new TRectangle(Point3D(-20, -0.001, -100), Vector3D(0, 0, 120), Vector3D(40, 0, 0)); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);
			break;
		}
	case 210:
		{
			//24.15c
			int num_samples = 1;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_max_depth(10);
	
			tracer_ptr = new Whitted(this);
	
			background_color = black; 
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);	


			// the camera is looking at the center of the reflective sphere

			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-8, 20, 40);   
			pinhole_ptr->set_lookat(0, 4.5, 0);     
			pinhole_ptr->set_view_distance(2700);		
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(5.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.0);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.0);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
	
			// large emissive sphere with lines
			// this is not a light source 
	
			SphereChecker* checker_ptr1 = new SphereChecker;  // can only be applied to a generic sphere
			checker_ptr1->set_num_horizontal(16);
			checker_ptr1->set_num_vertical(16);    
			checker_ptr1->set_horizontal_line_width(0.075);
			checker_ptr1->set_vertical_line_width(0.075);
			checker_ptr1->set_color1(0.75, 1.0, 0.25);   // yellow
			checker_ptr1->set_color2(0.75, 1.0, 0.25);   // yellow
			checker_ptr1->set_line_color(black);
	
			SV_Emissive* sv_emissive_ptr = new SV_Emissive;
			sv_emissive_ptr->set_ce(checker_ptr1);
			sv_emissive_ptr->scale_radiance(1.5);      
	
		
			Sphere* sphere_ptr1 = new Sphere;
		//	sphere_ptr1->set_shadows(false);
			sphere_ptr1->set_material(sv_emissive_ptr);
	
			Instance* sphere_ptr2 = new Instance(sphere_ptr1);
			sphere_ptr2->scale(30);
			sphere_ptr2->translate(0, 50, 45);
			add_object(sphere_ptr2);
	
	

			// reflective sphere
	
			// We use a SphereMaterials material for the reflective sphere.
			// This material is like the SphereChecker texture in that it can be used to render
			// checkers on a generic sphere, but it allows different materials to be used for the
			// the checkers and the lines.
			// You can implement this as an exercise.
			// In this figure, the reflective material in Figures 24.15(a) and (b) is used for 
			// both checkers, and a red emissive material is used for the lines.
			// A red Matte material for the lines is shaded from the three lights with the result that
			// the lines are not of constant brightness.
			// A reflective material for the lines with red for the diffuse and reflective colors is still
			// shaded, and also picks up the reflected colors from the emissive sphere and plane.
			// In contrast, an emissive material emits constant radiance, and is not reflective.
	
			Reflective* reflective_ptr = new Reflective;			
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0); 
			reflective_ptr->set_cd(1.0);
			reflective_ptr->set_ks(0.15);
			reflective_ptr->set_exp(300.0);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 0.75, 0.25);  // orange
	
			Emissive* emissive_ptr = new Emissive;   
			emissive_ptr->set_ce(0.85);	
			emissive_ptr->set_ce(0, 0.75, 0);
			emissive_ptr->set_ce(0.85, 0, 0);		// red		
			emissive_ptr->scale_radiance(0.85);  
	
			SphereMaterials* sphere_materials_ptr = new SphereMaterials;
			sphere_materials_ptr->set_num_horizontal(16);
			sphere_materials_ptr->set_num_vertical(8);
			sphere_materials_ptr->set_line_width(0.04);
			sphere_materials_ptr->set_checker1_material(reflective_ptr);
			sphere_materials_ptr->set_checker2_material(reflective_ptr);
			sphere_materials_ptr->set_line_material(emissive_ptr);
	
	
			Sphere* sphere_ptr3 = new Sphere;
			sphere_ptr3->set_material(reflective_ptr);
			sphere_ptr3->set_material(sphere_materials_ptr);

			Instance* sphere_ptr4 = new Instance(sphere_ptr3);
			sphere_ptr4->scale(3.0);
			sphere_ptr4->translate(0.0, 4.5, 0.0);
			add_object(sphere_ptr4);
	
	
			// rectangle
	
			Checker3D* checker_ptr2 = new Checker3D;
			checker_ptr2->set_size(4.0);
			checker_ptr2->set_color1(0.5);  
			checker_ptr2->set_color2(white);	 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr2);	
		
			TRectangle* rectangle_ptr = new TRectangle(Point3D(-20, -0.001, -100), Vector3D(0, 0, 120), Vector3D(40, 0, 0)); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);
			break;
		}
	case 211:
		{
			//24.16
			int num_samples = 25;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_max_depth(10);
	
			tracer_ptr = new Whitted(this);
	
			background_color = black; 
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);	
	
			float vpd = 2400.0;

			Pinhole* left_pinhole_ptr = new Pinhole;
			left_pinhole_ptr->set_view_distance(vpd);
	
			Pinhole* right_pinhole_ptr = new Pinhole;
			right_pinhole_ptr->set_view_distance(vpd);
	
			StereoCamera* stereo_ptr = new StereoCamera(left_pinhole_ptr, right_pinhole_ptr);
			stereo_ptr->use_parallel_viewing();
		//	stereo_ptr->use_transverse_viewing();
			stereo_ptr->set_pixel_gap(5);
			stereo_ptr->set_eye(-8, 20, 40); 
			stereo_ptr->set_lookat(0, 4.5, 0); 
			stereo_ptr->compute_uvw(); 
			stereo_ptr->set_stereo_angle(1.5);  // in degrees
			stereo_ptr->setup_cameras(); 
			set_camera(stereo_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(5.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.0);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);

	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.0);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
	
			// large emissive sphere with lines
			// this is not a light source 
	
			SphereChecker* checker_ptr1 = new SphereChecker;  // can only be applied to a generic sphere
			checker_ptr1->set_num_horizontal(16);
			checker_ptr1->set_num_vertical(16);    
			checker_ptr1->set_horizontal_line_width(0.075);
			checker_ptr1->set_vertical_line_width(0.075);
			checker_ptr1->set_color1(0.75, 1.0, 0.25);   // yellow
			checker_ptr1->set_color2(0.75, 1.0, 0.25);   // yellow
			checker_ptr1->set_line_color(black);
	
			SV_Emissive* sv_emissive_ptr = new SV_Emissive;
			sv_emissive_ptr->set_ce(checker_ptr1);
			sv_emissive_ptr->scale_radiance(1.5);      
	
		
			Sphere* sphere_ptr1 = new Sphere;
			sphere_ptr1->set_material(sv_emissive_ptr);
	
			Instance* sphere_ptr2 = new Instance(sphere_ptr1);
			sphere_ptr2->scale(30);
			sphere_ptr2->translate(0, 50, 45);
			add_object(sphere_ptr2);
	
	

			// reflective sphere
	
			// We use a SphereMaterials material for the reflective sphere.
			// This material is like the SphereChecker texture in that it can be used to render
			// checkers on a generic sphere, but it allows different materials to be used for the
			// the checkers and the lines.
			// You can implement this as an exercise.
			// In this figure, the reflective material in Figures 24.15(a) and (b) is used for 
			// both checkers, and a red emissive material is used for the lines.
			// A red Matte material for the lines is shaded from the three lights with the result that
			// the lines are not of constant brightness.
			// A reflective material for the lines with red for the diffuse and reflective colors is still
			// shaded, and also picks up the reflected colors from the emissive sphere and plane.
			// In contrast, an emissive material emits constant radiance, and is not reflective.
	
			Reflective* reflective_ptr = new Reflective;			
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0); 
			reflective_ptr->set_cd(1.0);
			reflective_ptr->set_ks(0.15);
			reflective_ptr->set_exp(300.0);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 0.75, 0.25);  // orange
	
			Emissive* emissive_ptr = new Emissive;   
			emissive_ptr->set_ce(0.85);	
			emissive_ptr->set_ce(0, 0.75, 0);
			emissive_ptr->set_ce(0.85, 0, 0);		// red		
			emissive_ptr->scale_radiance(0.85);  
	
			SphereMaterials* sphere_materials_ptr = new SphereMaterials;
			sphere_materials_ptr->set_num_horizontal(16);
			sphere_materials_ptr->set_num_vertical(8);
			sphere_materials_ptr->set_line_width(0.04);
			sphere_materials_ptr->set_checker1_material(reflective_ptr);
			sphere_materials_ptr->set_checker2_material(reflective_ptr);
			sphere_materials_ptr->set_line_material(emissive_ptr);
	
	
			Sphere* sphere_ptr3 = new Sphere;
			sphere_ptr3->set_material(reflective_ptr);
			sphere_ptr3->set_material(sphere_materials_ptr);

			Instance* sphere_ptr4 = new Instance(sphere_ptr3);
			sphere_ptr4->scale(3.0);
			sphere_ptr4->translate(0.0, 4.5, 0.0);
			add_object(sphere_ptr4);
	
	
			// rectangle
	
			Checker3D* checker_ptr2 = new Checker3D;
			checker_ptr2->set_size(4.0);
			checker_ptr2->set_color1(0.5);  
			checker_ptr2->set_color2(white);	 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr2);	
		
			TRectangle* rectangle_ptr = new TRectangle(Point3D(-20, -0.001, -100), Vector3D(0, 0, 120), Vector3D(40, 0, 0)); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);
			break;
		}
	case 212:
		{
			//24.17a
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);        
			vp.set_samples(num_samples);
			vp.set_max_depth(0);	//  for Figure 24.17(a)
		//	vp.set_max_depth(1);	//  for Figure 24.17(b)
		//	vp.set_max_depth(2);	//  for Figure 24.17(c)
	
			tracer_ptr = new Whitted(this);
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7.5, 3, 9.5);
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->set_view_distance(300.0);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			// four point lights near the ceiling
			// these don't use distance attenuation

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(10, 10, 0); 
			light_ptr1->scale_radiance(2.0); 
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);
    
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(0, 10, 10); 
			light_ptr2->scale_radiance(2.0); 
			light_ptr2->set_shadows(true); 
			add_light(light_ptr2);
    
			PointLight* light_ptr3 = new PointLight;
			light_ptr3->set_location(-10, 10, 0); 
			light_ptr3->scale_radiance(2.0); 
			light_ptr3->set_shadows(true); 
			add_light(light_ptr3);
    
			PointLight* light_ptr4 = new PointLight;
			light_ptr4->set_location(0, 10, -10); 
			light_ptr4->scale_radiance(2.0); 
			light_ptr4->set_shadows(true); 
			add_light(light_ptr4);

		
			// sphere
			// this is the only reflective object with a direct illumination shading component
	
			Reflective* reflective_ptr1 = new Reflective;			
			reflective_ptr1->set_ka(0.1); 
			reflective_ptr1->set_kd(0.4); 
			reflective_ptr1->set_cd(0, 0, 1);   	 // blue
			reflective_ptr1->set_ks(0.25);
			reflective_ptr1->set_exp(100.0);
			reflective_ptr1->set_kr(0.85); 
			reflective_ptr1->set_cr(0.75, 0.75, 1);  // blue 
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(0, 0.5, 0), 4); 
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
		
	
			// the walls, the ceiling, and the floor of the room are defined as planes
			// the shape is a cube
	
			double room_size = 11.0;
	
			// floor  (-ve yw)
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.1);   
			matte_ptr1->set_kd(0.50);
			matte_ptr1->set_cd(0.25);     // medium grey
	
			Plane* floor_ptr = new Plane(Point3D(0, -room_size,  0), Normal(0, 1, 0));
			floor_ptr->set_material(matte_ptr1);        
			add_object(floor_ptr);
	
	
			// ceiling  (+ve yw)
	
			Matte* matte_ptr2 = new Matte;   
			matte_ptr2->set_ka(0.35);   
			matte_ptr2->set_kd(0.50);
			matte_ptr2->set_cd(white);
	
			Plane* ceiling_ptr = new Plane(Point3D(0, room_size,  0), Normal(0, -1, 0));
			ceiling_ptr->set_material(matte_ptr2);        
			add_object(ceiling_ptr);
	
	
			// back wall  (-ve zw)
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.15); 
			matte_ptr3->set_kd(0.60);
			matte_ptr3->set_cd(0.5, 0.75, 0.75);     // cyan
	
			Plane* backWall_ptr = new Plane(Point3D(0, 0,  -room_size), Normal(0, 0, 1));
			backWall_ptr->set_material(matte_ptr3);        
			add_object(backWall_ptr);
	
			// front wall  (+ve zw)
	
			Plane* frontWall_ptr = new Plane(Point3D(0, 0,  room_size), Normal(0, 0, -1));
			frontWall_ptr->set_material(matte_ptr3);        
			add_object(frontWall_ptr);
	
			// left wall  (-ve xw)
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(0.15); 
			matte_ptr4->set_kd(0.60);
			matte_ptr4->set_cd(0.71, 0.40, 0.20);   // orange
	
			Plane* leftWall_ptr = new Plane(Point3D(-room_size, 0, 0), Normal(1, 0, 0));
			leftWall_ptr->set_material(matte_ptr4);        
			add_object(leftWall_ptr);
	
			// right wall  (+ve xw)
	
			Plane* rightWall_ptr = new Plane(Point3D(room_size, 0, 0), Normal(-1, 0, 0));
			rightWall_ptr->set_material(matte_ptr4);        
			add_object(rightWall_ptr);
	
	
			// mirrors on the walls
			// the right wall has no mirror
	
			double mirror_size 	= 8;  	// the mirror size
			double offset 		= 1.0;  // the mirror offset from the walls
	
			// mirror material
			// this has no direct illumination and a slight green tint
	
			Reflective* reflective_ptr2 = new Reflective;			
			reflective_ptr2->set_ka(0); 
			reflective_ptr2->set_kd(0);
			reflective_ptr2->set_cd(black); 
			reflective_ptr2->set_ks(0);
			reflective_ptr2->set_kr(0.9);
			reflective_ptr2->set_cr(0.9, 1.0, 0.9);  // light green
	
			// back wall mirror  (-ve zw)

			Point3D p0;
			Vector3D a, b;
	
			p0 = Point3D(-mirror_size, -mirror_size, -(room_size - offset));
			a = Vector3D(2.0 * mirror_size, 0, 0);
			b = Vector3D(0, 2.0 * mirror_size, 0);
			Normal n(0, 0, 1);
			TRectangle* rectangle_ptr1 = new TRectangle(p0, a, b, n);
			rectangle_ptr1->set_material(reflective_ptr2); 
			add_object(rectangle_ptr1);
	
	
			// front wall mirror  (+ve zw)
	
			p0 = Point3D(-mirror_size, -mirror_size, +(room_size - offset));
			n = Normal(0, 0, -1);
			TRectangle* rectangle_ptr2 = new TRectangle(p0, a, b, n);
			rectangle_ptr2->set_material(reflective_ptr2); 
			add_object(rectangle_ptr2);
	
	
			// left wall mirror  (-ve xw)
	
			p0 = Point3D(-(room_size - offset), -mirror_size, +mirror_size);
			a = Point3D(0, 0, -2.0 * mirror_size);
			n = Normal(1, 0, 0);
			TRectangle* rectangle_ptr3 = new TRectangle(p0, a, b, n);
			rectangle_ptr3->set_material(reflective_ptr2); 
			add_object(rectangle_ptr3);


			// horizontal mirror underneath the sphere
			// this has no direct illumination and a lemon color
	
			Reflective* reflective_ptr3 = new Reflective;			
			reflective_ptr3->set_ka(0); 
			reflective_ptr3->set_kd(0);
			reflective_ptr3->set_cd(black); 
			reflective_ptr3->set_ks(0);
			reflective_ptr3->set_kr(1);
			reflective_ptr3->set_cr(1, 1, 0.5);  // lemon
	
			double yw = -4.0;   // the yw location of the mirror
	
			p0 = Point3D(-mirror_size, yw, -mirror_size);
			a = Vector3D(0, 0, 2.0 * mirror_size);
			b = Vector3D(2.0 * mirror_size, 0, 0);
			n = Normal(0, 1, 0);
			TRectangle* rectangle_ptr4 = new TRectangle(p0, a, b, n);
			rectangle_ptr4->set_material(reflective_ptr3); 
			add_object(rectangle_ptr4);
			break;
		}
	case 213:
		{
			//24.17b
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);        
			vp.set_samples(num_samples);
		//	vp.set_max_depth(0);	//  for Figure 24.17(a)
			vp.set_max_depth(1);	//  for Figure 24.17(b)
		//	vp.set_max_depth(2);	//  for Figure 24.17(c)
	
			tracer_ptr = new Whitted(this);
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7.5, 3, 9.5);
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->set_view_distance(300.0);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			// four point lights near the ceiling
			// these don't use distance attenuation

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(10, 10, 0); 
			light_ptr1->scale_radiance(2.0); 
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);
    
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(0, 10, 10); 
			light_ptr2->scale_radiance(2.0); 
			light_ptr2->set_shadows(true); 
			add_light(light_ptr2);
    
			PointLight* light_ptr3 = new PointLight;
			light_ptr3->set_location(-10, 10, 0); 
			light_ptr3->scale_radiance(2.0); 
			light_ptr3->set_shadows(true); 
			add_light(light_ptr3);
    
			PointLight* light_ptr4 = new PointLight;
			light_ptr4->set_location(0, 10, -10); 
			light_ptr4->scale_radiance(2.0); 
			light_ptr4->set_shadows(true); 
			add_light(light_ptr4);

		
			// sphere
			// this is the only reflective object with a direct illumination shading component
	
			Reflective* reflective_ptr1 = new Reflective;			
			reflective_ptr1->set_ka(0.1); 
			reflective_ptr1->set_kd(0.4); 
			reflective_ptr1->set_cd(0, 0, 1);   	 // blue
			reflective_ptr1->set_ks(0.25);
			reflective_ptr1->set_exp(100.0);
			reflective_ptr1->set_kr(0.85); 
			reflective_ptr1->set_cr(0.75, 0.75, 1);  // blue 
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(0, 0.5, 0), 4); 
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
		
	
			// the walls, the ceiling, and the floor of the room are defined as planes
			// the shape is a cube
	
			double room_size = 11.0;
	
			// floor  (-ve yw)
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.1);   
			matte_ptr1->set_kd(0.50);
			matte_ptr1->set_cd(0.25);     // medium grey
	
			Plane* floor_ptr = new Plane(Point3D(0, -room_size,  0), Normal(0, 1, 0));
			floor_ptr->set_material(matte_ptr1);        
			add_object(floor_ptr);
	
	
			// ceiling  (+ve yw)
	
			Matte* matte_ptr2 = new Matte;   
			matte_ptr2->set_ka(0.35);   
			matte_ptr2->set_kd(0.50);
			matte_ptr2->set_cd(white);
	
			Plane* ceiling_ptr = new Plane(Point3D(0, room_size,  0), Normal(0, -1, 0));
			ceiling_ptr->set_material(matte_ptr2);        
			add_object(ceiling_ptr);
	
	
			// back wall  (-ve zw)
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.15); 
			matte_ptr3->set_kd(0.60);
			matte_ptr3->set_cd(0.5, 0.75, 0.75);     // cyan
	
			Plane* backWall_ptr = new Plane(Point3D(0, 0,  -room_size), Normal(0, 0, 1));
			backWall_ptr->set_material(matte_ptr3);        
			add_object(backWall_ptr);
	
			// front wall  (+ve zw)
	
			Plane* frontWall_ptr = new Plane(Point3D(0, 0,  room_size), Normal(0, 0, -1));
			frontWall_ptr->set_material(matte_ptr3);        
			add_object(frontWall_ptr);
	
			// left wall  (-ve xw)
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(0.15); 
			matte_ptr4->set_kd(0.60);
			matte_ptr4->set_cd(0.71, 0.40, 0.20);   // orange
	
			Plane* leftWall_ptr = new Plane(Point3D(-room_size, 0, 0), Normal(1, 0, 0));
			leftWall_ptr->set_material(matte_ptr4);        
			add_object(leftWall_ptr);
	
			// right wall  (+ve xw)
	
			Plane* rightWall_ptr = new Plane(Point3D(room_size, 0, 0), Normal(-1, 0, 0));
			rightWall_ptr->set_material(matte_ptr4);        
			add_object(rightWall_ptr);
	
	
			// mirrors on the walls
			// the right wall has no mirror
	
			double mirror_size 	= 8;  	// the mirror size
			double offset 		= 1.0;  // the mirror offset from the walls
	
			// mirror material
			// this has no direct illumination and a slight green tint
	
			Reflective* reflective_ptr2 = new Reflective;			
			reflective_ptr2->set_ka(0); 
			reflective_ptr2->set_kd(0);
			reflective_ptr2->set_cd(black); 
			reflective_ptr2->set_ks(0);
			reflective_ptr2->set_kr(0.9);
			reflective_ptr2->set_cr(0.9, 1.0, 0.9);  // light green
	
			// back wall mirror  (-ve zw)

			Point3D p0;
			Vector3D a, b;
	
			p0 = Point3D(-mirror_size, -mirror_size, -(room_size - offset));
			a = Vector3D(2.0 * mirror_size, 0, 0);
			b = Vector3D(0, 2.0 * mirror_size, 0);
			Normal n(0, 0, 1);
			TRectangle* rectangle_ptr1 = new TRectangle(p0, a, b, n);
			rectangle_ptr1->set_material(reflective_ptr2); 
			add_object(rectangle_ptr1);
	
	
			// front wall mirror  (+ve zw)
	
			p0 = Point3D(-mirror_size, -mirror_size, +(room_size - offset));
			n = Normal(0, 0, -1);
			TRectangle* rectangle_ptr2 = new TRectangle(p0, a, b, n);
			rectangle_ptr2->set_material(reflective_ptr2); 
			add_object(rectangle_ptr2);
	
	
			// left wall mirror  (-ve xw)
	
			p0 = Point3D(-(room_size - offset), -mirror_size, +mirror_size);
			a = Point3D(0, 0, -2.0 * mirror_size);
			n = Normal(1, 0, 0);
			TRectangle* rectangle_ptr3 = new TRectangle(p0, a, b, n);
			rectangle_ptr3->set_material(reflective_ptr2); 
			add_object(rectangle_ptr3);


			// horizontal mirror underneath the sphere
			// this has no direct illumination and a lemon color
	
			Reflective* reflective_ptr3 = new Reflective;			
			reflective_ptr3->set_ka(0); 
			reflective_ptr3->set_kd(0);
			reflective_ptr3->set_cd(black); 
			reflective_ptr3->set_ks(0);
			reflective_ptr3->set_kr(1);
			reflective_ptr3->set_cr(1, 1, 0.5);  // lemon
	
			double yw = -4.0;   // the yw location of the mirror
	
			p0 = Point3D(-mirror_size, yw, -mirror_size);
			a = Vector3D(0, 0, 2.0 * mirror_size);
			b = Vector3D(2.0 * mirror_size, 0, 0);
			n = Normal(0, 1, 0);
			TRectangle* rectangle_ptr4 = new TRectangle(p0, a, b, n);
			rectangle_ptr4->set_material(reflective_ptr3); 
			add_object(rectangle_ptr4);
			break;
		}
	case 214:
		{
			//24.17c
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);        
			vp.set_samples(num_samples);
		//	vp.set_max_depth(0);	//  for Figure 24.17(a)
		//	vp.set_max_depth(1);	//  for Figure 24.17(b)
			vp.set_max_depth(2);	//  for Figure 24.17(c)
	
			tracer_ptr = new Whitted(this);
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7.5, 3, 9.5);
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->set_view_distance(300.0);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			// four point lights near the ceiling
			// these don't use distance attenuation

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(10, 10, 0); 
			light_ptr1->scale_radiance(2.0); 
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);
    
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(0, 10, 10); 
			light_ptr2->scale_radiance(2.0); 
			light_ptr2->set_shadows(true); 
			add_light(light_ptr2);
    
			PointLight* light_ptr3 = new PointLight;
			light_ptr3->set_location(-10, 10, 0); 
			light_ptr3->scale_radiance(2.0); 
			light_ptr3->set_shadows(true); 
			add_light(light_ptr3);
    
			PointLight* light_ptr4 = new PointLight;
			light_ptr4->set_location(0, 10, -10); 
			light_ptr4->scale_radiance(2.0); 
			light_ptr4->set_shadows(true); 
			add_light(light_ptr4);

		
			// sphere
			// this is the only reflective object with a direct illumination shading component
	
			Reflective* reflective_ptr1 = new Reflective;			
			reflective_ptr1->set_ka(0.1); 
			reflective_ptr1->set_kd(0.4); 
			reflective_ptr1->set_cd(0, 0, 1);   	 // blue
			reflective_ptr1->set_ks(0.25);
			reflective_ptr1->set_exp(100.0);
			reflective_ptr1->set_kr(0.85); 
			reflective_ptr1->set_cr(0.75, 0.75, 1);  // blue 
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(0, 0.5, 0), 4); 
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
		
	
			// the walls, the ceiling, and the floor of the room are defined as planes
			// the shape is a cube
	
			double room_size = 11.0;
	
			// floor  (-ve yw)
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.1);   
			matte_ptr1->set_kd(0.50);
			matte_ptr1->set_cd(0.25);     // medium grey
	
			Plane* floor_ptr = new Plane(Point3D(0, -room_size,  0), Normal(0, 1, 0));
			floor_ptr->set_material(matte_ptr1);        
			add_object(floor_ptr);
	
	
			// ceiling  (+ve yw)
	
			Matte* matte_ptr2 = new Matte;   
			matte_ptr2->set_ka(0.35);   
			matte_ptr2->set_kd(0.50);
			matte_ptr2->set_cd(white);
	
			Plane* ceiling_ptr = new Plane(Point3D(0, room_size,  0), Normal(0, -1, 0));
			ceiling_ptr->set_material(matte_ptr2);        
			add_object(ceiling_ptr);
	
	
			// back wall  (-ve zw)
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.15); 
			matte_ptr3->set_kd(0.60);
			matte_ptr3->set_cd(0.5, 0.75, 0.75);     // cyan
	
			Plane* backWall_ptr = new Plane(Point3D(0, 0,  -room_size), Normal(0, 0, 1));
			backWall_ptr->set_material(matte_ptr3);        
			add_object(backWall_ptr);
	
			// front wall  (+ve zw)
	
			Plane* frontWall_ptr = new Plane(Point3D(0, 0,  room_size), Normal(0, 0, -1));
			frontWall_ptr->set_material(matte_ptr3);        
			add_object(frontWall_ptr);
	
			// left wall  (-ve xw)
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(0.15); 
			matte_ptr4->set_kd(0.60);
			matte_ptr4->set_cd(0.71, 0.40, 0.20);   // orange
	
			Plane* leftWall_ptr = new Plane(Point3D(-room_size, 0, 0), Normal(1, 0, 0));
			leftWall_ptr->set_material(matte_ptr4);        
			add_object(leftWall_ptr);
	
			// right wall  (+ve xw)
	
			Plane* rightWall_ptr = new Plane(Point3D(room_size, 0, 0), Normal(-1, 0, 0));
			rightWall_ptr->set_material(matte_ptr4);        
			add_object(rightWall_ptr);
	
	
			// mirrors on the walls
			// the right wall has no mirror
	
			double mirror_size 	= 8;  	// the mirror size
			double offset 		= 1.0;  // the mirror offset from the walls
	
			// mirror material
			// this has no direct illumination and a slight green tint
	
			Reflective* reflective_ptr2 = new Reflective;			
			reflective_ptr2->set_ka(0); 
			reflective_ptr2->set_kd(0);
			reflective_ptr2->set_cd(black); 
			reflective_ptr2->set_ks(0);
			reflective_ptr2->set_kr(0.9);
			reflective_ptr2->set_cr(0.9, 1.0, 0.9);  // light green
	
			// back wall mirror  (-ve zw)

			Point3D p0;
			Vector3D a, b;
	
			p0 = Point3D(-mirror_size, -mirror_size, -(room_size - offset));
			a = Vector3D(2.0 * mirror_size, 0, 0);
			b = Vector3D(0, 2.0 * mirror_size, 0);
			Normal n(0, 0, 1);
			TRectangle* rectangle_ptr1 = new TRectangle(p0, a, b, n);
			rectangle_ptr1->set_material(reflective_ptr2); 
			add_object(rectangle_ptr1);
	
	
			// front wall mirror  (+ve zw)
	
			p0 = Point3D(-mirror_size, -mirror_size, +(room_size - offset));
			n = Normal(0, 0, -1);
			TRectangle* rectangle_ptr2 = new TRectangle(p0, a, b, n);
			rectangle_ptr2->set_material(reflective_ptr2); 
			add_object(rectangle_ptr2);
	
	
			// left wall mirror  (-ve xw)
	
			p0 = Point3D(-(room_size - offset), -mirror_size, +mirror_size);
			a = Point3D(0, 0, -2.0 * mirror_size);
			n = Normal(1, 0, 0);
			TRectangle* rectangle_ptr3 = new TRectangle(p0, a, b, n);
			rectangle_ptr3->set_material(reflective_ptr2); 
			add_object(rectangle_ptr3);


			// horizontal mirror underneath the sphere
			// this has no direct illumination and a lemon color
	
			Reflective* reflective_ptr3 = new Reflective;			
			reflective_ptr3->set_ka(0); 
			reflective_ptr3->set_kd(0);
			reflective_ptr3->set_cd(black); 
			reflective_ptr3->set_ks(0);
			reflective_ptr3->set_kr(1);
			reflective_ptr3->set_cr(1, 1, 0.5);  // lemon
	
			double yw = -4.0;   // the yw location of the mirror
	
			p0 = Point3D(-mirror_size, yw, -mirror_size);
			a = Vector3D(0, 0, 2.0 * mirror_size);
			b = Vector3D(2.0 * mirror_size, 0, 0);
			n = Normal(0, 1, 0);
			TRectangle* rectangle_ptr4 = new TRectangle(p0, a, b, n);
			rectangle_ptr4->set_material(reflective_ptr3); 
			add_object(rectangle_ptr4);
			break;
		}
	case 215:
		{
			//24.18a
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);        
			vp.set_samples(num_samples);
			vp.set_max_depth(19);	
	
			tracer_ptr = new Whitted(this);
			
			Pinhole* pinhole_ptr = new Pinhole;
	
			pinhole_ptr->set_eye(7.5, 3, 9.5);
			pinhole_ptr->set_lookat(0);
			pinhole_ptr->set_view_distance(300);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			// four point lights near the ceiling
			// these don't use distance attenuation

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(10, 10, 0); 
			light_ptr1->scale_radiance(2.0); 
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);
    
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(0, 10, 10); 
			light_ptr2->scale_radiance(2.0); 
			light_ptr2->set_shadows(true); 
			add_light(light_ptr2);
    
			PointLight* light_ptr3 = new PointLight;
			light_ptr3->set_location(-10, 10, 0); 
			light_ptr3->scale_radiance(2.0); 
			light_ptr3->set_shadows(true); 
			add_light(light_ptr3);
    
			PointLight* light_ptr4 = new PointLight;
			light_ptr4->set_location(0, 10, -10); 
			light_ptr4->scale_radiance(2.0); 
			light_ptr4->set_shadows(true); 
			add_light(light_ptr4);

		
			// sphere
			// this is the only reflective object with a direct illumination shading component
	
			Reflective* reflective_ptr1 = new Reflective;			
			reflective_ptr1->set_ka(0.1); 
			reflective_ptr1->set_kd(0.4); 
			reflective_ptr1->set_cd(0, 0, 1);   	 // blue
			reflective_ptr1->set_ks(0.25);
			reflective_ptr1->set_exp(100.0);
			reflective_ptr1->set_kr(0.85); 
			reflective_ptr1->set_cr(0.75, 0.75, 1);  // blue 
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(0, 0.5, 0), 4); 
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
		
	
			// the walls, the ceiling, and the floor of the room are defined as planes
			// the shape is a cube
	
			double room_size = 11.0;
	
			// floor  (-ve yw)
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.1);   
			matte_ptr1->set_kd(0.50);
			matte_ptr1->set_cd(0.25);     // medium grey
	
			Plane* floor_ptr = new Plane(Point3D(0, -room_size,  0), Normal(0, 1, 0));
			floor_ptr->set_material(matte_ptr1);        
			add_object(floor_ptr);
	
	
			// ceiling  (+ve yw)
	
			Matte* matte_ptr2 = new Matte;   
			matte_ptr2->set_ka(0.35);   
			matte_ptr2->set_kd(0.50);
			matte_ptr2->set_cd(white);
	
			Plane* ceiling_ptr = new Plane(Point3D(0, room_size,  0), Normal(0, -1, 0));
			ceiling_ptr->set_material(matte_ptr2);        
			add_object(ceiling_ptr);
	
	
			// back wall  (-ve zw)
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.15); 
			matte_ptr3->set_kd(0.60);
			matte_ptr3->set_cd(0.5, 0.75, 0.75);     // cyan
	
			Plane* backWall_ptr = new Plane(Point3D(0, 0,  -room_size), Normal(0, 0, 1));
			backWall_ptr->set_material(matte_ptr3);        
			add_object(backWall_ptr);
	
			// front wall  (+ve zw)
	
			Plane* frontWall_ptr = new Plane(Point3D(0, 0,  room_size), Normal(0, 0, -1));
			frontWall_ptr->set_material(matte_ptr3);        
			add_object(frontWall_ptr);
	
			// left wall  (-ve xw)
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(0.15); 
			matte_ptr4->set_kd(0.60);
			matte_ptr4->set_cd(0.71, 0.40, 0.20);   // orange
	
			Plane* leftWall_ptr = new Plane(Point3D(-room_size, 0, 0), Normal(1, 0, 0));
			leftWall_ptr->set_material(matte_ptr4);        
			add_object(leftWall_ptr);
	
			// right wall  (+ve xw)
	
			Plane* rightWall_ptr = new Plane(Point3D(room_size, 0, 0), Normal(-1, 0, 0));
			rightWall_ptr->set_material(matte_ptr4);        
			add_object(rightWall_ptr);
	
	
			// mirrors on the walls
			// the right wall has no mirror
	
			double mirror_size 	= 8;  	// the mirror size
			double offset 		= 1.0;  // the mirror offset from the walls
	
			// mirror material
			// this has no direct illumination and a slight green tint
	
			Reflective* reflective_ptr2 = new Reflective;			
			reflective_ptr2->set_ka(0); 
			reflective_ptr2->set_kd(0);
			reflective_ptr2->set_cd(black); 
			reflective_ptr2->set_ks(0);
			reflective_ptr2->set_kr(0.9);
			reflective_ptr2->set_cr(0.9, 1.0, 0.9);  // light green
	
			// back wall mirror  (-ve zw)

			Point3D p0;
			Vector3D a, b;
	
			p0 = Point3D(-mirror_size, -mirror_size, -(room_size - offset));
			a = Vector3D(2.0 * mirror_size, 0, 0);
			b = Vector3D(0, 2.0 * mirror_size, 0);
			Normal n(0, 0, 1);
			TRectangle* rectangle_ptr1 = new TRectangle(p0, a, b, n);
			rectangle_ptr1->set_material(reflective_ptr2); 
			add_object(rectangle_ptr1);
	
	
			// front wall mirror  (+ve zw)
	
			p0 = Point3D(-mirror_size, -mirror_size, +(room_size - offset));
			n = Normal(0, 0, -1);
			TRectangle* rectangle_ptr2 = new TRectangle(p0, a, b, n);
			rectangle_ptr2->set_material(reflective_ptr2); 
			add_object(rectangle_ptr2);
	
	
			// left wall mirror  (-ve xw)
	
			p0 = Point3D(-(room_size - offset), -mirror_size, +mirror_size);
			a = Point3D(0, 0, -2.0 * mirror_size);
			n = Normal(1, 0, 0);
			TRectangle* rectangle_ptr3 = new TRectangle(p0, a, b, n);
			rectangle_ptr3->set_material(reflective_ptr2); 
			add_object(rectangle_ptr3);


			// horizontal mirror underneath the sphere
			// this has no direct illumination and a lemon color
	
			Reflective* reflective_ptr3 = new Reflective;			
			reflective_ptr3->set_ka(0); 
			reflective_ptr3->set_kd(0);
			reflective_ptr3->set_cd(black); 
			reflective_ptr3->set_ks(0);
			reflective_ptr3->set_kr(1);
			reflective_ptr3->set_cr(1, 1, 0.5);  // lemon
	
			double yw = -4.0;   // the yw location of the mirror
	
			p0 = Point3D(-mirror_size, yw, -mirror_size);
			a = Vector3D(0, 0, 2.0 * mirror_size);
			b = Vector3D(2.0 * mirror_size, 0, 0);
			n = Normal(0, 1, 0);
			TRectangle* rectangle_ptr4 = new TRectangle(p0, a, b, n);
			rectangle_ptr4->set_material(reflective_ptr3); 
			add_object(rectangle_ptr4);
			break;
		}
	case 216:
		{
			//24.18b
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);        
			vp.set_samples(num_samples);
			vp.set_max_depth(20);	
	
			tracer_ptr = new Whitted(this);
			
			Pinhole* pinhole_ptr = new Pinhole;
	

			// for regular view

			pinhole_ptr->set_eye(7.5, 3, 9.5);
			pinhole_ptr->set_lookat(0, -5, 0);   
			pinhole_ptr->set_view_distance(2000);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			// four point lights near the ceiling
			// these don't use distance attenuation

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(10, 10, 0); 
			light_ptr1->scale_radiance(2.0); 
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);
    
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(0, 10, 10); 
			light_ptr2->scale_radiance(2.0); 
			light_ptr2->set_shadows(true); 
			add_light(light_ptr2);
    
			PointLight* light_ptr3 = new PointLight;
			light_ptr3->set_location(-10, 10, 0); 
			light_ptr3->scale_radiance(2.0); 
			light_ptr3->set_shadows(true); 
			add_light(light_ptr3);
    
			PointLight* light_ptr4 = new PointLight;
			light_ptr4->set_location(0, 10, -10); 
			light_ptr4->scale_radiance(2.0); 
			light_ptr4->set_shadows(true); 
			add_light(light_ptr4);

		
			// sphere
			// this is the only reflective object with a direct illumination shading component
	
			Reflective* reflective_ptr1 = new Reflective;			
			reflective_ptr1->set_ka(0.1); 
			reflective_ptr1->set_kd(0.4); 
			reflective_ptr1->set_cd(0, 0, 1);   	 // blue
			reflective_ptr1->set_ks(0.25);
			reflective_ptr1->set_exp(100.0);
			reflective_ptr1->set_kr(0.85); 
			reflective_ptr1->set_cr(0.75, 0.75, 1);  // blue 
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(0, 0.5, 0), 4); 
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
		
	
			// the walls, the ceiling, and the floor of the room are defined as planes
			// the shape is a cube
	
			double room_size = 11.0;
	
			// floor  (-ve yw)
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.1);   
			matte_ptr1->set_kd(0.50);
			matte_ptr1->set_cd(0.25);     // medium grey
	
			Plane* floor_ptr = new Plane(Point3D(0, -room_size,  0), Normal(0, 1, 0));
			floor_ptr->set_material(matte_ptr1);        
			add_object(floor_ptr);
	
	
			// ceiling  (+ve yw)
	
			Matte* matte_ptr2 = new Matte;   
			matte_ptr2->set_ka(0.35);   
			matte_ptr2->set_kd(0.50);
			matte_ptr2->set_cd(white);
	
			Plane* ceiling_ptr = new Plane(Point3D(0, room_size,  0), Normal(0, -1, 0));
			ceiling_ptr->set_material(matte_ptr2);        
			add_object(ceiling_ptr);
	
	
			// back wall  (-ve zw)
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.15); 
			matte_ptr3->set_kd(0.60);
			matte_ptr3->set_cd(0.5, 0.75, 0.75);     // cyan
	
			Plane* backWall_ptr = new Plane(Point3D(0, 0,  -room_size), Normal(0, 0, 1));
			backWall_ptr->set_material(matte_ptr3);        
			add_object(backWall_ptr);
	
			// front wall  (+ve zw)
	
			Plane* frontWall_ptr = new Plane(Point3D(0, 0,  room_size), Normal(0, 0, -1));
			frontWall_ptr->set_material(matte_ptr3);        
			add_object(frontWall_ptr);
	
			// left wall  (-ve xw)
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(0.15); 
			matte_ptr4->set_kd(0.60);
			matte_ptr4->set_cd(0.71, 0.40, 0.20);   // orange
	
			Plane* leftWall_ptr = new Plane(Point3D(-room_size, 0, 0), Normal(1, 0, 0));
			leftWall_ptr->set_material(matte_ptr4);        
			add_object(leftWall_ptr);
	
			// right wall  (+ve xw)
	
			Plane* rightWall_ptr = new Plane(Point3D(room_size, 0, 0), Normal(-1, 0, 0));
			rightWall_ptr->set_material(matte_ptr4);        
			add_object(rightWall_ptr);
	
	
			// mirrors on the walls
			// the right wall has no mirror
	
			double mirror_size 	= 8;  	// the mirror size
			double offset 		= 1.0;  // the mirror offset from the walls
	
			// mirror material
			// this has no direct illumination and a slight green tint
	
			Reflective* reflective_ptr2 = new Reflective;			
			reflective_ptr2->set_ka(0); 
			reflective_ptr2->set_kd(0);
			reflective_ptr2->set_cd(black); 
			reflective_ptr2->set_ks(0);
			reflective_ptr2->set_kr(0.9);
			reflective_ptr2->set_cr(0.9, 1.0, 0.9);  // light green
	
			// back wall mirror  (-ve zw)

			Point3D p0;
			Vector3D a, b;
	
			p0 = Point3D(-mirror_size, -mirror_size, -(room_size - offset));
			a = Vector3D(2.0 * mirror_size, 0, 0);
			b = Vector3D(0, 2.0 * mirror_size, 0);
			Normal n(0, 0, 1);
			TRectangle* rectangle_ptr1 = new TRectangle(p0, a, b, n);
			rectangle_ptr1->set_material(reflective_ptr2); 
			add_object(rectangle_ptr1);
	
	
			// front wall mirror  (+ve zw)
	
			p0 = Point3D(-mirror_size, -mirror_size, +(room_size - offset));
			n = Normal(0, 0, -1);
			TRectangle* rectangle_ptr2 = new TRectangle(p0, a, b, n);
			rectangle_ptr2->set_material(reflective_ptr2); 
			add_object(rectangle_ptr2);
	
	
			// left wall mirror  (-ve xw)
	
			p0 = Point3D(-(room_size - offset), -mirror_size, +mirror_size);
			a = Point3D(0, 0, -2.0 * mirror_size);
			n = Normal(1, 0, 0);
			TRectangle* rectangle_ptr3 = new TRectangle(p0, a, b, n);
			rectangle_ptr3->set_material(reflective_ptr2); 
			add_object(rectangle_ptr3);


			// horizontal mirror underneath the sphere
			// this has no direct illumination and a lemon color
	
			Reflective* reflective_ptr3 = new Reflective;			
			reflective_ptr3->set_ka(0); 
			reflective_ptr3->set_kd(0);
			reflective_ptr3->set_cd(black); 
			reflective_ptr3->set_ks(0);
			reflective_ptr3->set_kr(1);
			reflective_ptr3->set_cr(1, 1, 0.5);  // lemon
	
			double yw = -4.0;   // the yw location of the mirror
	
			p0 = Point3D(-mirror_size, yw, -mirror_size);
			a = Vector3D(0, 0, 2.0 * mirror_size);
			b = Vector3D(2.0 * mirror_size, 0, 0);
			n = Normal(0, 1, 0);
			TRectangle* rectangle_ptr4 = new TRectangle(p0, a, b, n);
			rectangle_ptr4->set_material(reflective_ptr3); 
			add_object(rectangle_ptr4);
			break;
		}
	case 217:
		{
			//24.20a
			int num_samples = 16;
	
			vp.set_hres(400);  
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_max_depth(12);
		
			tracer_ptr = new Whitted(this);

			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);	
					
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-35, 25, 35);  
			pinhole_ptr->set_lookat(0.0, 0.4, -0.2);  
			pinhole_ptr->set_view_distance(5500.0);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(0, 20, 20);     
			light_ptr->scale_radiance(5.0); 
			light_ptr->set_shadows(false);
			add_light(light_ptr);	
	
	
			// the four spheres
		
			float ka = 0.75;
			float kd = 0.75;
			float ks = 0.1;
			float e = 20.0;
			float kr = 1.0;
	
			Reflective* reflective_ptr1 = new Reflective;
			reflective_ptr1->set_ka(ka); 
			reflective_ptr1->set_kd(kd); 
			reflective_ptr1->set_ks(ks);  
			reflective_ptr1->set_cd(0.168, 0.171, 0.009);    	// pink
			reflective_ptr1->set_exp(e);
			reflective_ptr1->set_kr(kr);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0, 1.414, 0.0), 0.866);
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
	
	
			Reflective* reflective_ptr2 = new Reflective;
			reflective_ptr2->set_ka(ka); 
			reflective_ptr2->set_kd(kd); 
			reflective_ptr2->set_cd(0.094, 0.243, 0.029);   	// green
			reflective_ptr2->set_ks(ks);    
			reflective_ptr2->set_exp(e);
			reflective_ptr2->set_kr(kr);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(0.0, 0.0, 1.0), 0.866);
			sphere_ptr2->set_material(reflective_ptr2);
			add_object(sphere_ptr2);
	
	
			Reflective* reflective_ptr3 = new Reflective;
			reflective_ptr3->set_ka(ka); 
			reflective_ptr3->set_kd(kd);
			reflective_ptr3->set_cd(0.243, 0.018, 0.164);     	// red 
			reflective_ptr3->set_ks(ks);    
			reflective_ptr3->set_exp(e);
			reflective_ptr3->set_kr(kr);
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(0.866, 0.0, -0.5), 0.866);
			sphere_ptr3->set_material(reflective_ptr3);
			add_object(sphere_ptr3);
	
	
			Reflective* reflective_ptr4 = new Reflective;
			reflective_ptr4->set_ka(ka); 
			reflective_ptr4->set_kd(kd); 
			reflective_ptr4->set_cd(0.094, 0.1, 0.243);    		// blue
			reflective_ptr4->set_ks(ks);    
			reflective_ptr4->set_exp(e);
			reflective_ptr4->set_kr(kr);
	
			Sphere* sphere_ptr4 = new Sphere(Point3D(-0.866, 0.0, -0.5), 0.866);
			sphere_ptr4->set_material(reflective_ptr4);
			add_object(sphere_ptr4);
			break;
		}
	case 218:
		{
			//24.20b
			int num_samples = 1;
	
			vp.set_hres(800);   
			vp.set_vres(800);
			vp.set_samples(num_samples);
			vp.set_max_depth(12);
		
			tracer_ptr = new Whitted(this);

			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);	
					
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0.0, 0.05, 0.0);
			pinhole_ptr->set_lookat(0.0, 1.0, 0.0);  
			pinhole_ptr->set_view_distance(600.0);   
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			// the four spheres
		
			float ka = 0.75;
			float kd = 0.75;
			float ks = 0.1;
			float e = 20.0;
			float kr = 1.0;
	
			Reflective* reflective_ptr1 = new Reflective;
			reflective_ptr1->set_ka(ka); 
			reflective_ptr1->set_kd(kd); 
			reflective_ptr1->set_ks(ks);  
			reflective_ptr1->set_cd(0.168, 0.171, 0.009);  		// pink 
			reflective_ptr1->set_exp(e);
			reflective_ptr1->set_kr(kr);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0, 1.414, 0.0), 0.866);
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
	
	
			Reflective* reflective_ptr2 = new Reflective;
			reflective_ptr2->set_ka(ka); 
			reflective_ptr2->set_kd(kd); 
			reflective_ptr2->set_cd(0.094, 0.243, 0.029);    	// green
			reflective_ptr2->set_ks(ks);    
			reflective_ptr2->set_exp(e);
			reflective_ptr2->set_kr(kr);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(0.0, 0.0, 1.0), 0.866);
			sphere_ptr2->set_material(reflective_ptr2);
			add_object(sphere_ptr2);
	
	
			Reflective* reflective_ptr3 = new Reflective;
			reflective_ptr3->set_ka(ka); 
			reflective_ptr3->set_kd(kd);
			reflective_ptr3->set_cd(0.243, 0.018, 0.164);     	// red 
			reflective_ptr3->set_ks(ks);    
			reflective_ptr3->set_exp(e);
			reflective_ptr3->set_kr(kr);
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(0.866, 0.0, -0.5), 0.866);
			sphere_ptr3->set_material(reflective_ptr3);
			add_object(sphere_ptr3);
	
			Reflective* reflective_ptr4 = new Reflective;
			reflective_ptr4->set_ka(ka); 
			reflective_ptr4->set_kd(kd); 
			reflective_ptr4->set_cd(0.094, 0.1, 0.243);    		// blue
			reflective_ptr4->set_ks(ks);    
			reflective_ptr4->set_exp(e);
			reflective_ptr4->set_kr(kr);
	
			Sphere* sphere_ptr4 = new Sphere(Point3D(-0.866, 0.0, -0.5), 0.866);
			sphere_ptr4->set_material(reflective_ptr4);
			add_object(sphere_ptr4);
			break;
		}
	case 219:
		{
			//24.29a
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 1;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(2);
	
			tracer_ptr = new Whitted(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, -15, 500);
			pinhole_ptr->set_lookat(-10, 10, 0);	 
			pinhole_ptr->set_view_distance(700);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
		

			Reflective* reflective_ptr = new Reflective;			
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_cd(0.0);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 0.75, 0.25);  // orange
	
	
			// thick cylinder
	
			float ymin = 0.0;
			float ymax = 100;
			float inner_radius = 75.0;
			float outer_radius = 150.0;
	
			ThickRing* ring_ptr = new ThickRing(ymin, ymax, inner_radius, outer_radius);
			ring_ptr->set_material(reflective_ptr);
	
			Instance* rotated_ring_ptr = new Instance (ring_ptr);
			rotated_ring_ptr->rotate_x(65);
			rotated_ring_ptr->rotate_y(-10);
			add_object(rotated_ring_ptr);
	
	
	
			// large sphere with Uffizi image
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());   // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");   // for production
	
			LightProbeMap* light_probe_ptr = new LightProbeMap;  
			light_probe_ptr->set_map_type(panoramic);     		
	
			ImageTexture* texture_ptr = new ImageTexture(image_ptr); 
			texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr = new Instance(unit_sphere_ptr); 
			sphere_ptr->set_material(sv_matte_ptr);
			sphere_ptr->scale(1000000.0);
			add_object(sphere_ptr);
			break;
		}
	case 220:
		{
			//24.29b
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 1;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
	
			tracer_ptr = new Whitted(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, -15, 500); 
			pinhole_ptr->set_lookat(0, -15, 0);	
			pinhole_ptr->set_view_distance(800);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
		
	
			Reflective* reflective_ptr = new Reflective;			
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_cd(0.0);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 0.75, 0.25);  // orange

	
			// box
	
			Point3D p0(-100.0);
			Point3D p1(100.0);
	
			Box* box_ptr = new Box(p0, p1);	
			box_ptr->set_material(reflective_ptr);

			Instance* rotated_box_ptr = new Instance(box_ptr);
			rotated_box_ptr->rotate_y(-20);
			rotated_box_ptr->rotate_x(39);
			add_object(rotated_box_ptr);
	
	
			// large sphere with Uffizi image
	
			Image* image_ptr = new Image;
		//	image_ptr->read_ppm_file("uffizi_probe_small.ppm");   // for testing 
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());   // for production
	
			LightProbeMap* light_probe_ptr = new LightProbeMap;  
			light_probe_ptr->set_map_type(panoramic);     		
	
			ImageTexture* texture_ptr = new ImageTexture(image_ptr); 
			texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr = new Instance(unit_sphere_ptr); 
			sphere_ptr->set_material(sv_matte_ptr);
			sphere_ptr->scale(1000000.0);
			add_object(sphere_ptr);
			break;
		}
	case 221:
		{
			//24.29c
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 1;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
	
			tracer_ptr = new Whitted(this);	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, -15, 500); 
			pinhole_ptr->set_lookat(0, -15, 0);	
			pinhole_ptr->set_view_distance(800);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
		
			Reflective* reflective_ptr = new Reflective;			
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_cd(0.0);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 0.75, 0.25);  // orange

	
			// beveled box
	
			Point3D p0(-100);
			Point3D p1(100);	
			double bevel_radius = 50;
	
			BeveledBox* beveled_box_ptr = new BeveledBox(p0, p1, bevel_radius);	
			beveled_box_ptr->set_material(reflective_ptr);

			Instance* rotated_beveled_box_ptr = new Instance(beveled_box_ptr);
			rotated_beveled_box_ptr->rotate_y(-20);
			rotated_beveled_box_ptr->rotate_x(39);
			add_object(rotated_beveled_box_ptr);
	
	
			// large sphere with Uffizi image
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());   // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");   // for production
	
			LightProbeMap* light_probe_ptr = new LightProbeMap; 
			light_probe_ptr->set_map_type(panoramic);      		
	
			ImageTexture* texture_ptr = new ImageTexture(image_ptr); 
			texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr = new Instance(unit_sphere_ptr); 
			sphere_ptr->set_material(sv_matte_ptr);
			sphere_ptr->scale(1000000.0);
			add_object(sphere_ptr);
			break;
		}
	case 222:
		{
			//24.29d
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 1;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
	
			tracer_ptr = new Whitted(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, -15, 500); 
			pinhole_ptr->set_lookat(30, 5, 0);	
			pinhole_ptr->set_view_distance(2400);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
		
	
			Reflective* reflective_ptr = new Reflective;			
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_cd(0.0);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 0.75, 0.25);  // orange

	
			// beveled box
	
			Point3D p0(-100);
			Point3D p1(100);	
			double bevel_radius = 50;
	
			BeveledBox* beveled_box_ptr = new BeveledBox(p0, p1, bevel_radius);	
			//beveled_box_ptr->set_material(reflective_ptr);    // don't use this, then use what ?

			Instance* rotated_beveled_box_ptr = new Instance(beveled_box_ptr);
			rotated_beveled_box_ptr->rotate_y(-20);
			rotated_beveled_box_ptr->rotate_x(39);
			add_object(rotated_beveled_box_ptr);
	
	
			// large sphere with Uffizi image
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());   // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");   // for production
	
			LightProbeMap* light_probe_ptr = new LightProbeMap; 
			light_probe_ptr->set_map_type(panoramic);      		
	
			ImageTexture* texture_ptr = new ImageTexture(image_ptr); 
			texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr = new Instance(unit_sphere_ptr); 
			sphere_ptr->set_material(sv_matte_ptr);
			sphere_ptr->scale(1000000.0);
			add_object(sphere_ptr);
			break;
		}
	case 223:
		{
			//24.30a
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
		
			tracer_ptr = new Whitted(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-150, 75, 500); 
			pinhole_ptr->set_lookat(-6, 50, 0);
			pinhole_ptr->set_view_distance(3000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(250, 500, 250); 
			light_ptr1->scale_radiance(3.0); 
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);
    

			// sphere
	
			Reflective* reflective_ptr = new Reflective;			
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_cd(black);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 1.0, 0.3);  // lemon
	
			int horizontal_steps = 100;
			int vertical_steps = 50;
			
			Grid* grid_ptr = new Grid;
			grid_ptr->tessellate_flat_sphere(horizontal_steps, vertical_steps); 
			grid_ptr->set_material(reflective_ptr);
			grid_ptr->setup_cells();

			Instance* sphere_ptr = new Instance(grid_ptr);
			sphere_ptr->set_material(reflective_ptr);
			sphere_ptr->scale(40);
			sphere_ptr->translate(-6, 55, 0);
			add_object(sphere_ptr);
	
	
			//cylinder
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.15);
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(0.5, 1.0, 0.5);   // green

			double bottom = -100.0;
			double top = 15.0;       
			double radius = 30.0;
			Instance* cylinder_ptr = new Instance(new SolidCylinder(bottom, top, radius));
			cylinder_ptr->translate(-6, 0, 0);
			cylinder_ptr->set_material(matte_ptr);
			add_object(cylinder_ptr);
	
	
			// large sphere with Uffizi image
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());   // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");   // for production
	
			LightProbeMap* light_probe_ptr = new LightProbeMap;   
			light_probe_ptr->set_map_type(panoramic);  		
	
			ImageTexture* texture_ptr = new ImageTexture(image_ptr); 
			texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* large_sphere_ptr = new Instance(unit_sphere_ptr); 
			large_sphere_ptr->set_material(sv_matte_ptr);
			large_sphere_ptr->scale(1000000.0);
			add_object(large_sphere_ptr);
			break;
		}
	case 224:
		{
			//24.30b
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
		
			tracer_ptr = new Whitted(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-150, 75, 500); 
			pinhole_ptr->set_lookat(-6, 50, 0);
			pinhole_ptr->set_view_distance(3000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(250, 500, 250); 
			light_ptr1->scale_radiance(3.0); 
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);
    

			// sphere
	
			Reflective* reflective_ptr = new Reflective;			
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_cd(black);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 1.0, 0.3);  // lemon
	
			int horizontal_steps = 100;
			int vertical_steps = 50;
			
			Grid* grid_ptr = new Grid;
			grid_ptr->tessellate_smooth_sphere(horizontal_steps, vertical_steps);
			grid_ptr->set_material(reflective_ptr);
			grid_ptr->setup_cells();

			Instance* sphere_ptr = new Instance(grid_ptr);
			sphere_ptr->set_material(reflective_ptr);
			sphere_ptr->scale(40);
			sphere_ptr->translate(-6, 55, 0);
			add_object(sphere_ptr);
	
	
			//cylinder
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.15);
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(0.5, 1.0, 0.5);   // green

			double bottom = -100.0;
			double top = 15.0;       
			double radius = 30.0;
			Instance* cylinder_ptr = new Instance(new SolidCylinder(bottom, top, radius));
			cylinder_ptr->translate(-6, 0, 0);
			cylinder_ptr->set_material(matte_ptr);
			add_object(cylinder_ptr);
	
	
			// large sphere with Uffizi image
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());   // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");   // for production
	
			LightProbeMap* light_probe_ptr = new LightProbeMap;   
			light_probe_ptr->set_map_type(panoramic);  		
	
			ImageTexture* texture_ptr = new ImageTexture(image_ptr); 
			texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* large_sphere_ptr = new Instance(unit_sphere_ptr); 
			large_sphere_ptr->set_material(sv_matte_ptr);
			large_sphere_ptr->scale(1000000.0);
			add_object(large_sphere_ptr);
			break;
		}
	case 225:
		{
			//24.30c
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
		
			tracer_ptr = new Whitted(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-150, 75, 500); 
			pinhole_ptr->set_lookat(-6, 50, 0);
			pinhole_ptr->set_view_distance(3000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(250, 500, 250); 
			light_ptr1->scale_radiance(3.0); 
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);
    
    
			// sphere
	
			Reflective* reflective_ptr = new Reflective;			
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_cd(black);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 1.0, 0.3);  // lemon
	
			Sphere* sphere_ptr = new Sphere(Point3D(-6, 55, 0), 40);
			sphere_ptr->set_material(reflective_ptr);
			add_object(sphere_ptr);
	
	
			//cylinder
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.15);
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(0.5, 1.0, 0.5);   // green

			double bottom = -100.0;
			double top = 15.0;       
			double radius = 30.0;
			Instance* cylinder_ptr = new Instance(new SolidCylinder(bottom, top, radius));
			cylinder_ptr->translate(-6, 0, 0);
			cylinder_ptr->set_material(matte_ptr);
			add_object(cylinder_ptr);
	
	
			// large sphere with Uffizi image
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());   // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");   // for production
	
			LightProbeMap* light_probe_ptr = new LightProbeMap;   
			light_probe_ptr->set_map_type(panoramic);  		
	
			ImageTexture* texture_ptr = new ImageTexture(image_ptr); 
			texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* large_sphere_ptr = new Instance(unit_sphere_ptr); 
			large_sphere_ptr->set_material(sv_matte_ptr);
			large_sphere_ptr->scale(1000000.0);
			add_object(large_sphere_ptr);
			break;
		}
	case 226:
		{
			//24.31a&b
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny4K.ply").toLatin1().data()))
				return;

			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;
			
			int num_samples = 16;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(3);
		
			tracer_ptr = new Whitted(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-150, 75, 500); 
			pinhole_ptr->set_lookat(-6, 50, 0);
			pinhole_ptr->set_view_distance(3000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(250, 500, 250); 
			light_ptr1->scale_radiance(3.0); 
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);
    

			// bunny
	
			Reflective* reflective_ptr = new Reflective;			
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_cd(0.0);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(0.5, 1.0, 0.5);  // light green
	
			Mesh* mesh_ptr = new Mesh;
		//	const char* file_name = "Bunny4K.ply";   		// Figure 24.31(a) & (b)
		//	const char* file_name = "Bunny69K.ply"; 		// Figure 24.31(c) & (d)
	
			Grid* grid_ptr = new Grid(mesh_ptr);
			grid_ptr->read_flat_triangles(QString(plyfile+"Stanford Bunny\\Bunny4K.ply").toLatin1().data());		// Figure 24.31(a) & (c)
		//	grid_ptr->read_smooth_triangles(file_name);		// Figure 24.31(b) & (d)
			grid_ptr->setup_cells();

			Instance* bunny_ptr1 = new Instance(grid_ptr);
			bunny_ptr1->set_material(reflective_ptr);
			bunny_ptr1->scale(500.0);
			add_object(bunny_ptr1);
	
	
			//cylinder
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.15);
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(1.0, 0.7, 0);   // orange

			double bottom = -100.0;
			double top = 15.0;       
			double radius = 30.0;
			Instance* cylinder_ptr = new Instance(new SolidCylinder(bottom, top, radius));
			cylinder_ptr->translate(-6, 0, 0);
			cylinder_ptr->set_material(matte_ptr);
			add_object(cylinder_ptr);
	
	
			// large sphere with Uffizi image
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());   // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");   // for production
	
			LightProbeMap* light_probe_ptr = new LightProbeMap;   
			light_probe_ptr->set_map_type(panoramic);  		
	
			ImageTexture* texture_ptr = new ImageTexture(image_ptr); 
			texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* large_sphere_ptr = new Instance(unit_sphere_ptr); 
			large_sphere_ptr->set_material(sv_matte_ptr);
			large_sphere_ptr->scale(1000000.0);
			add_object(large_sphere_ptr);
			break;
		}
	case 227:
		{
			//24.31c&d
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny69K.ply").toLatin1().data()))
				return;

			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;
			
			int num_samples = 16;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(3);
		
			tracer_ptr = new Whitted(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-150, 75, 500); 
			pinhole_ptr->set_lookat(-6, 50, 0);
			pinhole_ptr->set_view_distance(3000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(250, 500, 250); 
			light_ptr1->scale_radiance(3.0); 
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);
    

			// bunny
	
			Reflective* reflective_ptr = new Reflective;			
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_cd(0.0);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(0.5, 1.0, 0.5);  // light green
	
			Mesh* mesh_ptr = new Mesh;
		//	const char* file_name = "Bunny4K.ply";   		// Figure 24.31(a) & (b)
		//	const char* file_name = "Bunny69K.ply"; 		// Figure 24.31(c) & (d)
	
			Grid* grid_ptr = new Grid(mesh_ptr);
		//	grid_ptr->read_flat_triangles(QString(plyfile+"Stanford Bunny\\Bunny4K.ply").toLatin1().data());		// Figure 24.31(a) & (c)
			grid_ptr->read_smooth_triangles(QString(plyfile+"Stanford Bunny\\Bunny69K.ply").toLatin1().data());		// Figure 24.31(b) & (d)
			grid_ptr->setup_cells();

			Instance* bunny_ptr1 = new Instance(grid_ptr);
			bunny_ptr1->set_material(reflective_ptr);
			bunny_ptr1->scale(500.0);
			add_object(bunny_ptr1);
	
	
			//cylinder
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.15);
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(1.0, 0.7, 0);   // orange

			double bottom = -100.0;
			double top = 15.0;       
			double radius = 30.0;
			Instance* cylinder_ptr = new Instance(new SolidCylinder(bottom, top, radius));
			cylinder_ptr->translate(-6, 0, 0);
			cylinder_ptr->set_material(matte_ptr);
			add_object(cylinder_ptr);
	
	
			// large sphere with Uffizi image
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());   // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");   // for production
	
			LightProbeMap* light_probe_ptr = new LightProbeMap;   
			light_probe_ptr->set_map_type(panoramic);  		
	
			ImageTexture* texture_ptr = new ImageTexture(image_ptr); 
			texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* large_sphere_ptr = new Instance(unit_sphere_ptr); 
			large_sphere_ptr->set_material(sv_matte_ptr);
			large_sphere_ptr->scale(1000000.0);
			add_object(large_sphere_ptr);
			break;
		}
	case 228:
		{
			//24.32
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny69K.ply").toLatin1().data()))
				return;

			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
		
			tracer_ptr = new Whitted(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-150, 75, 500); 
			pinhole_ptr->set_lookat(-6, 50, 0);
			pinhole_ptr->set_view_distance(3000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(250, 500, 250); 
			light_ptr1->scale_radiance(3.0); 
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);
    

			// bunny
	
			Reflective* reflective_ptr = new Reflective;			
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_cd(0.0);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(0.5, 1.0, 0.5);  // light green
	
			Mesh* mesh_ptr = new Mesh;
			//const char* file_name = "Bunny69K.ply"; 
	
			Grid* grid_ptr = new Grid(mesh_ptr);
			grid_ptr->read_smooth_triangles(QString(plyfile+"Stanford Bunny\\Bunny69K.ply").toLatin1().data());
			grid_ptr->setup_cells();

			Instance* bunny_ptr1 = new Instance(grid_ptr);
			bunny_ptr1->set_material(reflective_ptr);
			bunny_ptr1->scale(500.0);
			add_object(bunny_ptr1);
	
	
			//cylinder
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.15);
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(1.0, 0.7, 0);   // orange

			double bottom = -100.0;
			double top = 15.0;       
			double radius = 30.0;
			Instance* cylinder_ptr = new Instance(new SolidCylinder(bottom, top, radius));
			cylinder_ptr->translate(-6, 0, 0);
			cylinder_ptr->set_material(matte_ptr);
			add_object(cylinder_ptr);
	
	
			// large sphere with Uffizi image
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());   // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");   // for production
	
			LightProbeMap* light_probe_ptr = new LightProbeMap;   
			light_probe_ptr->set_map_type(panoramic);  		
	
			ImageTexture* texture_ptr = new ImageTexture(image_ptr); 
			texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* large_sphere_ptr = new Instance(unit_sphere_ptr); 
			large_sphere_ptr->set_material(sv_matte_ptr);
			large_sphere_ptr->scale(1000000.0);
			add_object(large_sphere_ptr);
			break;
		}
	case 229:
		{
			//24.33a
			int num_samples = 1;
	
			vp.set_hres(600); 
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(10);
	
			tracer_ptr = new Whitted(this);	
			background_color = RGBColor(0.15); 
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(75, 40, 100); 
			pinhole_ptr->set_lookat(-10, 39, 0);  
			pinhole_ptr->set_view_distance(360);

	
			// looking at center of sphere on top of large box
	
			pinhole_ptr->set_eye(75, 39, 100); 
			pinhole_ptr->set_lookat(-30, 59, 35);  
			pinhole_ptr->set_view_distance(1500);

	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(150, 150, 0);  
			light_ptr->scale_radiance(3.0);
			light_ptr->set_shadows(true);
			add_light(light_ptr);

	
			// yellow-green reflective sphere
	
			Reflective* reflective_ptr1 = new Reflective;			
			reflective_ptr1->set_ka(0.25); 
			reflective_ptr1->set_kd(0.5);
			reflective_ptr1->set_cd(0.75, 0.75, 0);    	// yellow
			reflective_ptr1->set_ks(0.15);
			reflective_ptr1->set_exp(100.0);
			reflective_ptr1->set_kr(0.75);
			reflective_ptr1->set_cr(white); 			// default color
	
			float radius = 23.0;
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, radius, -25), radius); 
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
	
	
			// orange non-reflective sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.45); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.75, 0.25, 0);   // orange
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-7, 10, 42), 20);
			sphere_ptr2->set_material(matte_ptr1);      
			add_object(sphere_ptr2);
	
	
			// sphere on top of box

			Reflective* reflective_ptr2 = new Reflective;			
			reflective_ptr2->set_ka(0.35); 
			reflective_ptr2->set_kd(0.75);		// for Figure 24.33(a)
		//	reflective_ptr2->set_kd(1.0);		// for Figure 24.33(b)
			reflective_ptr2->set_cd(black); 
			reflective_ptr2->set_ks(0.0);		// default value
			reflective_ptr2->set_exp(1.0);		// default value, but irrelevant in this case
			reflective_ptr2->set_kr(0.75);
			reflective_ptr2->set_cr(white); 

			Sphere* sphere_ptr3 = new Sphere(Point3D(-30, 59, 35), 20);
			sphere_ptr3->set_material(reflective_ptr2);     
			add_object(sphere_ptr3);

	
			// cylinder
	
			Reflective* reflective_ptr3 = new Reflective;			
			reflective_ptr3->set_ka(0.35); 
			reflective_ptr3->set_kd(0.5);
			reflective_ptr3->set_cd(0, 0.5, 0.75);   // cyan
			reflective_ptr3->set_ks(0.2);
			reflective_ptr3->set_exp(100.0);
			reflective_ptr3->set_kr(0.75);
			reflective_ptr3->set_cr(white);
	
			double bottom 			= 0.0;
			double top 				= 85;   
			double cylinder_radius	= 22;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, cylinder_radius);
			cylinder_ptr->set_material(reflective_ptr3);
			add_object(cylinder_ptr);
	
	
			// box
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.15); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.75, 1.0, 0.75);   // light green
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(matte_ptr2);
			add_object(box_ptr);

	
			// ground plane
	
			PlaneChecker* checker_ptr = new PlaneChecker;
			checker_ptr->set_size(20.0);		
			checker_ptr->set_outline_width(2.0);
			checker_ptr->set_color1(white);
			checker_ptr->set_color2(white);
			checker_ptr->set_outline_color(black); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.30);
			sv_matte_ptr->set_kd(0.9);
			sv_matte_ptr->set_cd(checker_ptr); 
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 230:
		{
			//24.33b
			int num_samples = 1;
	
			vp.set_hres(600); 
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(10);
	
			tracer_ptr = new Whitted(this);	
			background_color = RGBColor(0.15); 
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(75, 40, 100); 
			pinhole_ptr->set_lookat(-10, 39, 0);  
			pinhole_ptr->set_view_distance(360);

	
			// looking at center of sphere on top of large box
	
			pinhole_ptr->set_eye(75, 39, 100); 
			pinhole_ptr->set_lookat(-30, 59, 35);  
			pinhole_ptr->set_view_distance(1500);

	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(150, 150, 0);  
			light_ptr->scale_radiance(3.0);
			light_ptr->set_shadows(true);
			add_light(light_ptr);

	
			// yellow-green reflective sphere
	
			Reflective* reflective_ptr1 = new Reflective;			
			reflective_ptr1->set_ka(0.25); 
			reflective_ptr1->set_kd(0.5);
			reflective_ptr1->set_cd(0.75, 0.75, 0);    	// yellow
			reflective_ptr1->set_ks(0.15);
			reflective_ptr1->set_exp(100.0);
			reflective_ptr1->set_kr(0.75);
			reflective_ptr1->set_cr(white); 			// default color
	
			float radius = 23.0;
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, radius, -25), radius); 
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
	
	
			// orange non-reflective sphere
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.45); 
			matte_ptr1->set_kd(0.75);
			matte_ptr1->set_cd(0.75, 0.25, 0);   // orange
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-7, 10, 42), 20);
			sphere_ptr2->set_material(matte_ptr1);      
			add_object(sphere_ptr2);
	
	
			// sphere on top of box

			Reflective* reflective_ptr2 = new Reflective;			
			reflective_ptr2->set_ka(0.35); 
		//	reflective_ptr2->set_kd(0.75);		// for Figure 24.33(a)
			reflective_ptr2->set_kd(1.0);		// for Figure 24.33(b)
			reflective_ptr2->set_cd(black); 
			reflective_ptr2->set_ks(0.0);		// default value
			reflective_ptr2->set_exp(1.0);		// default value, but irrelevant in this case
			reflective_ptr2->set_kr(0.75);
			reflective_ptr2->set_cr(white); 

			Sphere* sphere_ptr3 = new Sphere(Point3D(-30, 59, 35), 20);
			sphere_ptr3->set_material(reflective_ptr2);     
			add_object(sphere_ptr3);

	
			// cylinder
	
			Reflective* reflective_ptr3 = new Reflective;			
			reflective_ptr3->set_ka(0.35); 
			reflective_ptr3->set_kd(0.5);
			reflective_ptr3->set_cd(0, 0.5, 0.75);   // cyan
			reflective_ptr3->set_ks(0.2);
			reflective_ptr3->set_exp(100.0);
			reflective_ptr3->set_kr(0.75);
			reflective_ptr3->set_cr(white);
	
			double bottom 			= 0.0;
			double top 				= 85;   
			double cylinder_radius	= 22;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, cylinder_radius);
			cylinder_ptr->set_material(reflective_ptr3);
			add_object(cylinder_ptr);
	
	
			// box
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.15); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.75, 1.0, 0.75);   // light green
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(matte_ptr2);
			add_object(box_ptr);

	
			// ground plane
	
			PlaneChecker* checker_ptr = new PlaneChecker;
			checker_ptr->set_size(20.0);		
			checker_ptr->set_outline_width(2.0);
			checker_ptr->set_color1(white);
			checker_ptr->set_color2(white);
			checker_ptr->set_outline_color(black); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.30);
			sv_matte_ptr->set_kd(0.9);
			sv_matte_ptr->set_cd(checker_ptr); 
	
			Plane* plane_ptr = new Plane(Point3D(0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 231:
		{
			//24.34
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);			
			vp.set_vres(600);  
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);
			vp.set_max_depth(1);
	
			tracer_ptr = new Whitted(this);		
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(400, 125, 500);   
			pinhole_ptr->set_lookat(0.0, -50, 0);
			pinhole_ptr->set_view_distance(550);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Compound* spheres = new Compound;
		
			float  kr = 0.9;
			double radius = 100.0;
	
			// reflective sphere centered at the origin

			Reflective* reflective_ptrc = new Reflective;			
			reflective_ptrc->set_ka(0.0); 
			reflective_ptrc->set_kd(0.0);
			reflective_ptrc->set_ks(0.0);
			reflective_ptrc->set_cd(0.0);
			reflective_ptrc->set_kr(kr);
			reflective_ptrc->set_cr(0.65, 0.75, 1.0);   // pale blue
		
			Sphere* sphere_ptr = new Sphere(Point3D(0.0), radius);
			sphere_ptr->set_shadows(false);
			sphere_ptr->set_material(reflective_ptrc);
			spheres->add_object(sphere_ptr);
	
			// define materials for the surrounding spheres
	
			vector<Reflective*> materials;	
	
			Reflective* reflective_ptr0 = new Reflective;			
			reflective_ptr0->set_ka(0.0); 
			reflective_ptr0->set_kd(0.0);
			reflective_ptr0->set_ks(0.0);
			reflective_ptr0->set_cd(0.0);
			reflective_ptr0->set_kr(kr);
			reflective_ptr0->set_cr(0.5, 1.0, 0.5);  // light green
			materials.push_back(reflective_ptr0);

			Reflective* reflective_ptr1 = new Reflective;			
			reflective_ptr1->set_ka(0.0); 
			reflective_ptr1->set_kd(0.0);
			reflective_ptr1->set_ks(0.0);
			reflective_ptr1->set_cd(0.0);
			reflective_ptr1->set_kr(kr);
			reflective_ptr1->set_cr(0.4, 1.0, 1.0);  // cyan
			materials.push_back(reflective_ptr1);
	
			Reflective* reflective_ptr2 = new Reflective;			
			reflective_ptr2->set_ka(0.0); 
			reflective_ptr2->set_kd(0.0);
			reflective_ptr2->set_ks(0.0);
			reflective_ptr2->set_cd(0.0);
			reflective_ptr2->set_kr(kr);
			reflective_ptr2->set_cr(1.0, 1.0, 0.4);  // lemon
			materials.push_back(reflective_ptr2);
	
			Reflective* reflective_ptr3 = new Reflective;			
			reflective_ptr3->set_ka(0.0); 
			reflective_ptr3->set_kd(0.0);
			reflective_ptr3->set_ks(0.0);
			reflective_ptr3->set_cd(0.0);
			reflective_ptr3->set_kr(kr);
			reflective_ptr3->set_cr(1.0, 0.5, 1.0);  // mauve
			materials.push_back(reflective_ptr3);
	
			Reflective* reflective_ptr4 = new Reflective;			
			reflective_ptr4->set_ka(0.0); 
			reflective_ptr4->set_kd(0.0);
			reflective_ptr4->set_ks(0.0);
			reflective_ptr4->set_cd(0.0);
			reflective_ptr4->set_kr(kr);
			reflective_ptr4->set_cr(1.0, 0.75, 0.25);  // orange
			materials.push_back(reflective_ptr4);
	
			Reflective* reflective_ptr5 = new Reflective;			
			reflective_ptr5->set_ka(0.0); 
			reflective_ptr5->set_kd(0.0);
			reflective_ptr5->set_ks(0.0);
			reflective_ptr5->set_cd(0.0);
			reflective_ptr5->set_kr(kr);
			reflective_ptr5->set_cr(0.5, 0.5, 1.0);  // blue
			materials.push_back(reflective_ptr5);
	

			// define ring of reflective spheres that just touch the center sphere
			// these are initially in the (x, z) plane
	
			float  num_spheres = 6;
			double theta = 0.0;
			double delta_theta = 2.0 * PI / num_spheres;
	
			for (int j = 0; j < num_spheres; j++) {
				Point3D center((2.0 * radius) * sin(theta), 0.0, (2.0 * radius) * cos(theta));
				Sphere* sphere_ptr = new Sphere(center, radius);
				sphere_ptr->set_material(materials[j]);
				spheres->add_object(sphere_ptr);
				theta += delta_theta;
			}
		
			// now rotate the spheres

			Instance* rotated_spheres_ptr = new Instance(spheres);
			rotated_spheres_ptr->rotate_x(40.0);
			rotated_spheres_ptr->rotate_z(-40.0);
			add_object(rotated_spheres_ptr);

	
			// large sphere with Uffizi image
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());   // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");   // for production
	
			LightProbeMap* light_probe_ptr = new LightProbeMap; 
			light_probe_ptr->set_map_type(panoramic);    		
	
			ImageTexture* texture_ptr = new ImageTexture(image_ptr); 
			texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr1 = new Instance(unit_sphere_ptr); 
			sphere_ptr1->set_material(sv_matte_ptr);
			sphere_ptr1->scale(1000000.0);
			add_object(sphere_ptr1);
			break;
		}
	case 232:
		{
			//24.36a
			int num_samples = 9;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_pixel_size(0.00425);
			vp.set_max_depth(1);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
	
			Orthographic* orthographic_ptr = new Orthographic;
			orthographic_ptr->set_eye(1.5, 1000.0, 0.0);     
			orthographic_ptr->set_lookat(1.5, 0.0, 0.0);
			orthographic_ptr->compute_uvw();
			set_camera(orthographic_ptr);
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0.0, 1.0, 0.0);
			light_ptr->scale_radiance(2.5);
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
		
			// cone
	
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.0);	
			reflective_ptr->set_kd(0.0);
			reflective_ptr->set_cd(0, 0, 0);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_exp(1.0);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 0.8, 0.0);	// orange	
	
			Instance* cone_ptr = new Instance(new SolidCone);
			cone_ptr->set_material(reflective_ptr);
			cone_ptr->scale(1.0, 0.9, 1.0);			// for Figure 24.36(a)
		//	cone_ptr->scale(1.0, 1.0, 1.0);			// for Figure 24.36(b)
		//	cone_ptr->scale(1.0, 1.1, 1.0);			// for Figure 24.36(c)
		//	cone_ptr->scale(1.0, 3.0, 1.0);			// for Figure 24.36(d)
			cone_ptr->translate(1.5, -1, 0);
			add_object(cone_ptr);
	
			// ground plane with checker
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(0.45);		
			checker_ptr->set_color1(white);   
			checker_ptr->set_color2(0.5);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(checker_ptr);

			Plane* plane_ptr1 = new Plane(Point3D(0, -1.01, 0), Normal(0, 1, 0));  // for jug
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 233:
		{
			//24.36b
			int num_samples = 9;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_pixel_size(0.00425);
			vp.set_max_depth(1);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
	
			Orthographic* orthographic_ptr = new Orthographic;
			orthographic_ptr->set_eye(1.5, 1000.0, 0.0);     
			orthographic_ptr->set_lookat(1.5, 0.0, 0.0);
			orthographic_ptr->compute_uvw();
			set_camera(orthographic_ptr);
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0.0, 1.0, 0.0);
			light_ptr->scale_radiance(2.5);
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
		
			// cone
	
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.0);	
			reflective_ptr->set_kd(0.0);
			reflective_ptr->set_cd(0, 0, 0);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_exp(1.0);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 0.8, 0.0);	// orange	
	
			Instance* cone_ptr = new Instance(new SolidCone);
			cone_ptr->set_material(reflective_ptr);
		//	cone_ptr->scale(1.0, 0.9, 1.0);			// for Figure 24.36(a)
			cone_ptr->scale(1.0, 1.0, 1.0);			// for Figure 24.36(b)
		//	cone_ptr->scale(1.0, 1.1, 1.0);			// for Figure 24.36(c)
		//	cone_ptr->scale(1.0, 3.0, 1.0);			// for Figure 24.36(d)
			cone_ptr->translate(1.5, -1, 0);
			add_object(cone_ptr);
	
			// ground plane with checker
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(0.45);		
			checker_ptr->set_color1(white);   
			checker_ptr->set_color2(0.5);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(checker_ptr);

			Plane* plane_ptr1 = new Plane(Point3D(0, -1.01, 0), Normal(0, 1, 0));  // for jug
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 234:
		{
			//24.36c
			int num_samples = 9;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_pixel_size(0.00425);
			vp.set_max_depth(1);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
	
			Orthographic* orthographic_ptr = new Orthographic;
			orthographic_ptr->set_eye(1.5, 1000.0, 0.0);     
			orthographic_ptr->set_lookat(1.5, 0.0, 0.0);
			orthographic_ptr->compute_uvw();
			set_camera(orthographic_ptr);
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0.0, 1.0, 0.0);
			light_ptr->scale_radiance(2.5);
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
		
			// cone
	
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.0);	
			reflective_ptr->set_kd(0.0);
			reflective_ptr->set_cd(0, 0, 0);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_exp(1.0);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 0.8, 0.0);	// orange	
	
			Instance* cone_ptr = new Instance(new SolidCone);
			cone_ptr->set_material(reflective_ptr);
		//	cone_ptr->scale(1.0, 0.9, 1.0);			// for Figure 24.36(a)
		//	cone_ptr->scale(1.0, 1.0, 1.0);			// for Figure 24.36(b)
			cone_ptr->scale(1.0, 1.1, 1.0);			// for Figure 24.36(c)
		//	cone_ptr->scale(1.0, 3.0, 1.0);			// for Figure 24.36(d)
			cone_ptr->translate(1.5, -1, 0);
			add_object(cone_ptr);
	
			// ground plane with checker
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(0.45);		
			checker_ptr->set_color1(white);   
			checker_ptr->set_color2(0.5);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(checker_ptr);

			Plane* plane_ptr1 = new Plane(Point3D(0, -1.01, 0), Normal(0, 1, 0));  // for jug
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 235:
		{
			//24.36d
			int num_samples = 9;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_pixel_size(0.00425);
			vp.set_max_depth(1);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
	
			Orthographic* orthographic_ptr = new Orthographic;
			orthographic_ptr->set_eye(1.5, 1000.0, 0.0);     
			orthographic_ptr->set_lookat(1.5, 0.0, 0.0);
			orthographic_ptr->compute_uvw();
			set_camera(orthographic_ptr);
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0.0, 1.0, 0.0);
			light_ptr->scale_radiance(2.5);
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
		
			// cone
	
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.0);	
			reflective_ptr->set_kd(0.0);
			reflective_ptr->set_cd(0, 0, 0);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_exp(1.0);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 0.8, 0.0);	// orange	
	
			Instance* cone_ptr = new Instance(new SolidCone);
			cone_ptr->set_material(reflective_ptr);
		//	cone_ptr->scale(1.0, 0.9, 1.0);			// for Figure 24.36(a)
		//	cone_ptr->scale(1.0, 1.0, 1.0);			// for Figure 24.36(b)
		//	cone_ptr->scale(1.0, 1.1, 1.0);			// for Figure 24.36(c)
			cone_ptr->scale(1.0, 3.0, 1.0);			// for Figure 24.36(d)
			cone_ptr->translate(1.5, -1, 0);
			add_object(cone_ptr);
	
			// ground plane with checker
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(0.45);		
			checker_ptr->set_color1(white);   
			checker_ptr->set_color2(0.5);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(checker_ptr);

			Plane* plane_ptr1 = new Plane(Point3D(0, -1.01, 0), Normal(0, 1, 0));  // for jug
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 236:
		{
			//24.39
			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_max_depth(10);
	
			tracer_ptr = new Whitted(this);	

			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.0);
			set_ambient_light(ambient_ptr);	
		
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 0); 
			pinhole_ptr->set_lookat(0, 0, -100);
			pinhole_ptr->set_view_distance(500);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(1.0, 1.0, 0.5); 	// yellow 
			emissive_ptr->scale_radiance(0.85);  


			ConcaveSphere* sphere_ptr = new ConcaveSphere;
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_shadows(false);
			add_object(sphere_ptr);

	
			// cylinder
	
			Reflective* reflective_ptr = new Reflective;			
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0); 
			reflective_ptr->set_cd(black);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_exp(1.0);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 0.75, 0.5);  // orange
	
	
			double bottom 	= -2.0;
			double top 		= 2.0; 
			double radius	= 10.0;
	
			OpenCylinder* cylinder_ptr2 = new OpenCylinder(bottom, top, radius);
			cylinder_ptr2->set_material(reflective_ptr);
			add_object(cylinder_ptr2);
			break;
		}
	case 237:
		{
			//24.40a
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_max_depth(10);  
			vp.set_pixel_size(0.0073);
			vp.set_samples(num_samples);
	
			background_color = white;
	
			tracer_ptr = new Whitted(this);

	
			Orthographic* orthographic_ptr = new Orthographic;
			orthographic_ptr->set_eye(0.0, 0.866, 100.0);    
			orthographic_ptr->set_lookat(0.0, 0.866, 0.0);  
			orthographic_ptr->compute_uvw();     
			set_camera(orthographic_ptr);

	
			float kr = 1.0;
	
			// top sphere 
	
			Reflective* reflective_ptr1 = new Reflective;
			reflective_ptr1->set_ka(0.0); 
			reflective_ptr1->set_kd(0.0); 
			reflective_ptr1->set_cd(black);
			reflective_ptr1->set_ks(0.0);
			reflective_ptr1->set_exp(1.0);			
			reflective_ptr1->set_kr(kr);
			reflective_ptr1->set_cr(0, 1, 1);  // cyan
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0, 1.732, 0.0), 1.0);
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
	
			// left bottom sphere 
	
			Reflective* reflective_ptr2 = new Reflective;
			reflective_ptr2->set_ka(0.0); 
			reflective_ptr2->set_kd(0.0); 
			reflective_ptr2->set_cd(black);
			reflective_ptr2->set_ks(0.0);
			reflective_ptr2->set_exp(1.0);			
			reflective_ptr2->set_kr(kr);
			reflective_ptr2->set_cr(1, 1, 0);  // yellow
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-1.0, 0.0, 0.0), 1.0);
			sphere_ptr2->set_material(reflective_ptr2);
			add_object(sphere_ptr2);
	
			// right bottom sphere 
	
			Reflective* reflective_ptr3 = new Reflective;
			reflective_ptr3->set_ka(0.0); 
			reflective_ptr3->set_kd(0.0); 
			reflective_ptr3->set_cd(black);
			reflective_ptr3->set_ks(0.0);
			reflective_ptr3->set_exp(1.0);			
			reflective_ptr3->set_kr(kr);
			reflective_ptr3->set_cr(1, 0, 1);  // majenta
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(1.0, 0.0, 0.0), 1.0);
			sphere_ptr3->set_material(reflective_ptr3);
			add_object(sphere_ptr3);
			break;
		}
	case 238:
		{
			//24.40b
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_max_depth(1); 
			vp.set_pixel_size(0.0073);
			vp.set_samples(num_samples);
	
			background_color = white;
	
			tracer_ptr = new Whitted(this);
	
			Orthographic* orthographic_ptr = new Orthographic;
			orthographic_ptr->set_eye(0.0, 0.866, 100.0);    
			orthographic_ptr->set_lookat(0.0, 0.866, 0.0);  
			orthographic_ptr->compute_uvw();     
			set_camera(orthographic_ptr);

	
			float kr = 1.0;
	
			// top sphere 
	
			Reflective* reflective_ptr1 = new Reflective;
			reflective_ptr1->set_ka(0.0); 
			reflective_ptr1->set_kd(0.0); 
			reflective_ptr1->set_cd(black);
			reflective_ptr1->set_ks(0.0);
			reflective_ptr1->set_exp(1.0);			
			reflective_ptr1->set_kr(kr);
			reflective_ptr1->set_cr(1, 0, 0);  // red
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0, 1.732, 0.0), 1.0);
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
	
			// left bottom sphere 
	
			Reflective* reflective_ptr2 = new Reflective;
			reflective_ptr2->set_ka(0.0); 
			reflective_ptr2->set_kd(0.0); 
			reflective_ptr2->set_cd(black);
			reflective_ptr2->set_ks(0.0);
			reflective_ptr2->set_exp(1.0);				
			reflective_ptr2->set_kr(kr);
			reflective_ptr2->set_cr(0, 1, 0);  // green
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(-1.0, 0.0, 0.0), 1.0);
			sphere_ptr2->set_material(reflective_ptr2);
			add_object(sphere_ptr2);
	
			// right bottom sphere 
	
			Reflective* reflective_ptr3 = new Reflective;
			reflective_ptr3->set_ka(0.0); 
			reflective_ptr3->set_kd(0.0); 
			reflective_ptr3->set_cd(black);
			reflective_ptr3->set_ks(0.0);
			reflective_ptr3->set_exp(1.0);			
			reflective_ptr3->set_kr(kr);
			reflective_ptr3->set_cr(0, 0, 1);  // blue
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(1.0, 0.0, 0.0), 1.0);
			sphere_ptr3->set_material(reflective_ptr3);
			add_object(sphere_ptr3);
			break;
		}
	case 239:
		{
			//24.41a
			int num_samples = 25;
	
			vp.set_hres(600);      
			vp.set_vres(600);
			vp.set_pixel_size(0.004);     
			vp.set_max_depth(1);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.0, 0.25, 0.0);   // dark green
	
			tracer_ptr = new Whitted(this);	
	
			Orthographic* ortho_ptr = new Orthographic;
			ortho_ptr->set_eye(0, 10, 0);  
			ortho_ptr->set_lookat(0.0);
			ortho_ptr->compute_uvw();     
			set_camera(ortho_ptr);
	 
		
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 1, 0);
			light_ptr->scale_radiance(2.5);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// sphere
		
			Reflective* reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0); 
			reflective_ptr->set_cd(black);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_exp(1.0);			
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 1.0, 0);  // yellow
	
			Sphere* sphere_ptr = new Sphere(Point3D(0.0, 5.0, 0.0), 1);
			sphere_ptr->set_material(reflective_ptr);
			add_object(sphere_ptr);
	
	
			// plane with checker
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(2);
			checker_ptr->set_color1(0.0);
			checker_ptr->set_color2(1.0);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.33);
			sv_matte_ptr->set_kd(0.75);
			sv_matte_ptr->set_cd(checker_ptr);

			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			plane_ptr->set_shadows(false);
			add_object(plane_ptr);	
			break;
		}
	case 240:
		{
			//24.41b
			int num_samples = 25;
	
			vp.set_hres(600);      
			vp.set_vres(600);
			vp.set_pixel_size(0.004);     
			vp.set_max_depth(1);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.0, 0.25, 0.0);   // dark green
	
			tracer_ptr = new Whitted(this);	
	
			Orthographic* ortho_ptr = new Orthographic;
			ortho_ptr->set_eye(0, 10, 0);  
			ortho_ptr->set_lookat(0.0);
			ortho_ptr->compute_uvw();     
			set_camera(ortho_ptr);
	 
		
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 1, 0);
			light_ptr->scale_radiance(2.5);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// sphere
		
			Reflective* reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0); 
			reflective_ptr->set_cd(black);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_exp(1.0);			
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 1.0, 0);  // yellow
	
			Sphere* sphere_ptr = new Sphere(Point3D(0.0, -0.5, 0.0), 1);
			sphere_ptr->set_material(reflective_ptr);
			add_object(sphere_ptr);
	
	
			// plane with checker
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(2);
			checker_ptr->set_color1(0.0);
			checker_ptr->set_color2(1.0);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.33);
			sv_matte_ptr->set_kd(0.75);
			sv_matte_ptr->set_cd(checker_ptr);

			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			plane_ptr->set_shadows(false);
			add_object(plane_ptr);	
			break;
		}
	case 241:
		{
			//24.43
			int num_samples = 100;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_max_depth(10);
		
			tracer_ptr = new AreaLighting(this);	
		
			AmbientOccluder* ambient_occluder_ptr = new AmbientOccluder;
			ambient_occluder_ptr->set_sampler(new MultiJittered(num_samples));
			ambient_occluder_ptr->set_min_amount(0.5);
			set_ambient_light(ambient_occluder_ptr);

			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 45, 100);  
			pinhole_ptr->set_lookat(-10, 40, 0);  
			pinhole_ptr->set_view_distance(400);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);

	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(0.90);
			emissive_ptr->set_ce(1.0, 1.0, 0.5); 	// lemon yellow

		
			ConcaveSphere* sphere_ptr = new ConcaveSphere;
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_shadows(false);
			add_object(sphere_ptr);
	
			EnvironmentLight* environment_light_ptr = new EnvironmentLight;
			environment_light_ptr->set_material(emissive_ptr);
			environment_light_ptr->set_sampler(new MultiJittered(num_samples));
			environment_light_ptr->set_shadows(true);
			add_light(environment_light_ptr);
	
	
			// common reflective material for large sphere, medium sphere, and cylinder
	
			Reflective* reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0); 
			reflective_ptr->set_cd(black);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_exp(1.0);			
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 0.75, 0.5);   // orange
	
			float ka = 0.2;  // commom ambient reflection coefficient for other objects
	
				// large sphere
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, 20, -24), 20);
			sphere_ptr1->set_material(reflective_ptr);
			add_object(sphere_ptr1);
	
	
			// small sphere
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(ka); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.85);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(34, 12, 13), 12);
			sphere_ptr2->set_material(matte_ptr2);
			add_object(sphere_ptr2);
	
	
			// medium sphere
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(-7, 15, 42), 16);
			sphere_ptr3->set_material(reflective_ptr);
			add_object(sphere_ptr3);
	
	
			// cylinder
	
			double bottom 	= 0.0;
			double top 		= 85; 
			double radius	= 22;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(reflective_ptr);
			add_object(cylinder_ptr);

	
			// box
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(ka); 
			matte_ptr5->set_kd(0.5);
			matte_ptr5->set_cd(0.95);
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(matte_ptr5);
			add_object(box_ptr);
	
				
			// ground plane
		
			Matte* matte_ptr6 = new Matte;			
			matte_ptr6->set_ka(0.15); 
			matte_ptr6->set_kd(0.5);	
			matte_ptr6->set_cd(0.7);    
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr6);
			add_object(plane_ptr);
			break;
		}
	case 242:
		{
			//25p1
			int num_samples = 256;   // use 1 for testing!
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_max_depth(10);
		
			tracer_ptr = new AreaLighting(this);	
		
			AmbientOccluder* ambient_occluder_ptr = new AmbientOccluder;
			ambient_occluder_ptr->set_sampler(new MultiJittered(num_samples));
			ambient_occluder_ptr->set_min_amount(0.5);
			set_ambient_light(ambient_occluder_ptr);

			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 45, 100);  
			pinhole_ptr->set_lookat(-10, 35, 0);  
			pinhole_ptr->set_view_distance(400);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(150, 250, -150);   
			light_ptr2->scale_radiance(1.5);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);


			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(1.0, 1.0, 0.5); 	 // lemon
			emissive_ptr->scale_radiance(0.85); 
	
	
			EnvironmentLight* environment_light_ptr = new EnvironmentLight;
			environment_light_ptr->set_material(emissive_ptr);
			environment_light_ptr->set_sampler(new MultiJittered(num_samples));
			environment_light_ptr->set_shadows(true);
			add_light(environment_light_ptr);
	
	
			// large concave sphere for direct rendering of environment light
	
			ConcaveSphere* sphere_ptr = new ConcaveSphere;
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_shadows(false);
			add_object(sphere_ptr);
	
	
			// other objects
		
			// large sphere
	
			GlossyReflector* glossy_ptr1 = new GlossyReflector;
			glossy_ptr1->set_samples(num_samples, 100.0);			
			glossy_ptr1->set_ka(0.0); 
			glossy_ptr1->set_kd(0.0);
			glossy_ptr1->set_ks(0.3);
			glossy_ptr1->set_exp(100.0);
			glossy_ptr1->set_cd(1.0, 1.0, 0.3);	 // orange
			glossy_ptr1->set_kr(0.9);
			glossy_ptr1->set_exponent(100.0);
			glossy_ptr1->set_cr(1.0, 0.75, 0.5);  // orange
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, 20, -24), 20);
			sphere_ptr1->set_material(glossy_ptr1);
			add_object(sphere_ptr1);
	
	
			// small sphere
		
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.4); 
			matte_ptr2->set_kd(0.4);
			matte_ptr2->set_cd(0.75, 0, 0);     // red
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(34, 12, 13), 12);
			sphere_ptr2->set_material(matte_ptr2);
			add_object(sphere_ptr2);
	
	
			// medium sphere
	
			Reflective* reflective_ptr = new Reflective;			
			reflective_ptr->set_cd(0.75);
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0); 
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_exp(20);
			reflective_ptr->set_kr(0.9);
			reflective_ptr->set_cr(1.0, 0.75, 0.5);   // orange
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(-7, 15, 42), 16);
			sphere_ptr3->set_material(reflective_ptr);
			add_object(sphere_ptr3);
	
	
			// cylinder

			GlossyReflector* glossy_ptr2 = new GlossyReflector;
			glossy_ptr2->set_samples(num_samples, 10.0);			
			glossy_ptr2->set_ka(0.0); 
			glossy_ptr2->set_kd(0.0);
			glossy_ptr2->set_ks(0.75);
			glossy_ptr2->set_cs(0.35, 0.75, 0.55);  // green
			glossy_ptr2->set_exp(10.0);
			glossy_ptr2->set_cd(1.0, 1.0, 0.3);
			glossy_ptr2->set_kr(0.9);
			glossy_ptr2->set_exponent(10.0);
			glossy_ptr2->set_cr(0.35, 0.75, 0.55);   // green
	
			double bottom 	= 0.0;
			double top 		= 85.0;
			double radius	= 22.0;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(glossy_ptr2);
			add_object(cylinder_ptr);

	
			// box

			GlossyReflector* glossy_ptr3 = new GlossyReflector;
			glossy_ptr3->set_samples(num_samples, 1000.0);			
			glossy_ptr3->set_ka(0.2); 
			glossy_ptr3->set_kd(0.3);
			glossy_ptr3->set_ks(0.0);
			glossy_ptr3->set_exp(1000.0);
			glossy_ptr3->set_cd(0.4, 0.5, 1.0);   // blue
			glossy_ptr3->set_kr(0.9);
			glossy_ptr3->set_exponent(1000.0);
			glossy_ptr3->set_cr(0.4, 0.5, 1.0);   // blue
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(glossy_ptr3);
			add_object(box_ptr);
	
	
			// ground plane with checker
	
			// checker with stripes
	
			PlaneChecker* checker_ptr = new PlaneChecker;
			checker_ptr->set_size(20.0);		
			checker_ptr->set_outline_width(2.0);
			checker_ptr->set_color1(1.0, 0.75, 0.5);
			checker_ptr->set_color2(white);
			checker_ptr->set_outline_color(black); 
	
			// Using the following glossy reflector material with the exponent = 1.0, 
			// allows us to render color bleeding from the objects onto the plane.
			// You will have to write this material and the PlaneChecker material
			// as exercises.
	
			SV_GlossyReflector* sv_glossy_ptr = new SV_GlossyReflector;		
			sv_glossy_ptr->set_samples(num_samples, 1.0);			
			sv_glossy_ptr->set_ka(0.0);
			sv_glossy_ptr->set_kd(0.0);
			sv_glossy_ptr->set_ks(0.0);
			sv_glossy_ptr->set_cs(checker_ptr);
			sv_glossy_ptr->set_exp(1.0);
			sv_glossy_ptr->set_cd(checker_ptr);
			sv_glossy_ptr->set_kr(0.75); 
			sv_glossy_ptr->set_exponent(1.0);
			sv_glossy_ptr->set_cr(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_glossy_ptr);
			add_object(plane_ptr);
			break;
		}
	case 243:
		{
			//25.07
			int num_samples = 100;
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_max_depth(1);

			background_color = RGBColour(0.8, 0.9, 1);   // light blue
	
			tracer_ptr = new AreaLighting(this);	 
	
			Ambient* ambient_ptr = new Ambient;	
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			Pinhole* pinhole_ptr = new Pinhole;	
			pinhole_ptr->set_eye(0, 0, 20);     	
			pinhole_ptr->set_view_distance(3500); 
			pinhole_ptr->set_lookat(0);		
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// glossy reflector sphere	
	
			float exp = 1.0;  
	
			GlossyReflector* glossy_ptr = new GlossyReflector;
			glossy_ptr->set_samples(num_samples, exp);			
			glossy_ptr->set_ka(0.0); 
			glossy_ptr->set_kd(0.0);
			glossy_ptr->set_ks(0.0);
			glossy_ptr->set_exp(exp);
			glossy_ptr->set_cd(black);
			glossy_ptr->set_kr(0.8);
			glossy_ptr->set_exponent(exp);
			glossy_ptr->set_cr(white); 
	
			Sphere* sphere_ptr = new Sphere;  
			sphere_ptr->set_material(glossy_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 244:
		{
			//25.08a
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 25;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
		
			tracer_ptr = new AreaLighting(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-150, 75, 500); 
			pinhole_ptr->set_lookat(-6, 50, 0);
			pinhole_ptr->set_view_distance(3000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(250, 500, 250); 
			light_ptr1->scale_radiance(2.0);   
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);

			float exp = 1.0;  		// for Figure 25.30(a)
		//	float exp = 10.0;  		// for Figure 25.30(b)
		//	float exp = 100.0;  	// for Figure 25.30(c)
		//	float exp = 1000.0;  	// for Figure 25.30(d)
		//	float exp = 10000.0;  	// for Figure 25.30(e)
		//	float exp = 100000.0;  	// for Figure 25.30(f)
	
			GlossyReflector* glossy_ptr = new GlossyReflector;
			glossy_ptr->set_samples(num_samples, exp);			
			glossy_ptr->set_ka(0.0); 
			glossy_ptr->set_kd(0.0);
			glossy_ptr->set_ks(0.0);
			glossy_ptr->set_exp(exp);
			glossy_ptr->set_cd(1.0, 1.0, 0.3);
			glossy_ptr->set_kr(0.9);
			glossy_ptr->set_exponent(exp);
			glossy_ptr->set_cr(1.0, 1.0, 0.3);  // lemon
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(-6, 55, 0), 40);
			sphere_ptr1->set_material(glossy_ptr);
			add_object(sphere_ptr1);
		
	
			//cylinder
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.15);
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(0.5, 1.0, 0.5);   // green

			double bottom = -100;
			double top = 15;       
			double radius = 30;
			Instance* cylinder_ptr = new Instance(new SolidCylinder(bottom, top, radius));
			cylinder_ptr->translate(-6, 0, 0);
			cylinder_ptr->set_material(matte_ptr);
			add_object(cylinder_ptr);
	
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());  // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");  // for production
				
			LightProbeMap* light_probe_ptr = new LightProbeMap; 
			light_probe_ptr->set_map_type(panoramic);   		
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(1);
			sv_matte_ptr->set_kd(0.85);  
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr2 = new Instance(unit_sphere_ptr); 
			sphere_ptr2->scale(1000000.0);
			sphere_ptr2->set_material(sv_matte_ptr);
			add_object(sphere_ptr2);
			break;
		}
	case 245:
		{
			//25.08b
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 25;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
		
			tracer_ptr = new AreaLighting(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-150, 75, 500); 
			pinhole_ptr->set_lookat(-6, 50, 0);
			pinhole_ptr->set_view_distance(3000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(250, 500, 250); 
			light_ptr1->scale_radiance(2.0);   
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);

		//	float exp = 1.0;  		// for Figure 25.30(a)
			float exp = 10.0;  		// for Figure 25.30(b)
		//	float exp = 100.0;  	// for Figure 25.30(c)
		//	float exp = 1000.0;  	// for Figure 25.30(d)
		//	float exp = 10000.0;  	// for Figure 25.30(e)
		//	float exp = 100000.0;  	// for Figure 25.30(f)
	
			GlossyReflector* glossy_ptr = new GlossyReflector;
			glossy_ptr->set_samples(num_samples, exp);			
			glossy_ptr->set_ka(0.0); 
			glossy_ptr->set_kd(0.0);
			glossy_ptr->set_ks(0.0);
			glossy_ptr->set_exp(exp);
			glossy_ptr->set_cd(1.0, 1.0, 0.3);
			glossy_ptr->set_kr(0.9);
			glossy_ptr->set_exponent(exp);
			glossy_ptr->set_cr(1.0, 1.0, 0.3);  // lemon
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(-6, 55, 0), 40);
			sphere_ptr1->set_material(glossy_ptr);
			add_object(sphere_ptr1);
		
	
			//cylinder
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.15);
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(0.5, 1.0, 0.5);   // green

			double bottom = -100;
			double top = 15;       
			double radius = 30;
			Instance* cylinder_ptr = new Instance(new SolidCylinder(bottom, top, radius));
			cylinder_ptr->translate(-6, 0, 0);
			cylinder_ptr->set_material(matte_ptr);
			add_object(cylinder_ptr);
	
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());  // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");  // for production
				
			LightProbeMap* light_probe_ptr = new LightProbeMap; 
			light_probe_ptr->set_map_type(panoramic);   		
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(1);
			sv_matte_ptr->set_kd(0.85);  
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr2 = new Instance(unit_sphere_ptr); 
			sphere_ptr2->scale(1000000.0);
			sphere_ptr2->set_material(sv_matte_ptr);
			add_object(sphere_ptr2);
			break;
		}
	case 246:
		{
			//25.08c
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 25;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
		
			tracer_ptr = new AreaLighting(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-150, 75, 500); 
			pinhole_ptr->set_lookat(-6, 50, 0);
			pinhole_ptr->set_view_distance(3000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(250, 500, 250); 
			light_ptr1->scale_radiance(2.0);   
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);

		//	float exp = 1.0;  		// for Figure 25.30(a)
		//	float exp = 10.0;  		// for Figure 25.30(b)
			float exp = 100.0;  	// for Figure 25.30(c)
		//	float exp = 1000.0;  	// for Figure 25.30(d)
		//	float exp = 10000.0;  	// for Figure 25.30(e)
		//	float exp = 100000.0;  	// for Figure 25.30(f)
	
			GlossyReflector* glossy_ptr = new GlossyReflector;
			glossy_ptr->set_samples(num_samples, exp);			
			glossy_ptr->set_ka(0.0); 
			glossy_ptr->set_kd(0.0);
			glossy_ptr->set_ks(0.0);
			glossy_ptr->set_exp(exp);
			glossy_ptr->set_cd(1.0, 1.0, 0.3);
			glossy_ptr->set_kr(0.9);
			glossy_ptr->set_exponent(exp);
			glossy_ptr->set_cr(1.0, 1.0, 0.3);  // lemon
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(-6, 55, 0), 40);
			sphere_ptr1->set_material(glossy_ptr);
			add_object(sphere_ptr1);
		
	
			//cylinder
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.15);
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(0.5, 1.0, 0.5);   // green

			double bottom = -100;
			double top = 15;       
			double radius = 30;
			Instance* cylinder_ptr = new Instance(new SolidCylinder(bottom, top, radius));
			cylinder_ptr->translate(-6, 0, 0);
			cylinder_ptr->set_material(matte_ptr);
			add_object(cylinder_ptr);
	
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());  // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");  // for production
				
			LightProbeMap* light_probe_ptr = new LightProbeMap; 
			light_probe_ptr->set_map_type(panoramic);   		
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(1);
			sv_matte_ptr->set_kd(0.85);  
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr2 = new Instance(unit_sphere_ptr); 
			sphere_ptr2->scale(1000000.0);
			sphere_ptr2->set_material(sv_matte_ptr);
			add_object(sphere_ptr2);
			break;
		}
	case 247:
		{
			//25.08d
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 25;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
		
			tracer_ptr = new AreaLighting(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-150, 75, 500); 
			pinhole_ptr->set_lookat(-6, 50, 0);
			pinhole_ptr->set_view_distance(3000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(250, 500, 250); 
			light_ptr1->scale_radiance(2.0);   
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);

		//	float exp = 1.0;  		// for Figure 25.30(a)
		//	float exp = 10.0;  		// for Figure 25.30(b)
		//	float exp = 100.0;  	// for Figure 25.30(c)
			float exp = 1000.0;  	// for Figure 25.30(d)
		//	float exp = 10000.0;  	// for Figure 25.30(e)
		//	float exp = 100000.0;  	// for Figure 25.30(f)
	
			GlossyReflector* glossy_ptr = new GlossyReflector;
			glossy_ptr->set_samples(num_samples, exp);			
			glossy_ptr->set_ka(0.0); 
			glossy_ptr->set_kd(0.0);
			glossy_ptr->set_ks(0.0);
			glossy_ptr->set_exp(exp);
			glossy_ptr->set_cd(1.0, 1.0, 0.3);
			glossy_ptr->set_kr(0.9);
			glossy_ptr->set_exponent(exp);
			glossy_ptr->set_cr(1.0, 1.0, 0.3);  // lemon
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(-6, 55, 0), 40);
			sphere_ptr1->set_material(glossy_ptr);
			add_object(sphere_ptr1);
		
	
			//cylinder
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.15);
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(0.5, 1.0, 0.5);   // green

			double bottom = -100;
			double top = 15;       
			double radius = 30;
			Instance* cylinder_ptr = new Instance(new SolidCylinder(bottom, top, radius));
			cylinder_ptr->translate(-6, 0, 0);
			cylinder_ptr->set_material(matte_ptr);
			add_object(cylinder_ptr);
	
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());  // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");  // for production
				
			LightProbeMap* light_probe_ptr = new LightProbeMap; 
			light_probe_ptr->set_map_type(panoramic);   		
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(1);
			sv_matte_ptr->set_kd(0.85);  
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr2 = new Instance(unit_sphere_ptr); 
			sphere_ptr2->scale(1000000.0);
			sphere_ptr2->set_material(sv_matte_ptr);
			add_object(sphere_ptr2);
			break;
		}
	case 248:
		{
			//25.08e
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 25;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
		
			tracer_ptr = new AreaLighting(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-150, 75, 500); 
			pinhole_ptr->set_lookat(-6, 50, 0);
			pinhole_ptr->set_view_distance(3000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(250, 500, 250); 
			light_ptr1->scale_radiance(2.0);   
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);

		//	float exp = 1.0;  		// for Figure 25.30(a)
		//	float exp = 10.0;  		// for Figure 25.30(b)
		//	float exp = 100.0;  	// for Figure 25.30(c)
		//	float exp = 1000.0;  	// for Figure 25.30(d)
			float exp = 10000.0;  	// for Figure 25.30(e)
		//	float exp = 100000.0;  	// for Figure 25.30(f)
	
			GlossyReflector* glossy_ptr = new GlossyReflector;
			glossy_ptr->set_samples(num_samples, exp);			
			glossy_ptr->set_ka(0.0); 
			glossy_ptr->set_kd(0.0);
			glossy_ptr->set_ks(0.0);
			glossy_ptr->set_exp(exp);
			glossy_ptr->set_cd(1.0, 1.0, 0.3);
			glossy_ptr->set_kr(0.9);
			glossy_ptr->set_exponent(exp);
			glossy_ptr->set_cr(1.0, 1.0, 0.3);  // lemon
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(-6, 55, 0), 40);
			sphere_ptr1->set_material(glossy_ptr);
			add_object(sphere_ptr1);
		
	
			//cylinder
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.15);
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(0.5, 1.0, 0.5);   // green

			double bottom = -100;
			double top = 15;       
			double radius = 30;
			Instance* cylinder_ptr = new Instance(new SolidCylinder(bottom, top, radius));
			cylinder_ptr->translate(-6, 0, 0);
			cylinder_ptr->set_material(matte_ptr);
			add_object(cylinder_ptr);
	
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());  // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");  // for production
				
			LightProbeMap* light_probe_ptr = new LightProbeMap; 
			light_probe_ptr->set_map_type(panoramic);   		
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(1);
			sv_matte_ptr->set_kd(0.85);  
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr2 = new Instance(unit_sphere_ptr); 
			sphere_ptr2->scale(1000000.0);
			sphere_ptr2->set_material(sv_matte_ptr);
			add_object(sphere_ptr2);
			break;
		}
	case 249:
		{
			//25.08f
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 25;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
		
			tracer_ptr = new AreaLighting(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-150, 75, 500); 
			pinhole_ptr->set_lookat(-6, 50, 0);
			pinhole_ptr->set_view_distance(3000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(250, 500, 250); 
			light_ptr1->scale_radiance(2.0);   
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);

		//	float exp = 1.0;  		// for Figure 25.30(a)
		//	float exp = 10.0;  		// for Figure 25.30(b)
		//	float exp = 100.0;  	// for Figure 25.30(c)
		//	float exp = 1000.0;  	// for Figure 25.30(d)
		//	float exp = 10000.0;  	// for Figure 25.30(e)
			float exp = 100000.0;  	// for Figure 25.30(f)
	
			GlossyReflector* glossy_ptr = new GlossyReflector;
			glossy_ptr->set_samples(num_samples, exp);			
			glossy_ptr->set_ka(0.0); 
			glossy_ptr->set_kd(0.0);
			glossy_ptr->set_ks(0.0);
			glossy_ptr->set_exp(exp);
			glossy_ptr->set_cd(1.0, 1.0, 0.3);
			glossy_ptr->set_kr(0.9);
			glossy_ptr->set_exponent(exp);
			glossy_ptr->set_cr(1.0, 1.0, 0.3);  // lemon
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(-6, 55, 0), 40);
			sphere_ptr1->set_material(glossy_ptr);
			add_object(sphere_ptr1);
		
	
			//cylinder
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.15);
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(0.5, 1.0, 0.5);   // green

			double bottom = -100;
			double top = 15;       
			double radius = 30;
			Instance* cylinder_ptr = new Instance(new SolidCylinder(bottom, top, radius));
			cylinder_ptr->translate(-6, 0, 0);
			cylinder_ptr->set_material(matte_ptr);
			add_object(cylinder_ptr);
	
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());  // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");  // for production
				
			LightProbeMap* light_probe_ptr = new LightProbeMap; 
			light_probe_ptr->set_map_type(panoramic);   		
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(1);
			sv_matte_ptr->set_kd(0.85);  
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr2 = new Instance(unit_sphere_ptr); 
			sphere_ptr2->scale(1000000.0);
			sphere_ptr2->set_material(sv_matte_ptr);
			add_object(sphere_ptr2);
			break;
		}
	case 250:
		{
			//25.09
			int num_samples = 256;
	
			vp.set_hres(600);	  		
			vp.set_vres(200);
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
	
			background_color = black;
			tracer_ptr = new AreaLighting(this);
	
			Ambient* ambient_ptr = new Ambient; 
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-2, 300, 400);
			pinhole_ptr->set_lookat(-2, 8, 0);
			pinhole_ptr->set_view_distance(3500);
			pinhole_ptr->compute_uvw();  
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(20, 30, 40); 
			light_ptr->scale_radiance(4.0);
			light_ptr->set_shadows(false);
			add_light(light_ptr);

			// boxes
	
			float checker_size = 4.0;
	
			float exp1 = 100000.0;
			GlossyReflector* glossy_ptr1 = new GlossyReflector;
			glossy_ptr1->set_cd(0, 0.5, 0.25);
			glossy_ptr1->set_ka(0.2);
			glossy_ptr1->set_kd(0.3);	
			glossy_ptr1->set_ks(0.0);
			glossy_ptr1->set_exp(exp1);
			glossy_ptr1->set_kr(0.5);
			glossy_ptr1->set_sampler(new MultiJittered(num_samples), exp1);
		
			Box* box_ptr1 = new Box(-10.0 * checker_size, -6.0 * checker_size, 0, 5 * checker_size, -0.5, 0.0);
			box_ptr1->set_material(glossy_ptr1);
			add_object(box_ptr1);
	
			float exp2 = 10000.0;
			GlossyReflector* glossy_ptr2 = new GlossyReflector;
			glossy_ptr2->set_cd(0, 0.5, 0.25);
			glossy_ptr2->set_ka(0.2);
			glossy_ptr2->set_kd(0.3);	
			glossy_ptr2->set_ks(0.0);
			glossy_ptr2->set_exp(exp2);
			glossy_ptr2->set_kr(0.5);
			glossy_ptr2->set_sampler(new MultiJittered(num_samples), exp2);
	
			Box* box_ptr2 = new Box(-5.0 * checker_size, -checker_size, 0, 5 * checker_size, -0.5, 0.0);
			box_ptr2->set_material(glossy_ptr2);
			add_object(box_ptr2);
	
			float exp3 = 1000.0;
			GlossyReflector* glossy_ptr3 = new GlossyReflector;
			glossy_ptr3->set_cd(0, 0.5, 0.25);
			glossy_ptr3->set_ka(0.2);
			glossy_ptr3->set_kd(0.3);	
			glossy_ptr3->set_ks(0.0);
			glossy_ptr3->set_exp(exp3);
			glossy_ptr3->set_kr(0.5);
			glossy_ptr3->set_sampler(new MultiJittered(num_samples), exp3);
	
			//Box* box_ptr3 = new Box;
			Box* box_ptr3 = new Box(0, 4 * checker_size, 0, 5 * checker_size, -0.5, 0.0);
			box_ptr3->set_material(glossy_ptr3);
			add_object(box_ptr3);
	
			float exp4 = 100.0;
			GlossyReflector* glossy_ptr4 = new GlossyReflector;
			glossy_ptr4->set_cd(0, 0.5, 0.25);
			glossy_ptr4->set_ka(0.2);
			glossy_ptr4->set_kd(0.3);	
			glossy_ptr4->set_ks(0.0);
			glossy_ptr4->set_exp(exp4);
			glossy_ptr4->set_kr(0.5);
			glossy_ptr4->set_sampler(new MultiJittered(num_samples), exp4);
	
			Box* box_ptr4 = new Box(5 * checker_size, 9 * checker_size, 0, 5 * checker_size, -0.5, 0.0);
			box_ptr4->set_material(glossy_ptr4);
			add_object(box_ptr4);	
	
			// vertical back plane
	
			Matte* matte_ptr = new Matte;			
			matte_ptr->set_ka(0.25);    
			matte_ptr->set_kd(0.25);
			matte_ptr->set_cd(white);
	
			Plane* plane_ptr1 = new Plane(Point3D(0, 0, -4), Normal(0, 0, 1)); 
			plane_ptr1->set_material(matte_ptr);
			add_object(plane_ptr1);
	
	
			// ground plane with checker
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(checker_size);
			checker_ptr->set_color1(black);
			checker_ptr->set_color2(white);
	 
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.8);  
			sv_matte_ptr->set_kd(0.4);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr2 = new Plane(Point3D(0, -0.01, 0), Normal(0, 1, 0)); 
			plane_ptr2->set_material(sv_matte_ptr);
			add_object(plane_ptr2);	
			break;
		}
	case 251:
		{
			//25.10a
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);        
			vp.set_samples(num_samples);
			vp.set_max_depth(19);	
	
			tracer_ptr = new Whitted(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7.5, 3, 9.5);
			pinhole_ptr->set_lookat(5, 2.5, 0);
			pinhole_ptr->set_view_distance(800);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
				
	
			// four point lights near the ceiling
			// these don't use distance attenuation

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(10, 10, 0); 
			light_ptr1->scale_radiance(2.0); 
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);
    
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(0, 10, 10); 
			light_ptr2->scale_radiance(2.0); 
			light_ptr2->set_shadows(true); 
			add_light(light_ptr2);
    
			PointLight* light_ptr3 = new PointLight;
			light_ptr3->set_location(-10, 10, 0); 
			light_ptr3->scale_radiance(2.0); 
			light_ptr3->set_shadows(true); 
			add_light(light_ptr3);
    
			PointLight* light_ptr4 = new PointLight;
			light_ptr4->set_location(0, 10, -10); 
			light_ptr4->scale_radiance(2.0); 
			light_ptr4->set_shadows(true); 
			add_light(light_ptr4);

		
			// sphere
			// this is the only reflective object with a direct illumination shading component
	
			Reflective* reflective_ptr1 = new Reflective;			
			reflective_ptr1->set_ka(0.1); 
			reflective_ptr1->set_kd(0.4); 
			reflective_ptr1->set_cd(0, 0, 1);   	 // blue
			reflective_ptr1->set_ks(0.25);
			reflective_ptr1->set_exp(100.0);
			reflective_ptr1->set_kr(0.85); 
			reflective_ptr1->set_cr(0.75, 0.75, 1);  // blue 
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(0, 0.5, 0), 4); 
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
		
	
			// the walls, the ceiling, and the floor of the room are defined as planes
			// the shape is a cube
	
			double room_size = 11.0;
	
			// floor  (-ve yw)
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.1);   
			matte_ptr1->set_kd(0.50);
			matte_ptr1->set_cd(0.25);     // medium grey
	
			Plane* floor_ptr = new Plane(Point3D(0, -room_size,  0), Normal(0, 1, 0));
			floor_ptr->set_material(matte_ptr1);        
			add_object(floor_ptr);
	
	
			// ceiling  (+ve yw)
	
			Matte* matte_ptr2 = new Matte;   
			matte_ptr2->set_ka(0.35);   
			matte_ptr2->set_kd(0.50);
			matte_ptr2->set_cd(white);
	
			Plane* ceiling_ptr = new Plane(Point3D(0, room_size,  0), Normal(0, -1, 0));
			ceiling_ptr->set_material(matte_ptr2);        
			add_object(ceiling_ptr);
	
	
			// back wall  (-ve zw)
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.15); 
			matte_ptr3->set_kd(0.60);
			matte_ptr3->set_cd(0.5, 0.75, 0.75);     // cyan
	
			Plane* backWall_ptr = new Plane(Point3D(0, 0,  -room_size), Normal(0, 0, 1));
			backWall_ptr->set_material(matte_ptr3);        
			add_object(backWall_ptr);
	
			// front wall  (+ve zw)
	
			Plane* frontWall_ptr = new Plane(Point3D(0, 0,  room_size), Normal(0, 0, -1));
			frontWall_ptr->set_material(matte_ptr3);        
			add_object(frontWall_ptr);
	
			// left wall  (-ve xw)
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(0.15); 
			matte_ptr4->set_kd(0.60);
			matte_ptr4->set_cd(0.71, 0.40, 0.20);   // orange
	
			Plane* leftWall_ptr = new Plane(Point3D(-room_size, 0, 0), Normal(1, 0, 0));
			leftWall_ptr->set_material(matte_ptr4);        
			add_object(leftWall_ptr);
	
			// right wall  (+ve xw)
	
			Plane* rightWall_ptr = new Plane(Point3D(room_size, 0, 0), Normal(-1, 0, 0));
			rightWall_ptr->set_material(matte_ptr4);        
			add_object(rightWall_ptr);
	
	
			// mirrors on the walls
			// the right wall has no mirror
	
			double mirror_size 	= 8;  	// the mirror size
			double offset 		= 1.0;  // the mirror offset from the walls
	
			// mirror material
			// this has no direct illumination and a slight green tint
	
			Reflective* reflective_ptr2 = new Reflective;			
			reflective_ptr2->set_ka(0); 
			reflective_ptr2->set_kd(0);
			reflective_ptr2->set_cd(black); 
			reflective_ptr2->set_ks(0);
			reflective_ptr2->set_kr(0.9);
			reflective_ptr2->set_cr(0.9, 1.0, 0.9);  // light green
	
			// back wall mirror  (-ve zw)

			Point3D p0;
			Vector3D a, b;
	
			p0 = Point3D(-mirror_size, -mirror_size, -(room_size - offset));
			a = Vector3D(2.0 * mirror_size, 0, 0);
			b = Vector3D(0, 2.0 * mirror_size, 0);
			Normal n(0, 0, 1);
			TRectangle* rectangle_ptr1 = new TRectangle(p0, a, b, n);
			rectangle_ptr1->set_material(reflective_ptr2); 
			add_object(rectangle_ptr1);
	
	
			// front wall mirror  (+ve zw)
	
			p0 = Point3D(-mirror_size, -mirror_size, +(room_size - offset));
			n = Normal(0, 0, -1);
			TRectangle* rectangle_ptr2 = new TRectangle(p0, a, b, n);
			rectangle_ptr2->set_material(reflective_ptr2); 
			add_object(rectangle_ptr2);
	
	
			// left wall mirror  (-ve xw)
	
			p0 = Point3D(-(room_size - offset), -mirror_size, +mirror_size);
			a = Point3D(0, 0, -2.0 * mirror_size);
			n = Normal(1, 0, 0);
			TRectangle* rectangle_ptr3 = new TRectangle(p0, a, b, n);
			rectangle_ptr3->set_material(reflective_ptr2); 
			add_object(rectangle_ptr3);


			// horizontal mirror underneath the sphere
			// this has no direct illumination and a lemon color
	
			Reflective* reflective_ptr3 = new Reflective;			
			reflective_ptr3->set_ka(0); 
			reflective_ptr3->set_kd(0);
			reflective_ptr3->set_cd(black); 
			reflective_ptr3->set_ks(0);
			reflective_ptr3->set_kr(1);
			reflective_ptr3->set_cr(1, 1, 0.5);  // lemon
	
			double yw = -4.0;   // the yw location of the mirror
	
			p0 = Point3D(-mirror_size, yw, -mirror_size);
			a = Vector3D(0, 0, 2.0 * mirror_size);
			b = Vector3D(2.0 * mirror_size, 0, 0);
			n = Normal(0, 1, 0);
			TRectangle* rectangle_ptr4 = new TRectangle(p0, a, b, n);
			rectangle_ptr4->set_material(reflective_ptr3); 
			add_object(rectangle_ptr4);
			break;
		}
	case 252:
		{
			//25.10b
			int num_samples = 100;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);        
			vp.set_samples(num_samples);
			vp.set_max_depth(19);	
	
			tracer_ptr = new AreaLighting(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(7.5, 3, 9.5);
			pinhole_ptr->set_lookat(5, 2.5, 0);
			pinhole_ptr->set_view_distance(800);
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
				
	
			// four point lights near the ceiling
			// these don't use distance attenuation

			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(10, 10, 0); 
			light_ptr1->scale_radiance(2.0); 
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);
    
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(0, 10, 10); 
			light_ptr2->scale_radiance(2.0); 
			light_ptr2->set_shadows(true); 
			add_light(light_ptr2);
    
			PointLight* light_ptr3 = new PointLight;
			light_ptr3->set_location(-10, 10, 0); 
			light_ptr3->scale_radiance(2.0); 
			light_ptr3->set_shadows(true); 
			add_light(light_ptr3);
    
			PointLight* light_ptr4 = new PointLight;
			light_ptr4->set_location(0, 10, -10); 
			light_ptr4->scale_radiance(2.0); 
			light_ptr4->set_shadows(true); 
			add_light(light_ptr4);

		
			// sphere
			// this is the only reflective object with a direct illumination shading component
	
			Reflective* reflective_ptr1 = new Reflective;			
			reflective_ptr1->set_ka(0.1); 
			reflective_ptr1->set_kd(0.4); 
			reflective_ptr1->set_cd(0, 0, 1);   	 // blue
			reflective_ptr1->set_ks(0.25);
			reflective_ptr1->set_exp(100.0);
			reflective_ptr1->set_kr(0.85); 
			reflective_ptr1->set_cr(0.75, 0.75, 1);  // blue 
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(0, 0.5, 0), 4); 
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
		
	
			// the walls, the ceiling, and the floor of the room are defined as planes
			// the shape is a cube
	
			double room_size = 11.0;
	
			// floor  (-ve yw)
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.1);   
			matte_ptr1->set_kd(0.50);
			matte_ptr1->set_cd(0.25);     // medium grey
	
			Plane* floor_ptr = new Plane(Point3D(0, -room_size,  0), Normal(0, 1, 0));
			floor_ptr->set_material(matte_ptr1);        
			add_object(floor_ptr);
	
	
			// ceiling  (+ve yw)
	
			Matte* matte_ptr2 = new Matte;   
			matte_ptr2->set_ka(0.35);   
			matte_ptr2->set_kd(0.50);
			matte_ptr2->set_cd(white);
	
			Plane* ceiling_ptr = new Plane(Point3D(0, room_size,  0), Normal(0, -1, 0));
			ceiling_ptr->set_material(matte_ptr2);        
			add_object(ceiling_ptr);
	
	
			// back wall  (-ve zw)
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.15); 
			matte_ptr3->set_kd(0.60);
			matte_ptr3->set_cd(0.5, 0.75, 0.75);     // cyan
	
			Plane* backWall_ptr = new Plane(Point3D(0, 0,  -room_size), Normal(0, 0, 1));
			backWall_ptr->set_material(matte_ptr3);        
			add_object(backWall_ptr);
	
			// front wall  (+ve zw)
	
			Plane* frontWall_ptr = new Plane(Point3D(0, 0,  room_size), Normal(0, 0, -1));
			frontWall_ptr->set_material(matte_ptr3);        
			add_object(frontWall_ptr);
	
			// left wall  (-ve xw)
	
			Matte* matte_ptr4 = new Matte;
			matte_ptr4->set_ka(0.15); 
			matte_ptr4->set_kd(0.60);
			matte_ptr4->set_cd(0.71, 0.40, 0.20);   // orange
	
			Plane* leftWall_ptr = new Plane(Point3D(-room_size, 0, 0), Normal(1, 0, 0));
			leftWall_ptr->set_material(matte_ptr4);        
			add_object(leftWall_ptr);
	
			// right wall  (+ve xw)
	
			Plane* rightWall_ptr = new Plane(Point3D(room_size, 0, 0), Normal(-1, 0, 0));
			rightWall_ptr->set_material(matte_ptr4);        
			add_object(rightWall_ptr);
	
	
			// mirrors on the walls
			// the right wall has no mirror
	
			double mirror_size 	= 8;  	// the mirror size
			double offset 		= 1.0;  // the mirror offset from the walls
	
			// mirror reflection material for the left wall mirror
	
			Reflective* reflective_ptr2 = new Reflective;			
			reflective_ptr2->set_ka(0); 
			reflective_ptr2->set_kd(0);
			reflective_ptr2->set_cd(black); 
			reflective_ptr2->set_ks(0);
			reflective_ptr2->set_kr(0.9);
			reflective_ptr2->set_cr(0.9, 1.0, 0.9);  // light green
	
			// glossy reflector material for the back and front mirrors
	
			float exp = 25000.0;
			GlossyReflector* glossy_reflector_ptr = new GlossyReflector;
			glossy_reflector_ptr->set_samples(num_samples, exp);			
			glossy_reflector_ptr->set_ka(0.0); 
			glossy_reflector_ptr->set_kd(0.0);
			glossy_reflector_ptr->set_ks(0.0);
			glossy_reflector_ptr->set_exp(exp);
			glossy_reflector_ptr->set_cd(black);
			glossy_reflector_ptr->set_kr(0.9);
			glossy_reflector_ptr->set_exponent(exp);
			glossy_reflector_ptr->set_cr(0.9, 1.0, 0.9);  // light green
	
	
			// back wall mirror  (-ve zw)

			Point3D p0;
			Vector3D a, b;
	
			p0 = Point3D(-mirror_size, -mirror_size, -(room_size - offset));
			a = Vector3D(2.0 * mirror_size, 0, 0);
			b = Vector3D(0, 2.0 * mirror_size, 0);
			Normal n(0, 0, 1);
			TRectangle* rectangle_ptr1 = new TRectangle(p0, a, b, n);
		//	rectangle_ptr1->set_material(reflective_ptr2);
			rectangle_ptr1->set_material(glossy_reflector_ptr); 
			add_object(rectangle_ptr1);
	
	
			// front wall mirror  (+ve zw)
	
			p0 = Point3D(-mirror_size, -mirror_size, +(room_size - offset));
			n = Normal(0, 0, -1);
			TRectangle* rectangle_ptr2 = new TRectangle(p0, a, b, n);
		//	rectangle_ptr2->set_material(reflective_ptr2); 
			rectangle_ptr2->set_material(glossy_reflector_ptr); 
			add_object(rectangle_ptr2);
	
	
			// left wall mirror  (-ve xw)
	
			p0 = Point3D(-(room_size - offset), -mirror_size, +mirror_size);
			a = Point3D(0, 0, -2.0 * mirror_size);
			n = Normal(1, 0, 0);
			TRectangle* rectangle_ptr3 = new TRectangle(p0, a, b, n);
			rectangle_ptr3->set_material(reflective_ptr2); 
			add_object(rectangle_ptr3);


			// horizontal mirror underneath the sphere
			// this has no direct illumination and a lemon color
	
			Reflective* reflective_ptr3 = new Reflective;			
			reflective_ptr3->set_ka(0); 
			reflective_ptr3->set_kd(0);
			reflective_ptr3->set_cd(black); 
			reflective_ptr3->set_ks(0);
			reflective_ptr3->set_kr(1);
			reflective_ptr3->set_cr(1, 1, 0.5);  // lemon
	
			double yw = -4.0;   // the yw location of the mirror
	
			p0 = Point3D(-mirror_size, yw, -mirror_size);
			a = Vector3D(0, 0, 2.0 * mirror_size);
			b = Vector3D(2.0 * mirror_size, 0, 0);
			n = Normal(0, 1, 0);
			TRectangle* rectangle_ptr4 = new TRectangle(p0, a, b, n);
			rectangle_ptr4->set_material(reflective_ptr3); 
			add_object(rectangle_ptr4);
			break;
		}
	case 253:
		{
			//25.12
			int num_samples = 100;
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_max_depth(1);

			background_color = RGBColour(0.8, 0.9, 1);
	
			tracer_ptr = new AreaLighting(this);	 
	
			Ambient* ambient_ptr = new Ambient;	
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			Pinhole* pinhole_ptr = new Pinhole;
	
			// view with checker
	
			pinhole_ptr->set_eye(5, 0, 20);     	
			pinhole_ptr->set_view_distance(3000); 
			pinhole_ptr->set_lookat(0);		
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			// Point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(10, 30, 20); 
			light_ptr1->scale_radiance(5.0);
			light_ptr1->set_shadows(false);
			add_light(light_ptr1);	
	
	
			// glossy reflector sphere	
	
			float exp = 100.0; 
	
			GlossyReflector* glossy_ptr = new GlossyReflector;
			glossy_ptr->set_samples(num_samples, exp);			
			glossy_ptr->set_ka(0.0); 
			glossy_ptr->set_kd(0.0);
			glossy_ptr->set_ks(0.0);
			glossy_ptr->set_exp(exp);
			glossy_ptr->set_cd(black);
			glossy_ptr->set_kr(0.8);
			glossy_ptr->set_exponent(exp);
			glossy_ptr->set_cr(white); 
	
			Sphere* sphere_ptr = new Sphere;  
			sphere_ptr->set_material(glossy_ptr);
			add_object(sphere_ptr);
	
	
			// ground plane with checker
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4.0);
			checker_ptr->set_color1(white); 
			checker_ptr->set_color2(black);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(1);
			sv_matte_ptr->set_kd(0.4);
			sv_matte_ptr->set_cd(checker_ptr);

			Plane* plane_ptr = new Plane(Point3D(0, -5.01, 0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);	
			break;
		}
	case 254:
		{
			//25.13a
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 1;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
		
			tracer_ptr = new AreaLighting(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-150, 75, 500); 
			pinhole_ptr->set_lookat(-6, 50, 0);
			pinhole_ptr->set_view_distance(3000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(250, 500, 250); 
			light_ptr1->scale_radiance(2.0);   
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);

			float exp = 1.0;  	
			GlossyReflector* glossy_ptr = new GlossyReflector;
			glossy_ptr->set_sampler(new PureRandom(num_samples), exp);		// for Figure 25.13(a)
		//	glossy_ptr->set_sampler(new Regular(num_samples), exp);			// for Figure 25.13(b)
		//	glossy_ptr->set_sampler(new Hammersley(num_samples), exp);		// for Figure 25.13(c)		
			glossy_ptr->set_ka(0.0); 
			glossy_ptr->set_kd(0.0);
			glossy_ptr->set_ks(0.0);
			glossy_ptr->set_exp(exp);
			glossy_ptr->set_cd(1.0, 1.0, 0.3);
			glossy_ptr->set_kr(0.9);
			glossy_ptr->set_exponent(exp);
			glossy_ptr->set_cr(1.0, 1.0, 0.3);  // lemon
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(-6, 55, 0), 40);
			sphere_ptr1->set_material(glossy_ptr);
			add_object(sphere_ptr1);
		
	
			//cylinder
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.15);
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(0.5, 1.0, 0.5);   // green

			double bottom = -100;
			double top = 15;       
			double radius = 30;
			Instance* cylinder_ptr = new Instance(new SolidCylinder(bottom, top, radius));
			cylinder_ptr->translate(-6, 0, 0);
			cylinder_ptr->set_material(matte_ptr);
			add_object(cylinder_ptr);
	
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());  // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");  // for production

	
			LightProbeMap* light_probe_ptr = new LightProbeMap; 
			light_probe_ptr->set_map_type(panoramic);   		
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(1);
			sv_matte_ptr->set_kd(0.85);  
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr2 = new Instance(unit_sphere_ptr); 
			sphere_ptr2->scale(1000000.0);
			sphere_ptr2->set_material(sv_matte_ptr);
			add_object(sphere_ptr2);
			break;
		}
	case 255:
		{
			//25.13b
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 1;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
		
			tracer_ptr = new AreaLighting(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-150, 75, 500); 
			pinhole_ptr->set_lookat(-6, 50, 0);
			pinhole_ptr->set_view_distance(3000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(250, 500, 250); 
			light_ptr1->scale_radiance(2.0);   
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);

			float exp = 1.0;  	
			GlossyReflector* glossy_ptr = new GlossyReflector;
		//	glossy_ptr->set_sampler(new PureRandom(num_samples), exp);		// for Figure 25.13(a)
			glossy_ptr->set_sampler(new Regular(num_samples), exp);			// for Figure 25.13(b)
		//	glossy_ptr->set_sampler(new Hammersley(num_samples), exp);		// for Figure 25.13(c)		
			glossy_ptr->set_ka(0.0); 
			glossy_ptr->set_kd(0.0);
			glossy_ptr->set_ks(0.0);
			glossy_ptr->set_exp(exp);
			glossy_ptr->set_cd(1.0, 1.0, 0.3);
			glossy_ptr->set_kr(0.9);
			glossy_ptr->set_exponent(exp);
			glossy_ptr->set_cr(1.0, 1.0, 0.3);  // lemon
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(-6, 55, 0), 40);
			sphere_ptr1->set_material(glossy_ptr);
			add_object(sphere_ptr1);
		
	
			//cylinder
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.15);
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(0.5, 1.0, 0.5);   // green

			double bottom = -100;
			double top = 15;       
			double radius = 30;
			Instance* cylinder_ptr = new Instance(new SolidCylinder(bottom, top, radius));
			cylinder_ptr->translate(-6, 0, 0);
			cylinder_ptr->set_material(matte_ptr);
			add_object(cylinder_ptr);
	
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());  // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");  // for production

	
			LightProbeMap* light_probe_ptr = new LightProbeMap; 
			light_probe_ptr->set_map_type(panoramic);   		
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(1);
			sv_matte_ptr->set_kd(0.85);  
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr2 = new Instance(unit_sphere_ptr); 
			sphere_ptr2->scale(1000000.0);
			sphere_ptr2->set_material(sv_matte_ptr);
			add_object(sphere_ptr2);
			break;
		}
	case 256:
		{
			//25.13c
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 1;
	
			vp.set_hres(600);			
			vp.set_vres(600); 
			vp.set_samples(num_samples);
			vp.set_max_depth(1);
		
			tracer_ptr = new AreaLighting(this);	
				
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-150, 75, 500); 
			pinhole_ptr->set_lookat(-6, 50, 0);
			pinhole_ptr->set_view_distance(3000);	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(250, 500, 250); 
			light_ptr1->scale_radiance(2.0);   
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);

			float exp = 1.0;  	
			GlossyReflector* glossy_ptr = new GlossyReflector;
		//	glossy_ptr->set_sampler(new PureRandom(num_samples), exp);		// for Figure 25.13(a)
		//	glossy_ptr->set_sampler(new Regular(num_samples), exp);			// for Figure 25.13(b)
			glossy_ptr->set_sampler(new Hammersley(num_samples), exp);		// for Figure 25.13(c)		
			glossy_ptr->set_ka(0.0); 
			glossy_ptr->set_kd(0.0);
			glossy_ptr->set_ks(0.0);
			glossy_ptr->set_exp(exp);
			glossy_ptr->set_cd(1.0, 1.0, 0.3);
			glossy_ptr->set_kr(0.9);
			glossy_ptr->set_exponent(exp);
			glossy_ptr->set_cr(1.0, 1.0, 0.3);  // lemon
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(-6, 55, 0), 40);
			sphere_ptr1->set_material(glossy_ptr);
			add_object(sphere_ptr1);
		
	
			//cylinder
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.15);
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(0.5, 1.0, 0.5);   // green

			double bottom = -100;
			double top = 15;       
			double radius = 30;
			Instance* cylinder_ptr = new Instance(new SolidCylinder(bottom, top, radius));
			cylinder_ptr->translate(-6, 0, 0);
			cylinder_ptr->set_material(matte_ptr);
			add_object(cylinder_ptr);
	
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());  // for testing 
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");  // for production

	
			LightProbeMap* light_probe_ptr = new LightProbeMap; 
			light_probe_ptr->set_map_type(panoramic);   		
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(1);
			sv_matte_ptr->set_kd(0.85);  
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr2 = new Instance(unit_sphere_ptr); 
			sphere_ptr2->scale(1000000.0);
			sphere_ptr2->set_material(sv_matte_ptr);
			add_object(sphere_ptr2);
			break;
		}
	case 257:
		{
			//26.05
			int num_samples = 100;

			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new AreaLighting(this);

			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.0);
			set_ambient_light(ambient_ptr);	

			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 45, 100);  
			pinhole_ptr->set_lookat(-10, 40, 0);  
			pinhole_ptr->set_view_distance(400);  	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(white);  
			emissive_ptr->scale_radiance(1.5);   
							
			EnvironmentLight* environmentLight_ptr = new EnvironmentLight;
			environmentLight_ptr->set_material(emissive_ptr);
			environmentLight_ptr->set_sampler(new MultiJittered(num_samples));
			environmentLight_ptr->set_shadows(true);
			add_light(environmentLight_ptr);
	
	
			ConcaveSphere* sphere_ptr = new ConcaveSphere;		// centered on the origin
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_shadows(false);
			sphere_ptr->set_material(emissive_ptr);
			add_object(sphere_ptr);	
	
		
			float ka = 0.2;  // common ambient reflection coefficient	

		
			// large sphere

			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(ka); 
			matte_ptr1->set_kd(0.60);
			matte_ptr1->set_cd(white);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, 20, -24), 20); 
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
	
			// small sphere
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(ka); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.85);				// gray
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(34, 12, 13), 12);
			sphere_ptr2->set_material(matte_ptr2);
			add_object(sphere_ptr2);
	
	
			// medium sphere
		
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(ka); 
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(0.73, 0.22, 0.0);    // orange
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(-7, 15, 42), 16);
			sphere_ptr3->set_material(matte_ptr3);
			add_object(sphere_ptr3);
	
	
			// cylinder
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(ka); 
			matte_ptr4->set_kd(0.75);
			matte_ptr4->set_cd(0.60);				// gray
			
			double bottom 	= 0.0;
			double top 		= 85.0;
			double radius	= 22.0;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr4);
			add_object(cylinder_ptr);

	
			// box
	
			MultiJittered* sampler_ptr5 = new MultiJittered(num_samples);
	
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(ka); 
			matte_ptr5->set_kd(0.75);
			matte_ptr5->set_cd(0.95);				// gray
	
			Box* box_ptr = new Box(Point3D(-55, 0, -110), Point3D(-25, 60, 65));  // thicker
			box_ptr->set_material(matte_ptr5);
			add_object(box_ptr);
	
	
			// ground plane
			
			Matte* matte_ptr6 = new Matte;			
			matte_ptr6->set_ka(0.15); 
			matte_ptr6->set_kd(0.95);	
			matte_ptr6->set_cd(0.37, 0.43, 0.08);     // olive green
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr6);
			add_object(plane_ptr);
			break;
		}
	case 258:
		{
			//26.06a
			int num_samples = 1;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_max_depth(0);				// for Figure 26.6(a)
		//	vp.set_max_depth(1);				// for Figure 26.6(b)
		//	vp.set_max_depth(5);				// for Figure 26.6(c)
	
			tracer_ptr = new PathTrace(this);	

			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.0);
			set_ambient_light(ambient_ptr);	

			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 45, 100);  
			pinhole_ptr->set_lookat(-10, 40, 0);  
			pinhole_ptr->set_view_distance(400);   	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(white);  
			emissive_ptr->scale_radiance(1.5);  
	
	
			ConcaveSphere* sphere_ptr = new ConcaveSphere;		// centered on the origin
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_shadows(false);
			sphere_ptr->set_material(emissive_ptr);
			add_object(sphere_ptr);	
	
		
			float ka = 0.2;  // common ambient reflection coefficient	

		
			// large sphere

			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(ka); 
			matte_ptr1->set_kd(0.60);
			matte_ptr1->set_cd(white);
			matte_ptr1->set_sampler(new MultiJittered(num_samples));
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, 20, -24), 20); 
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
	
			// small sphere
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(ka); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.85);				// gray
			matte_ptr2->set_sampler(new MultiJittered(num_samples));
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(34, 12, 13), 12);
			sphere_ptr2->set_material(matte_ptr2);
			add_object(sphere_ptr2);
	
	
			// medium sphere
		
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(ka); 
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(0.73, 0.22, 0.0);    // orange
			matte_ptr3->set_sampler(new MultiJittered(num_samples));
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(-7, 15, 42), 16);
			sphere_ptr3->set_material(matte_ptr3);
			add_object(sphere_ptr3);
	
	
			// cylinder
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(ka); 
			matte_ptr4->set_kd(0.75);
			matte_ptr4->set_cd(0.60);				// gray
			matte_ptr4->set_sampler(new MultiJittered(num_samples));
			
			double bottom 	= 0.0;
			double top 		= 85.0;
			double radius	= 22.0;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr4);
			add_object(cylinder_ptr);

	
			// box
		
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(ka); 
			matte_ptr5->set_kd(0.75);
			matte_ptr5->set_cd(0.95);				// gray
			matte_ptr5->set_sampler(new MultiJittered(num_samples));
	
			Box* box_ptr = new Box(Point3D(-55, 0, -110), Point3D(-25, 60, 65));  // thicker
			box_ptr->set_material(matte_ptr5);
			add_object(box_ptr);
	
	
			// ground plane
		
			MultiJittered* sampler_ptr6 = new MultiJittered(num_samples);
	
			Matte* matte_ptr6 = new Matte;			
			matte_ptr6->set_ka(0.15); 
			matte_ptr6->set_kd(0.95);	
			matte_ptr6->set_cd(0.37, 0.43, 0.08);     // olive green
			matte_ptr6->set_sampler(new MultiJittered(num_samples));    
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr6);
			add_object(plane_ptr);

			break;
		}
	case 259:
		{
			//26.06b
			int num_samples = 1;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
		//	vp.set_max_depth(0);				// for Figure 26.6(a)
			vp.set_max_depth(1);				// for Figure 26.6(b)
		//	vp.set_max_depth(5);				// for Figure 26.6(c)
	
			tracer_ptr = new PathTrace(this);	

			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.0);
			set_ambient_light(ambient_ptr);	

			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 45, 100);  
			pinhole_ptr->set_lookat(-10, 40, 0);  
			pinhole_ptr->set_view_distance(400);   	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(white);  
			emissive_ptr->scale_radiance(1.5);  
	
	
			ConcaveSphere* sphere_ptr = new ConcaveSphere;		// centered on the origin
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_shadows(false);
			sphere_ptr->set_material(emissive_ptr);
			add_object(sphere_ptr);	
	
		
			float ka = 0.2;  // common ambient reflection coefficient	

		
			// large sphere

			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(ka); 
			matte_ptr1->set_kd(0.60);
			matte_ptr1->set_cd(white);
			matte_ptr1->set_sampler(new MultiJittered(num_samples));
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, 20, -24), 20); 
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
	
			// small sphere
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(ka); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.85);				// gray
			matte_ptr2->set_sampler(new MultiJittered(num_samples));
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(34, 12, 13), 12);
			sphere_ptr2->set_material(matte_ptr2);
			add_object(sphere_ptr2);
	
	
			// medium sphere
		
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(ka); 
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(0.73, 0.22, 0.0);    // orange
			matte_ptr3->set_sampler(new MultiJittered(num_samples));
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(-7, 15, 42), 16);
			sphere_ptr3->set_material(matte_ptr3);
			add_object(sphere_ptr3);
	
	
			// cylinder
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(ka); 
			matte_ptr4->set_kd(0.75);
			matte_ptr4->set_cd(0.60);				// gray
			matte_ptr4->set_sampler(new MultiJittered(num_samples));
			
			double bottom 	= 0.0;
			double top 		= 85.0;
			double radius	= 22.0;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr4);
			add_object(cylinder_ptr);

	
			// box
		
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(ka); 
			matte_ptr5->set_kd(0.75);
			matte_ptr5->set_cd(0.95);				// gray
			matte_ptr5->set_sampler(new MultiJittered(num_samples));
	
			Box* box_ptr = new Box(Point3D(-55, 0, -110), Point3D(-25, 60, 65));  // thicker
			box_ptr->set_material(matte_ptr5);
			add_object(box_ptr);
	
	
			// ground plane
		
			MultiJittered* sampler_ptr6 = new MultiJittered(num_samples);
	
			Matte* matte_ptr6 = new Matte;			
			matte_ptr6->set_ka(0.15); 
			matte_ptr6->set_kd(0.95);	
			matte_ptr6->set_cd(0.37, 0.43, 0.08);     // olive green
			matte_ptr6->set_sampler(new MultiJittered(num_samples));    
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr6);
			add_object(plane_ptr);

			break;
		}
	case 260:
		{
			//26.06c
			int num_samples = 1;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
		//	vp.set_max_depth(0);				// for Figure 26.6(a)
		//	vp.set_max_depth(1);				// for Figure 26.6(b)
			vp.set_max_depth(5);				// for Figure 26.6(c)
	
			tracer_ptr = new PathTrace(this);	

			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.0);
			set_ambient_light(ambient_ptr);	

			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 45, 100);  
			pinhole_ptr->set_lookat(-10, 40, 0);  
			pinhole_ptr->set_view_distance(400);   	
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(white);  
			emissive_ptr->scale_radiance(1.5);  
	
	
			ConcaveSphere* sphere_ptr = new ConcaveSphere;		// centered on the origin
			sphere_ptr->set_radius(1000000.0);
			sphere_ptr->set_shadows(false);
			sphere_ptr->set_material(emissive_ptr);
			add_object(sphere_ptr);	
	
		
			float ka = 0.2;  // common ambient reflection coefficient	

		
			// large sphere

			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(ka); 
			matte_ptr1->set_kd(0.60);
			matte_ptr1->set_cd(white);
			matte_ptr1->set_sampler(new MultiJittered(num_samples));
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, 20, -24), 20); 
			sphere_ptr1->set_material(matte_ptr1);
			add_object(sphere_ptr1);
	
	
			// small sphere
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(ka); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.85);				// gray
			matte_ptr2->set_sampler(new MultiJittered(num_samples));
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(34, 12, 13), 12);
			sphere_ptr2->set_material(matte_ptr2);
			add_object(sphere_ptr2);
	
	
			// medium sphere
		
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(ka); 
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(0.73, 0.22, 0.0);    // orange
			matte_ptr3->set_sampler(new MultiJittered(num_samples));
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(-7, 15, 42), 16);
			sphere_ptr3->set_material(matte_ptr3);
			add_object(sphere_ptr3);
	
	
			// cylinder
	
			Matte* matte_ptr4 = new Matte;			
			matte_ptr4->set_ka(ka); 
			matte_ptr4->set_kd(0.75);
			matte_ptr4->set_cd(0.60);				// gray
			matte_ptr4->set_sampler(new MultiJittered(num_samples));
			
			double bottom 	= 0.0;
			double top 		= 85.0;
			double radius	= 22.0;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(matte_ptr4);
			add_object(cylinder_ptr);

	
			// box
		
			Matte* matte_ptr5 = new Matte;			
			matte_ptr5->set_ka(ka); 
			matte_ptr5->set_kd(0.75);
			matte_ptr5->set_cd(0.95);				// gray
			matte_ptr5->set_sampler(new MultiJittered(num_samples));
	
			Box* box_ptr = new Box(Point3D(-55, 0, -110), Point3D(-25, 60, 65));  // thicker
			box_ptr->set_material(matte_ptr5);
			add_object(box_ptr);
	
	
			// ground plane
		
			MultiJittered* sampler_ptr6 = new MultiJittered(num_samples);
	
			Matte* matte_ptr6 = new Matte;			
			matte_ptr6->set_ka(0.15); 
			matte_ptr6->set_kd(0.95);	
			matte_ptr6->set_cd(0.37, 0.43, 0.08);     // olive green
			matte_ptr6->set_sampler(new MultiJittered(num_samples));    
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr6);
			add_object(plane_ptr);

			break;
		}
	case 261:
		{
			//26.07a
			int num_samples = 1;		// for Figure 26.7(a)
		//	int num_samples = 100;		// for Figure 26.7(b)
		//	int num_samples = 1024;		// for Figure 26.7(c)
		//	int num_samples = 10000;	// for Figure 26.7(d)
		
			vp.set_hres(300);	  		
			vp.set_vres(300);
			vp.set_samples(num_samples); 
			vp.set_max_depth(10);
	
			background_color = black;
	
			tracer_ptr = new PathTrace(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(27.6, 27.4, -80.0);
			pinhole_ptr->set_lookat(27.6, 27.4, 0.0);
			pinhole_ptr->set_view_distance(400);      
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			Point3D p0;
			Vector3D a, b;
			Normal normal;
	
			// box dimensions
	
			double width 	= 55.28;   	// x direction
			double height 	= 54.88;  	// y direction
			double depth 	= 55.92;	// z direction
	
	
			// the ceiling light - doesn't need samples
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(1.0, 0.73, 0.4);   
			emissive_ptr->scale_radiance(100);
	
			p0 = Point3D(21.3, height - 0.001, 22.7);
			a = Vector3D(0.0, 0.0, 10.5);
			b = Vector3D(13.0, 0.0, 0.0);
			normal = Normal(0.0, -1.0, 0.0);
			TRectangle* light_ptr = new TRectangle(p0, a, b, normal);
			light_ptr->set_material(emissive_ptr);
			add_object(light_ptr);
	
		
			// left wall
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.0);
			matte_ptr1->set_kd(0.6); 
			matte_ptr1->set_cd(0.57, 0.025, 0.025);	 // red
			matte_ptr1->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(width, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(-1.0, 0.0, 0.0);
			TRectangle* left_wall_ptr = new TRectangle(p0, a, b, normal);
			left_wall_ptr->set_material(matte_ptr1);
			add_object(left_wall_ptr);
	
	
			// right wall
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(0.0);
			matte_ptr2->set_kd(0.6); 
			matte_ptr2->set_cd(0.37, 0.59, 0.2);	 // green   from Photoshop
			matte_ptr2->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(0.0, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(1.0, 0.0, 0.0);
			TRectangle* right_wall_ptr = new TRectangle(p0, a, b, normal);
			right_wall_ptr->set_material(matte_ptr2);
			add_object(right_wall_ptr);
	
	
			// back wall
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.0);
			matte_ptr3->set_kd(0.6); 
			matte_ptr3->set_cd(1.0);	 // white
			matte_ptr3->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(0.0, 0.0, depth);
			a = Vector3D(width, 0.0, 0.0);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(0.0, 0.0, -1.0);
			TRectangle* back_wall_ptr = new TRectangle(p0, a, b, normal);
			back_wall_ptr->set_material(matte_ptr3);
			add_object(back_wall_ptr);
	
	
			// floor
	
			p0 = Point3D(0.0, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(width, 0.0, 0.0);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* floor_ptr = new TRectangle(p0, a, b, normal);
			floor_ptr->set_material(matte_ptr3);
			add_object(floor_ptr);
	
	
			// ceiling
	
			p0 = Point3D(0.0, height, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(width, 0.0, 0.0);
			normal = Normal(0.0, -1.0, 0.0);
			TRectangle* ceiling_ptr = new TRectangle(p0, a, b, normal);
			ceiling_ptr->set_material(matte_ptr3);
			add_object(ceiling_ptr);

	
			// the two boxes defined as 5 rectangles each
	
			// short box
	
			// top
	
			p0 = Point3D(13.0, 16.5, 6.5);
			a = Vector3D(-4.8, 0.0, 16.0);
			b = Vector3D(16.0, 0.0, 4.9);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* short_top_ptr = new TRectangle(p0, a, b, normal);
			short_top_ptr->set_material(matte_ptr3);
			add_object(short_top_ptr);
	
	
			// side 1
	
			p0 = Point3D(13.0, 0.0, 6.5);
			a = Vector3D(-4.8, 0.0, 16.0);
			b = Vector3D(0.0, 16.5, 0.0);
			TRectangle* short_side_ptr1 = new TRectangle(p0, a, b);
			short_side_ptr1->set_material(matte_ptr3);
			add_object(short_side_ptr1);
	
	
			// side 2
	
			p0 = Point3D(8.2, 0.0, 22.5);
			a = Vector3D(15.8, 0.0, 4.7);
			TRectangle* short_side_ptr2 = new TRectangle(p0, a, b);
			short_side_ptr2->set_material(matte_ptr3);
			add_object(short_side_ptr2);
	
	
			// side 3
	
			p0 = Point3D(24.2, 0.0, 27.4);
			a = Vector3D(4.8, 0.0, -16.0);
			TRectangle* short_side_ptr3 = new TRectangle(p0, a, b);
			short_side_ptr3->set_material(matte_ptr3);
			add_object(short_side_ptr3);
	
	
			// side 4
	
			p0 = Point3D(29.0, 0.0, 11.4);
			a = Vector3D(-16.0, 0.0, -4.9);
			TRectangle* short_side_ptr4 = new TRectangle(p0, a, b);
			short_side_ptr4->set_material(matte_ptr3);
			add_object(short_side_ptr4);
	
	
	
	
			// tall box
	
			// top
	
			p0 = Point3D(42.3, 33.0, 24.7);
			a = Vector3D(-15.8, 0.0, 4.9);
			b = Vector3D(4.9, 0.0, 15.9);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* tall_top_ptr = new TRectangle(p0, a, b, normal);
			tall_top_ptr->set_material(matte_ptr3);
			add_object(tall_top_ptr);
	
	
			// side 1
	
			p0 = Point3D(42.3, 0.0, 24.7);
			a = Vector3D(-15.8, 0.0, 4.9);
			b = Vector3D(0.0, 33.0, 0.0);
			TRectangle* tall_side_ptr1 = new TRectangle(p0, a, b);
			tall_side_ptr1->set_material(matte_ptr3);
			add_object(tall_side_ptr1);
	
	
			// side 2
	
			p0 = Point3D(26.5, 0.0, 29.6);
			a = Vector3D(4.9, 0.0, 15.9);
			TRectangle* tall_side_ptr2 = new TRectangle(p0, a, b);
			tall_side_ptr2->set_material(matte_ptr3);
			add_object(tall_side_ptr2);
	
	
			// side 3
	
			p0 = Point3D(31.4, 0.0, 45.5);
			a = Vector3D(15.8, 0.0, -4.9);
			TRectangle* tall_side_ptr3 = new TRectangle(p0, a, b);
			tall_side_ptr3->set_material(matte_ptr3);
			add_object(tall_side_ptr3);
	
	
			// side 4
	
			p0 = Point3D(47.2, 0.0, 40.6);
			a = Vector3D(-4.9, 0.0, -15.9);
			TRectangle* tall_side_ptr4 = new TRectangle(p0, a, b);
			tall_side_ptr4->set_material(matte_ptr3);
			add_object(tall_side_ptr4);
			break;
		}
	case 262:
		{
			//26.07b
		//	int num_samples = 1;		// for Figure 26.7(a)
			int num_samples = 100;		// for Figure 26.7(b)
		//	int num_samples = 1024;		// for Figure 26.7(c)
		//	int num_samples = 10000;	// for Figure 26.7(d)
		
			vp.set_hres(300);	  		
			vp.set_vres(300);
			vp.set_samples(num_samples); 
			vp.set_max_depth(10);
	
			background_color = black;
	
			tracer_ptr = new PathTrace(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(27.6, 27.4, -80.0);
			pinhole_ptr->set_lookat(27.6, 27.4, 0.0);
			pinhole_ptr->set_view_distance(400);      
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			Point3D p0;
			Vector3D a, b;
			Normal normal;
	
			// box dimensions
	
			double width 	= 55.28;   	// x direction
			double height 	= 54.88;  	// y direction
			double depth 	= 55.92;	// z direction
	
	
			// the ceiling light - doesn't need samples
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(1.0, 0.73, 0.4);   
			emissive_ptr->scale_radiance(100);
	
			p0 = Point3D(21.3, height - 0.001, 22.7);
			a = Vector3D(0.0, 0.0, 10.5);
			b = Vector3D(13.0, 0.0, 0.0);
			normal = Normal(0.0, -1.0, 0.0);
			TRectangle* light_ptr = new TRectangle(p0, a, b, normal);
			light_ptr->set_material(emissive_ptr);
			add_object(light_ptr);
	
		
			// left wall
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.0);
			matte_ptr1->set_kd(0.6); 
			matte_ptr1->set_cd(0.57, 0.025, 0.025);	 // red
			matte_ptr1->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(width, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(-1.0, 0.0, 0.0);
			TRectangle* left_wall_ptr = new TRectangle(p0, a, b, normal);
			left_wall_ptr->set_material(matte_ptr1);
			add_object(left_wall_ptr);
	
	
			// right wall
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(0.0);
			matte_ptr2->set_kd(0.6); 
			matte_ptr2->set_cd(0.37, 0.59, 0.2);	 // green   from Photoshop
			matte_ptr2->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(0.0, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(1.0, 0.0, 0.0);
			TRectangle* right_wall_ptr = new TRectangle(p0, a, b, normal);
			right_wall_ptr->set_material(matte_ptr2);
			add_object(right_wall_ptr);
	
	
			// back wall
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.0);
			matte_ptr3->set_kd(0.6); 
			matte_ptr3->set_cd(1.0);	 // white
			matte_ptr3->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(0.0, 0.0, depth);
			a = Vector3D(width, 0.0, 0.0);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(0.0, 0.0, -1.0);
			TRectangle* back_wall_ptr = new TRectangle(p0, a, b, normal);
			back_wall_ptr->set_material(matte_ptr3);
			add_object(back_wall_ptr);
	
	
			// floor
	
			p0 = Point3D(0.0, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(width, 0.0, 0.0);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* floor_ptr = new TRectangle(p0, a, b, normal);
			floor_ptr->set_material(matte_ptr3);
			add_object(floor_ptr);
	
	
			// ceiling
	
			p0 = Point3D(0.0, height, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(width, 0.0, 0.0);
			normal = Normal(0.0, -1.0, 0.0);
			TRectangle* ceiling_ptr = new TRectangle(p0, a, b, normal);
			ceiling_ptr->set_material(matte_ptr3);
			add_object(ceiling_ptr);

	
			// the two boxes defined as 5 rectangles each
	
			// short box
	
			// top
	
			p0 = Point3D(13.0, 16.5, 6.5);
			a = Vector3D(-4.8, 0.0, 16.0);
			b = Vector3D(16.0, 0.0, 4.9);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* short_top_ptr = new TRectangle(p0, a, b, normal);
			short_top_ptr->set_material(matte_ptr3);
			add_object(short_top_ptr);
	
	
			// side 1
	
			p0 = Point3D(13.0, 0.0, 6.5);
			a = Vector3D(-4.8, 0.0, 16.0);
			b = Vector3D(0.0, 16.5, 0.0);
			TRectangle* short_side_ptr1 = new TRectangle(p0, a, b);
			short_side_ptr1->set_material(matte_ptr3);
			add_object(short_side_ptr1);
	
	
			// side 2
	
			p0 = Point3D(8.2, 0.0, 22.5);
			a = Vector3D(15.8, 0.0, 4.7);
			TRectangle* short_side_ptr2 = new TRectangle(p0, a, b);
			short_side_ptr2->set_material(matte_ptr3);
			add_object(short_side_ptr2);
	
	
			// side 3
	
			p0 = Point3D(24.2, 0.0, 27.4);
			a = Vector3D(4.8, 0.0, -16.0);
			TRectangle* short_side_ptr3 = new TRectangle(p0, a, b);
			short_side_ptr3->set_material(matte_ptr3);
			add_object(short_side_ptr3);
	
	
			// side 4
	
			p0 = Point3D(29.0, 0.0, 11.4);
			a = Vector3D(-16.0, 0.0, -4.9);
			TRectangle* short_side_ptr4 = new TRectangle(p0, a, b);
			short_side_ptr4->set_material(matte_ptr3);
			add_object(short_side_ptr4);
	
	
	
	
			// tall box
	
			// top
	
			p0 = Point3D(42.3, 33.0, 24.7);
			a = Vector3D(-15.8, 0.0, 4.9);
			b = Vector3D(4.9, 0.0, 15.9);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* tall_top_ptr = new TRectangle(p0, a, b, normal);
			tall_top_ptr->set_material(matte_ptr3);
			add_object(tall_top_ptr);
	
	
			// side 1
	
			p0 = Point3D(42.3, 0.0, 24.7);
			a = Vector3D(-15.8, 0.0, 4.9);
			b = Vector3D(0.0, 33.0, 0.0);
			TRectangle* tall_side_ptr1 = new TRectangle(p0, a, b);
			tall_side_ptr1->set_material(matte_ptr3);
			add_object(tall_side_ptr1);
	
	
			// side 2
	
			p0 = Point3D(26.5, 0.0, 29.6);
			a = Vector3D(4.9, 0.0, 15.9);
			TRectangle* tall_side_ptr2 = new TRectangle(p0, a, b);
			tall_side_ptr2->set_material(matte_ptr3);
			add_object(tall_side_ptr2);
	
	
			// side 3
	
			p0 = Point3D(31.4, 0.0, 45.5);
			a = Vector3D(15.8, 0.0, -4.9);
			TRectangle* tall_side_ptr3 = new TRectangle(p0, a, b);
			tall_side_ptr3->set_material(matte_ptr3);
			add_object(tall_side_ptr3);
	
	
			// side 4
	
			p0 = Point3D(47.2, 0.0, 40.6);
			a = Vector3D(-4.9, 0.0, -15.9);
			TRectangle* tall_side_ptr4 = new TRectangle(p0, a, b);
			tall_side_ptr4->set_material(matte_ptr3);
			add_object(tall_side_ptr4);
			break;
		}
	case 263:
		{
			//26.07a
		//	int num_samples = 1;		// for Figure 26.7(a)
		//	int num_samples = 100;		// for Figure 26.7(b)
			int num_samples = 1024;		// for Figure 26.7(c)
		//	int num_samples = 10000;	// for Figure 26.7(d)
		
			vp.set_hres(300);	  		
			vp.set_vres(300);
			vp.set_samples(num_samples); 
			vp.set_max_depth(10);
	
			background_color = black;
	
			tracer_ptr = new PathTrace(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(27.6, 27.4, -80.0);
			pinhole_ptr->set_lookat(27.6, 27.4, 0.0);
			pinhole_ptr->set_view_distance(400);      
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			Point3D p0;
			Vector3D a, b;
			Normal normal;
	
			// box dimensions
	
			double width 	= 55.28;   	// x direction
			double height 	= 54.88;  	// y direction
			double depth 	= 55.92;	// z direction
	
	
			// the ceiling light - doesn't need samples
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(1.0, 0.73, 0.4);   
			emissive_ptr->scale_radiance(100);
	
			p0 = Point3D(21.3, height - 0.001, 22.7);
			a = Vector3D(0.0, 0.0, 10.5);
			b = Vector3D(13.0, 0.0, 0.0);
			normal = Normal(0.0, -1.0, 0.0);
			TRectangle* light_ptr = new TRectangle(p0, a, b, normal);
			light_ptr->set_material(emissive_ptr);
			add_object(light_ptr);
	
		
			// left wall
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.0);
			matte_ptr1->set_kd(0.6); 
			matte_ptr1->set_cd(0.57, 0.025, 0.025);	 // red
			matte_ptr1->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(width, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(-1.0, 0.0, 0.0);
			TRectangle* left_wall_ptr = new TRectangle(p0, a, b, normal);
			left_wall_ptr->set_material(matte_ptr1);
			add_object(left_wall_ptr);
	
	
			// right wall
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(0.0);
			matte_ptr2->set_kd(0.6); 
			matte_ptr2->set_cd(0.37, 0.59, 0.2);	 // green   from Photoshop
			matte_ptr2->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(0.0, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(1.0, 0.0, 0.0);
			TRectangle* right_wall_ptr = new TRectangle(p0, a, b, normal);
			right_wall_ptr->set_material(matte_ptr2);
			add_object(right_wall_ptr);
	
	
			// back wall
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.0);
			matte_ptr3->set_kd(0.6); 
			matte_ptr3->set_cd(1.0);	 // white
			matte_ptr3->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(0.0, 0.0, depth);
			a = Vector3D(width, 0.0, 0.0);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(0.0, 0.0, -1.0);
			TRectangle* back_wall_ptr = new TRectangle(p0, a, b, normal);
			back_wall_ptr->set_material(matte_ptr3);
			add_object(back_wall_ptr);
	
	
			// floor
	
			p0 = Point3D(0.0, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(width, 0.0, 0.0);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* floor_ptr = new TRectangle(p0, a, b, normal);
			floor_ptr->set_material(matte_ptr3);
			add_object(floor_ptr);
	
	
			// ceiling
	
			p0 = Point3D(0.0, height, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(width, 0.0, 0.0);
			normal = Normal(0.0, -1.0, 0.0);
			TRectangle* ceiling_ptr = new TRectangle(p0, a, b, normal);
			ceiling_ptr->set_material(matte_ptr3);
			add_object(ceiling_ptr);

	
			// the two boxes defined as 5 rectangles each
	
			// short box
	
			// top
	
			p0 = Point3D(13.0, 16.5, 6.5);
			a = Vector3D(-4.8, 0.0, 16.0);
			b = Vector3D(16.0, 0.0, 4.9);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* short_top_ptr = new TRectangle(p0, a, b, normal);
			short_top_ptr->set_material(matte_ptr3);
			add_object(short_top_ptr);
	
	
			// side 1
	
			p0 = Point3D(13.0, 0.0, 6.5);
			a = Vector3D(-4.8, 0.0, 16.0);
			b = Vector3D(0.0, 16.5, 0.0);
			TRectangle* short_side_ptr1 = new TRectangle(p0, a, b);
			short_side_ptr1->set_material(matte_ptr3);
			add_object(short_side_ptr1);
	
	
			// side 2
	
			p0 = Point3D(8.2, 0.0, 22.5);
			a = Vector3D(15.8, 0.0, 4.7);
			TRectangle* short_side_ptr2 = new TRectangle(p0, a, b);
			short_side_ptr2->set_material(matte_ptr3);
			add_object(short_side_ptr2);
	
	
			// side 3
	
			p0 = Point3D(24.2, 0.0, 27.4);
			a = Vector3D(4.8, 0.0, -16.0);
			TRectangle* short_side_ptr3 = new TRectangle(p0, a, b);
			short_side_ptr3->set_material(matte_ptr3);
			add_object(short_side_ptr3);
	
	
			// side 4
	
			p0 = Point3D(29.0, 0.0, 11.4);
			a = Vector3D(-16.0, 0.0, -4.9);
			TRectangle* short_side_ptr4 = new TRectangle(p0, a, b);
			short_side_ptr4->set_material(matte_ptr3);
			add_object(short_side_ptr4);
	
	
	
	
			// tall box
	
			// top
	
			p0 = Point3D(42.3, 33.0, 24.7);
			a = Vector3D(-15.8, 0.0, 4.9);
			b = Vector3D(4.9, 0.0, 15.9);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* tall_top_ptr = new TRectangle(p0, a, b, normal);
			tall_top_ptr->set_material(matte_ptr3);
			add_object(tall_top_ptr);
	
	
			// side 1
	
			p0 = Point3D(42.3, 0.0, 24.7);
			a = Vector3D(-15.8, 0.0, 4.9);
			b = Vector3D(0.0, 33.0, 0.0);
			TRectangle* tall_side_ptr1 = new TRectangle(p0, a, b);
			tall_side_ptr1->set_material(matte_ptr3);
			add_object(tall_side_ptr1);
	
	
			// side 2
	
			p0 = Point3D(26.5, 0.0, 29.6);
			a = Vector3D(4.9, 0.0, 15.9);
			TRectangle* tall_side_ptr2 = new TRectangle(p0, a, b);
			tall_side_ptr2->set_material(matte_ptr3);
			add_object(tall_side_ptr2);
	
	
			// side 3
	
			p0 = Point3D(31.4, 0.0, 45.5);
			a = Vector3D(15.8, 0.0, -4.9);
			TRectangle* tall_side_ptr3 = new TRectangle(p0, a, b);
			tall_side_ptr3->set_material(matte_ptr3);
			add_object(tall_side_ptr3);
	
	
			// side 4
	
			p0 = Point3D(47.2, 0.0, 40.6);
			a = Vector3D(-4.9, 0.0, -15.9);
			TRectangle* tall_side_ptr4 = new TRectangle(p0, a, b);
			tall_side_ptr4->set_material(matte_ptr3);
			add_object(tall_side_ptr4);
			break;
		}
	case 264:
		{
			//26.07d
		//	int num_samples = 1;		// for Figure 26.7(a)
		//	int num_samples = 100;		// for Figure 26.7(b)
		//	int num_samples = 1024;		// for Figure 26.7(c)
			int num_samples = 10000;	// for Figure 26.7(d)
		
			vp.set_hres(300);	  		
			vp.set_vres(300);
			vp.set_samples(num_samples); 
			vp.set_max_depth(10);
	
			background_color = black;
	
			tracer_ptr = new PathTrace(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(27.6, 27.4, -80.0);
			pinhole_ptr->set_lookat(27.6, 27.4, 0.0);
			pinhole_ptr->set_view_distance(400);      
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			Point3D p0;
			Vector3D a, b;
			Normal normal;
	
			// box dimensions
	
			double width 	= 55.28;   	// x direction
			double height 	= 54.88;  	// y direction
			double depth 	= 55.92;	// z direction
	
	
			// the ceiling light - doesn't need samples
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(1.0, 0.73, 0.4);   
			emissive_ptr->scale_radiance(100);
	
			p0 = Point3D(21.3, height - 0.001, 22.7);
			a = Vector3D(0.0, 0.0, 10.5);
			b = Vector3D(13.0, 0.0, 0.0);
			normal = Normal(0.0, -1.0, 0.0);
			TRectangle* light_ptr = new TRectangle(p0, a, b, normal);
			light_ptr->set_material(emissive_ptr);
			add_object(light_ptr);
	
		
			// left wall
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.0);
			matte_ptr1->set_kd(0.6); 
			matte_ptr1->set_cd(0.57, 0.025, 0.025);	 // red
			matte_ptr1->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(width, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(-1.0, 0.0, 0.0);
			TRectangle* left_wall_ptr = new TRectangle(p0, a, b, normal);
			left_wall_ptr->set_material(matte_ptr1);
			add_object(left_wall_ptr);
	
	
			// right wall
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(0.0);
			matte_ptr2->set_kd(0.6); 
			matte_ptr2->set_cd(0.37, 0.59, 0.2);	 // green   from Photoshop
			matte_ptr2->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(0.0, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(1.0, 0.0, 0.0);
			TRectangle* right_wall_ptr = new TRectangle(p0, a, b, normal);
			right_wall_ptr->set_material(matte_ptr2);
			add_object(right_wall_ptr);
	
	
			// back wall
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.0);
			matte_ptr3->set_kd(0.6); 
			matte_ptr3->set_cd(1.0);	 // white
			matte_ptr3->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(0.0, 0.0, depth);
			a = Vector3D(width, 0.0, 0.0);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(0.0, 0.0, -1.0);
			TRectangle* back_wall_ptr = new TRectangle(p0, a, b, normal);
			back_wall_ptr->set_material(matte_ptr3);
			add_object(back_wall_ptr);
	
	
			// floor
	
			p0 = Point3D(0.0, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(width, 0.0, 0.0);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* floor_ptr = new TRectangle(p0, a, b, normal);
			floor_ptr->set_material(matte_ptr3);
			add_object(floor_ptr);
	
	
			// ceiling
	
			p0 = Point3D(0.0, height, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(width, 0.0, 0.0);
			normal = Normal(0.0, -1.0, 0.0);
			TRectangle* ceiling_ptr = new TRectangle(p0, a, b, normal);
			ceiling_ptr->set_material(matte_ptr3);
			add_object(ceiling_ptr);

	
			// the two boxes defined as 5 rectangles each
	
			// short box
	
			// top
	
			p0 = Point3D(13.0, 16.5, 6.5);
			a = Vector3D(-4.8, 0.0, 16.0);
			b = Vector3D(16.0, 0.0, 4.9);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* short_top_ptr = new TRectangle(p0, a, b, normal);
			short_top_ptr->set_material(matte_ptr3);
			add_object(short_top_ptr);
	
	
			// side 1
	
			p0 = Point3D(13.0, 0.0, 6.5);
			a = Vector3D(-4.8, 0.0, 16.0);
			b = Vector3D(0.0, 16.5, 0.0);
			TRectangle* short_side_ptr1 = new TRectangle(p0, a, b);
			short_side_ptr1->set_material(matte_ptr3);
			add_object(short_side_ptr1);
	
	
			// side 2
	
			p0 = Point3D(8.2, 0.0, 22.5);
			a = Vector3D(15.8, 0.0, 4.7);
			TRectangle* short_side_ptr2 = new TRectangle(p0, a, b);
			short_side_ptr2->set_material(matte_ptr3);
			add_object(short_side_ptr2);
	
	
			// side 3
	
			p0 = Point3D(24.2, 0.0, 27.4);
			a = Vector3D(4.8, 0.0, -16.0);
			TRectangle* short_side_ptr3 = new TRectangle(p0, a, b);
			short_side_ptr3->set_material(matte_ptr3);
			add_object(short_side_ptr3);
	
	
			// side 4
	
			p0 = Point3D(29.0, 0.0, 11.4);
			a = Vector3D(-16.0, 0.0, -4.9);
			TRectangle* short_side_ptr4 = new TRectangle(p0, a, b);
			short_side_ptr4->set_material(matte_ptr3);
			add_object(short_side_ptr4);
	
	
	
	
			// tall box
	
			// top
	
			p0 = Point3D(42.3, 33.0, 24.7);
			a = Vector3D(-15.8, 0.0, 4.9);
			b = Vector3D(4.9, 0.0, 15.9);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* tall_top_ptr = new TRectangle(p0, a, b, normal);
			tall_top_ptr->set_material(matte_ptr3);
			add_object(tall_top_ptr);
	
	
			// side 1
	
			p0 = Point3D(42.3, 0.0, 24.7);
			a = Vector3D(-15.8, 0.0, 4.9);
			b = Vector3D(0.0, 33.0, 0.0);
			TRectangle* tall_side_ptr1 = new TRectangle(p0, a, b);
			tall_side_ptr1->set_material(matte_ptr3);
			add_object(tall_side_ptr1);
	
	
			// side 2
	
			p0 = Point3D(26.5, 0.0, 29.6);
			a = Vector3D(4.9, 0.0, 15.9);
			TRectangle* tall_side_ptr2 = new TRectangle(p0, a, b);
			tall_side_ptr2->set_material(matte_ptr3);
			add_object(tall_side_ptr2);
	
	
			// side 3
	
			p0 = Point3D(31.4, 0.0, 45.5);
			a = Vector3D(15.8, 0.0, -4.9);
			TRectangle* tall_side_ptr3 = new TRectangle(p0, a, b);
			tall_side_ptr3->set_material(matte_ptr3);
			add_object(tall_side_ptr3);
	
	
			// side 4
	
			p0 = Point3D(47.2, 0.0, 40.6);
			a = Vector3D(-4.9, 0.0, -15.9);
			TRectangle* tall_side_ptr4 = new TRectangle(p0, a, b);
			tall_side_ptr4->set_material(matte_ptr3);
			add_object(tall_side_ptr4);
			break;
		}
	case 265:
		{
			//26.08
			int num_samples = 5041;
	
			vp.set_hres(600);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples); 
			vp.set_max_depth(5);
	
			tracer_ptr = new PathTrace(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(5, 10, 20);			
			pinhole_ptr->set_lookat(-1, 1, 0);
			pinhole_ptr->set_view_distance(500);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// emissive sphere
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(20.0); 
			emissive_ptr->set_ce(0.75, 1, 0.75);      // light green
		
			Sphere* sphere_ptr = new Sphere(Point3D(-2, 7, 6), 1); 
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_sampler(new MultiJittered(num_samples));
			add_object(sphere_ptr);
	
	
			// reflective rectangle
	
			Reflective* reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.0); 
			reflective_ptr->set_ks(0.0);    
			reflective_ptr->set_exp(1.0);
			reflective_ptr->set_kr(0.95); 
			reflective_ptr->set_cr(1.0, 0.5, 0.25);  // orange 	
	
			Point3D p0;
			Vector3D a, b;
			Normal normal;
	
			p0 = Point3D(-4.0, -1.0, 0.0);
			a = Vector3D(8.0, 0.0, 0.0);
			b = Vector3D(0.0, 20.0, 0.0);
			normal = Normal(0.0, 0.0, 1.0);
			TRectangle* mirror_ptr = new TRectangle(p0, a, b, normal);
			mirror_ptr->set_material(reflective_ptr);
			add_object(mirror_ptr);

			// plane

			Matte* matte_ptr = new Matte;			
			matte_ptr->set_ka(0);		
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(white);
			matte_ptr->set_sampler(new MultiJittered(num_samples));
	
			Plane* plane_ptr = new Plane(Point3D(0, -1.0, 0), Normal(0, 1, 0)); 	
			plane_ptr->set_material(matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 266:
		{
			//26.09a
			int num_samples = 5041;
	
			vp.set_hres(600);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples); 
			vp.set_max_depth(2);
		
			tracer_ptr = new PathTrace(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(5, 15, 20);			
			pinhole_ptr->set_lookat(-1, 1, 0);
			pinhole_ptr->set_view_distance(1500);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
			
	
			// emissive sphere
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(0.75, 1, 0.75);
			emissive_ptr->scale_radiance(30.0);  
		
			Sphere* sphere_ptr = new Sphere(Point3D(-2, 7, 6), 1); 
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_sampler(new MultiJittered(num_samples));
			add_object(sphere_ptr);
		
	
			// reflective open half cylinder
	
			Reflective* reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.4); 
			reflective_ptr->set_ks(0.0);      
			reflective_ptr->set_exp(1.0);
			reflective_ptr->set_kr(0.95); 
			reflective_ptr->set_cr(1.0, 0.5, 0.25);  // orange 
	
			double y0 		= -1.0;
			double y1 		= 3.0;
			double radius 	= 3.0;
			double phi_min 	= 90.0;
			double phi_max 	= 270.0;
	
			ConcavePartCylinder* cylinder_ptr = new ConcavePartCylinder(y0, y1, radius, phi_min, phi_max); 
			cylinder_ptr->set_material(reflective_ptr);
			add_object(cylinder_ptr);
	
			// plane

			Matte* matte_ptr = new Matte;			
			matte_ptr->set_ka(0.0);		
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(1);
			matte_ptr->set_sampler(new MultiJittered(num_samples));
	
			Plane* plane_ptr = new Plane(Point3D(0, -1.0, 0), Normal(0, 1, 0)); 	
			plane_ptr->set_material(matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 267:
		{
			//26.09b
			int num_samples = 5041;
	
			vp.set_hres(600);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples); 
			vp.set_max_depth(5);
		
			tracer_ptr = new PathTrace(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(5, 15, 20);			
			pinhole_ptr->set_lookat(-1, 1, 0);
			pinhole_ptr->set_view_distance(1500);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
			
	
			// emissive sphere
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(0.75, 1, 0.75);
			emissive_ptr->scale_radiance(30.0);   
		
			Sphere* sphere_ptr = new Sphere(Point3D(-2, 7, 6), 1); 
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_sampler(new MultiJittered(num_samples));
			add_object(sphere_ptr);
		
	
			// reflective open half cylinder
	
			Reflective* reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.4); 
			reflective_ptr->set_ks(0.0);      
			reflective_ptr->set_exp(1.0);
			reflective_ptr->set_kr(0.95); 
			reflective_ptr->set_cr(1.0, 0.5, 0.25);  // orange 
	
			double y0 		= -1.0;
			double y1 		= 3.0;
			double radius 	= 3.0;
			double phi_min 	= 90.0;
			double phi_max 	= 270.0;
	
			ConcavePartCylinder* cylinder_ptr = new ConcavePartCylinder(y0, y1, radius, phi_min, phi_max); 
			cylinder_ptr->set_material(reflective_ptr);
			add_object(cylinder_ptr);	
	
	
			// plane

			Matte* matte_ptr = new Matte;			
			matte_ptr->set_ka(0.0);		
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(1);
			matte_ptr->set_sampler(new MultiJittered(num_samples));
	
			Plane* plane_ptr = new Plane(Point3D(0, -1.0, 0), Normal(0, 1, 0)); 	
			plane_ptr->set_material(matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 268:
		{
			//26.09c
			int num_samples = 5041;
	
			vp.set_hres(600);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples); 
			vp.set_max_depth(5);
		
			tracer_ptr = new PathTrace(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 100, 2);		
			pinhole_ptr->set_lookat(0, 0, 2);
			pinhole_ptr->set_view_distance(5000);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);

	
			// emissive sphere
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(0.75, 1, 0.75);
			emissive_ptr->scale_radiance(30.0);   
		
			Sphere* sphere_ptr = new Sphere(Point3D(-2, 7, 6), 1); 
			sphere_ptr->set_material(emissive_ptr);
			sphere_ptr->set_sampler(new MultiJittered(num_samples));
			add_object(sphere_ptr);
		
	
			// reflective open half cylinder
	
			Reflective* reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.0); 
			reflective_ptr->set_kd(0.4); 
			reflective_ptr->set_ks(0.0);      
			reflective_ptr->set_exp(1.0);
			reflective_ptr->set_kr(0.95); 
			reflective_ptr->set_cr(1.0, 0.5, 0.25);  // orange 
	
			double y0 		= -1.0;
			double y1 		= 3.0;
			double radius 	= 3.0;
			double phi_min 	= 90.0;
			double phi_max 	= 270.0;
	
			ConcavePartCylinder* cylinder_ptr = new ConcavePartCylinder(y0, y1, radius, phi_min, phi_max); 
			cylinder_ptr->set_material(reflective_ptr);
			add_object(cylinder_ptr);	
	
	
			// plane

			Matte* matte_ptr = new Matte;			
			matte_ptr->set_ka(0.0);		
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(1);
			matte_ptr->set_sampler(new MultiJittered(num_samples));
	
			Plane* plane_ptr = new Plane(Point3D(0, -1.0, 0), Normal(0, 1, 0)); 	
			plane_ptr->set_material(matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 269:
		{
			//26.10a
			int num_samples = 100;
		
			vp.set_hres(300);	  		
			vp.set_vres(300);
			vp.set_samples(num_samples); 
			vp.set_max_depth(1);
	
			background_color = black;
	
			tracer_ptr = new PathTrace(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(27.6, 27.4, -80.0);
			pinhole_ptr->set_lookat(27.6, 27.4, 0.0);
			pinhole_ptr->set_view_distance(400);      
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			Point3D p0;
			Vector3D a, b;
			Normal normal;
	
			// box dimensions
	
			double width 	= 55.28;   	// x direction
			double height 	= 54.88;  	// y direction
			double depth 	= 55.92;	// z direction
	
	
			// the ceiling light - doesn't need samples
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(1.0, 0.73, 0.4);   
			emissive_ptr->scale_radiance(100);
	
			p0 = Point3D(21.3, height - 0.001, 22.7);
			a = Vector3D(0.0, 0.0, 10.5);
			b = Vector3D(13.0, 0.0, 0.0);
			normal = Normal(0.0, -1.0, 0.0);
			TRectangle* light_ptr = new TRectangle(p0, a, b, normal);
			light_ptr->set_material(emissive_ptr);
			add_object(light_ptr);
	
		
			// left wall
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.0);
			matte_ptr1->set_kd(0.6); 
			matte_ptr1->set_cd(0.57, 0.025, 0.025);	 // red
			matte_ptr1->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(width, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(-1.0, 0.0, 0.0);
			TRectangle* left_wall_ptr = new TRectangle(p0, a, b, normal);
			left_wall_ptr->set_material(matte_ptr1);
			add_object(left_wall_ptr);
	
	
			// right wall
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(0.0);
			matte_ptr2->set_kd(0.6); 
			matte_ptr2->set_cd(0.37, 0.59, 0.2);	 // green   from Photoshop
			matte_ptr2->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(0.0, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(1.0, 0.0, 0.0);
			TRectangle* right_wall_ptr = new TRectangle(p0, a, b, normal);
			right_wall_ptr->set_material(matte_ptr2);
			add_object(right_wall_ptr);
	
	
			// back wall
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.0);
			matte_ptr3->set_kd(0.6); 
			matte_ptr3->set_cd(white);	
			matte_ptr3->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(0.0, 0.0, depth);
			a = Vector3D(width, 0.0, 0.0);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(0.0, 0.0, -1.0);
			TRectangle* back_wall_ptr = new TRectangle(p0, a, b, normal);
			back_wall_ptr->set_material(matte_ptr3);
			add_object(back_wall_ptr);
	
	
			// floor
	
			p0 = Point3D(0.0, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(width, 0.0, 0.0);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* floor_ptr = new TRectangle(p0, a, b, normal);
			floor_ptr->set_material(matte_ptr3);
			add_object(floor_ptr);
	
	
			// ceiling
	
			p0 = Point3D(0.0, height, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(width, 0.0, 0.0);
			normal = Normal(0.0, -1.0, 0.0);
			TRectangle* ceiling_ptr = new TRectangle(p0, a, b, normal);
			ceiling_ptr->set_material(matte_ptr3);
			add_object(ceiling_ptr);

	
			// the two boxes defined as 5 rectangles each
	
			// short box
	
			// top
	
			p0 = Point3D(13.0, 16.5, 6.5);
			a = Vector3D(-4.8, 0.0, 16.0);
			b = Vector3D(16.0, 0.0, 4.9);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* short_top_ptr = new TRectangle(p0, a, b, normal);
			short_top_ptr->set_material(matte_ptr3);
			add_object(short_top_ptr);
	
	
			// side 1
	
			p0 = Point3D(13.0, 0.0, 6.5);
			a = Vector3D(-4.8, 0.0, 16.0);
			b = Vector3D(0.0, 16.5, 0.0);
			TRectangle* short_side_ptr1 = new TRectangle(p0, a, b);
			short_side_ptr1->set_material(matte_ptr3);
			add_object(short_side_ptr1);
	
	
			// side 2
	
			p0 = Point3D(8.2, 0.0, 22.5);
			a = Vector3D(15.8, 0.0, 4.7);
			TRectangle* short_side_ptr2 = new TRectangle(p0, a, b);
			short_side_ptr2->set_material(matte_ptr3);
			add_object(short_side_ptr2);
	
	
			// side 3
	
			p0 = Point3D(24.2, 0.0, 27.4);
			a = Vector3D(4.8, 0.0, -16.0);
			TRectangle* short_side_ptr3 = new TRectangle(p0, a, b);
			short_side_ptr3->set_material(matte_ptr3);
			add_object(short_side_ptr3);
	
	
			// side 4
	
			p0 = Point3D(29.0, 0.0, 11.4);
			a = Vector3D(-16.0, 0.0, -4.9);
			TRectangle* short_side_ptr4 = new TRectangle(p0, a, b);
			short_side_ptr4->set_material(matte_ptr3);
			add_object(short_side_ptr4);
	
	
	
			// tall box
	
			// top
	
			p0 = Point3D(42.3, 33.0, 24.7);
			a = Vector3D(-15.8, 0.0, 4.9);
			b = Vector3D(4.9, 0.0, 15.9);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* tall_top_ptr = new TRectangle(p0, a, b, normal);
			tall_top_ptr->set_material(matte_ptr3);
			add_object(tall_top_ptr);
	
	
			// side 1
	
			p0 = Point3D(42.3, 0.0, 24.7);
			a = Vector3D(-15.8, 0.0, 4.9);
			b = Vector3D(0.0, 33.0, 0.0);
			TRectangle* tall_side_ptr1 = new TRectangle(p0, a, b);
			tall_side_ptr1->set_material(matte_ptr3);
			add_object(tall_side_ptr1);
	
	
			// side 2
	
			p0 = Point3D(26.5, 0.0, 29.6);
			a = Vector3D(4.9, 0.0, 15.9);
			TRectangle* tall_side_ptr2 = new TRectangle(p0, a, b);
			tall_side_ptr2->set_material(matte_ptr3);
			add_object(tall_side_ptr2);
	
	
			// side 3
	
			p0 = Point3D(31.4, 0.0, 45.5);
			a = Vector3D(15.8, 0.0, -4.9);
			TRectangle* tall_side_ptr3 = new TRectangle(p0, a, b);
			tall_side_ptr3->set_material(matte_ptr3);
			add_object(tall_side_ptr3);
	
	
			// side 4
	
			p0 = Point3D(47.2, 0.0, 40.6);
			a = Vector3D(-4.9, 0.0, -15.9);
			TRectangle* tall_side_ptr4 = new TRectangle(p0, a, b);
			tall_side_ptr4->set_material(matte_ptr3);
			add_object(tall_side_ptr4);
			break;
		}
	case 270:
		{
			//26.10b
			int num_samples = 1;
		
			vp.set_hres(300);	  		
			vp.set_vres(300);
			vp.set_samples(num_samples); 
			vp.set_max_depth(0);
	
			background_color = black;
	
			tracer_ptr = new AreaLighting(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.0);
			set_ambient_light(ambient_ptr);
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(27.6, 27.4, -80.0);
			pinhole_ptr->set_lookat(27.6, 27.4, 0.0);
			pinhole_ptr->set_view_distance(400);      
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			Point3D p0;
			Vector3D a, b;
			Normal normal;
	
			// box dimensions
	
			double width 	= 55.28;   	// x direction
			double height 	= 54.88;  	// y direction
			double depth 	= 55.92;	// z direction
	
		
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(1.0, 0.73, 0.4);   
			emissive_ptr->scale_radiance(100.0);
	
			p0 = Point3D(21.3, height - 0.001, 22.7);
			a = Vector3D(0.0, 0.0, 10.5);
			b = Vector3D(13.0, 0.0, 0.0);
			normal = Normal(0.0, -1.0, 0.0);
	
			TRectangle* light_ptr = new TRectangle(p0, a, b, normal);
			light_ptr->set_material(emissive_ptr);
			light_ptr->set_sampler(new MultiJittered(num_samples));
			light_ptr->set_shadows(false);
			add_object(light_ptr);
	
			AreaLight* ceiling_light_ptr = new AreaLight;   
			ceiling_light_ptr->set_object(light_ptr);		
			ceiling_light_ptr->set_shadows(true);
			add_light(ceiling_light_ptr);
	
		
			// left wall
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.0);
			matte_ptr1->set_kd(0.6); 
			matte_ptr1->set_cd(0.57, 0.025, 0.025);	 // red
	
			p0 = Point3D(width, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(-1.0, 0.0, 0.0);
			TRectangle* left_wall_ptr = new TRectangle(p0, a, b, normal);
			left_wall_ptr->set_material(matte_ptr1);
			add_object(left_wall_ptr);
	
	
			// right wall
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(0.0);
			matte_ptr2->set_kd(0.6); 
			matte_ptr2->set_cd(0.37, 0.59, 0.2);	 // green  
	
			p0 = Point3D(0.0, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(1.0, 0.0, 0.0);
			TRectangle* right_wall_ptr = new TRectangle(p0, a, b, normal);
			right_wall_ptr->set_material(matte_ptr2);
			add_object(right_wall_ptr);
	
	
			// back wall
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.0);
			matte_ptr3->set_kd(0.6); 
			matte_ptr3->set_cd(white);
	
			p0 = Point3D(0.0, 0.0, depth);
			a = Vector3D(width, 0.0, 0.0);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(0.0, 0.0, -1.0);
			TRectangle* back_wall_ptr = new TRectangle(p0, a, b, normal);
			back_wall_ptr->set_material(matte_ptr3);
			add_object(back_wall_ptr);
	
	
			// floor
	
			p0 = Point3D(0.0, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(width, 0.0, 0.0);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* floor_ptr = new TRectangle(p0, a, b, normal);
			floor_ptr->set_material(matte_ptr3);
			add_object(floor_ptr);
	
	
			// ceiling
	
			p0 = Point3D(0.0, height, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(width, 0.0, 0.0);
			normal = Normal(0.0, -1.0, 0.0);
			TRectangle* ceiling_ptr = new TRectangle(p0, a, b, normal);
			ceiling_ptr->set_material(matte_ptr3);
			add_object(ceiling_ptr);

	
			// the two boxes defined as 5 rectangles each
	
			// short box
	
			// top
	
			p0 = Point3D(13.0, 16.5, 6.5);
			a = Vector3D(-4.8, 0.0, 16.0);
			b = Vector3D(16.0, 0.0, 4.9);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* short_top_ptr = new TRectangle(p0, a, b, normal);
			short_top_ptr->set_material(matte_ptr3);
			add_object(short_top_ptr);
	
	
			// side 1
	
			p0 = Point3D(13.0, 0.0, 6.5);
			a = Vector3D(-4.8, 0.0, 16.0);
			b = Vector3D(0.0, 16.5, 0.0);
			TRectangle* short_side_ptr1 = new TRectangle(p0, a, b);
			short_side_ptr1->set_material(matte_ptr3);
			add_object(short_side_ptr1);
	
	
			// side 2
	
			p0 = Point3D(8.2, 0.0, 22.5);
			a = Vector3D(15.8, 0.0, 4.7);
			TRectangle* short_side_ptr2 = new TRectangle(p0, a, b);
			short_side_ptr2->set_material(matte_ptr3);
			add_object(short_side_ptr2);
	
	
			// side 3
	
			p0 = Point3D(24.2, 0.0, 27.4);
			a = Vector3D(4.8, 0.0, -16.0);
			TRectangle* short_side_ptr3 = new TRectangle(p0, a, b);
			short_side_ptr3->set_material(matte_ptr3);
			add_object(short_side_ptr3);
	
	
			// side 4
	
			p0 = Point3D(29.0, 0.0, 11.4);
			a = Vector3D(-16.0, 0.0, -4.9);
			TRectangle* short_side_ptr4 = new TRectangle(p0, a, b);
			short_side_ptr4->set_material(matte_ptr3);
			add_object(short_side_ptr4);
	
	
	
			// tall box
	
			// top
	
			p0 = Point3D(42.3, 33.0, 24.7);
			a = Vector3D(-15.8, 0.0, 4.9);
			b = Vector3D(4.9, 0.0, 15.9);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* tall_top_ptr = new TRectangle(p0, a, b, normal);
			tall_top_ptr->set_material(matte_ptr3);
			add_object(tall_top_ptr);
	
	
			// side 1
	
			p0 = Point3D(42.3, 0.0, 24.7);
			a = Vector3D(-15.8, 0.0, 4.9);
			b = Vector3D(0.0, 33.0, 0.0);
			TRectangle* tall_side_ptr1 = new TRectangle(p0, a, b);
			tall_side_ptr1->set_material(matte_ptr3);
			add_object(tall_side_ptr1);
	
	
			// side 2
	
			p0 = Point3D(26.5, 0.0, 29.6);
			a = Vector3D(4.9, 0.0, 15.9);
			TRectangle* tall_side_ptr2 = new TRectangle(p0, a, b);
			tall_side_ptr2->set_material(matte_ptr3);
			add_object(tall_side_ptr2);
	
	
			// side 3
	
			p0 = Point3D(31.4, 0.0, 45.5);
			a = Vector3D(15.8, 0.0, -4.9);
			TRectangle* tall_side_ptr3 = new TRectangle(p0, a, b);
			tall_side_ptr3->set_material(matte_ptr3);
			add_object(tall_side_ptr3);
	
	
			// side 4
	
			p0 = Point3D(47.2, 0.0, 40.6);
			a = Vector3D(-4.9, 0.0, -15.9);
			TRectangle* tall_side_ptr4 = new TRectangle(p0, a, b);
			tall_side_ptr4->set_material(matte_ptr3);
			add_object(tall_side_ptr4);
			break;
		}
	case 271:
		{
			//26.12a
			int num_samples = 1;
		
			vp.set_hres(300);	  		
			vp.set_vres(300);
			vp.set_samples(num_samples); 
			vp.set_max_depth(0);
	
			background_color = black;
	
			tracer_ptr = new GlobalTrace(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.0);
			set_ambient_light(ambient_ptr);
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(27.6, 27.4, -80.0);
			pinhole_ptr->set_lookat(27.6, 27.4, 0.0);
			pinhole_ptr->set_view_distance(400);      
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			Point3D p0;
			Vector3D a, b;
			Normal normal;
	
			// box dimensions
	
			double width 	= 55.28;   	// x direction
			double height 	= 54.88;  	// y direction
			double depth 	= 55.92;	// z direction
	
		
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(1.0, 0.73, 0.4);   
			emissive_ptr->scale_radiance(100.0);
	
			p0 = Point3D(21.3, height - 0.001, 22.7);
			a = Vector3D(0.0, 0.0, 10.5);
			b = Vector3D(13.0, 0.0, 0.0);
			normal = Normal(0.0, -1.0, 0.0);
	
			TRectangle* light_ptr = new TRectangle(p0, a, b, normal);
			light_ptr->set_material(emissive_ptr);
			light_ptr->set_sampler(new MultiJittered(num_samples));
			light_ptr->set_shadows(false);
			add_object(light_ptr);
	
			AreaLight* ceiling_light_ptr = new AreaLight;   
			ceiling_light_ptr->set_object(light_ptr);		
			ceiling_light_ptr->set_shadows(true);
			add_light(ceiling_light_ptr);
	
		
			// left wall
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.0);
			matte_ptr1->set_kd(0.6); 
			matte_ptr1->set_cd(0.57, 0.025, 0.025);	 // red
			matte_ptr1->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(width, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(-1.0, 0.0, 0.0);
			TRectangle* left_wall_ptr = new TRectangle(p0, a, b, normal);
			left_wall_ptr->set_material(matte_ptr1);
			add_object(left_wall_ptr);
	
	
			// right wall
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(0.0);
			matte_ptr2->set_kd(0.6); 
			matte_ptr2->set_cd(0.37, 0.59, 0.2);	 // green  
			matte_ptr2->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(0.0, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(1.0, 0.0, 0.0);
			TRectangle* right_wall_ptr = new TRectangle(p0, a, b, normal);
			right_wall_ptr->set_material(matte_ptr2);
			add_object(right_wall_ptr);
	
	
			// back wall
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.0);
			matte_ptr3->set_kd(0.6); 
			matte_ptr3->set_cd(white);
			matte_ptr3->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(0.0, 0.0, depth);
			a = Vector3D(width, 0.0, 0.0);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(0.0, 0.0, -1.0);
			TRectangle* back_wall_ptr = new TRectangle(p0, a, b, normal);
			back_wall_ptr->set_material(matte_ptr3);
			add_object(back_wall_ptr);
	
	
			// floor
	
			p0 = Point3D(0.0, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(width, 0.0, 0.0);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* floor_ptr = new TRectangle(p0, a, b, normal);
			floor_ptr->set_material(matte_ptr3);
			add_object(floor_ptr);
	
	
			// ceiling
	
			p0 = Point3D(0.0, height, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(width, 0.0, 0.0);
			normal = Normal(0.0, -1.0, 0.0);
			TRectangle* ceiling_ptr = new TRectangle(p0, a, b, normal);
			ceiling_ptr->set_material(matte_ptr3);
			add_object(ceiling_ptr);

	
			// the two boxes defined as 5 rectangles each
	
			// short box
	
			// top
	
			p0 = Point3D(13.0, 16.5, 6.5);
			a = Vector3D(-4.8, 0.0, 16.0);
			b = Vector3D(16.0, 0.0, 4.9);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* short_top_ptr = new TRectangle(p0, a, b, normal);
			short_top_ptr->set_material(matte_ptr3);
			add_object(short_top_ptr);
	
	
			// side 1
	
			p0 = Point3D(13.0, 0.0, 6.5);
			a = Vector3D(-4.8, 0.0, 16.0);
			b = Vector3D(0.0, 16.5, 0.0);
			TRectangle* short_side_ptr1 = new TRectangle(p0, a, b);
			short_side_ptr1->set_material(matte_ptr3);
			add_object(short_side_ptr1);
	
	
			// side 2
	
			p0 = Point3D(8.2, 0.0, 22.5);
			a = Vector3D(15.8, 0.0, 4.7);
			TRectangle* short_side_ptr2 = new TRectangle(p0, a, b);
			short_side_ptr2->set_material(matte_ptr3);
			add_object(short_side_ptr2);
	
	
			// side 3
	
			p0 = Point3D(24.2, 0.0, 27.4);
			a = Vector3D(4.8, 0.0, -16.0);
			TRectangle* short_side_ptr3 = new TRectangle(p0, a, b);
			short_side_ptr3->set_material(matte_ptr3);
			add_object(short_side_ptr3);
	
	
			// side 4
	
			p0 = Point3D(29.0, 0.0, 11.4);
			a = Vector3D(-16.0, 0.0, -4.9);
			TRectangle* short_side_ptr4 = new TRectangle(p0, a, b);
			short_side_ptr4->set_material(matte_ptr3);
			add_object(short_side_ptr4);
	
	
	
			// tall box
	
			// top
	
			p0 = Point3D(42.3, 33.0, 24.7);
			a = Vector3D(-15.8, 0.0, 4.9);
			b = Vector3D(4.9, 0.0, 15.9);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* tall_top_ptr = new TRectangle(p0, a, b, normal);
			tall_top_ptr->set_material(matte_ptr3);
			add_object(tall_top_ptr);
	
	
			// side 1
	
			p0 = Point3D(42.3, 0.0, 24.7);
			a = Vector3D(-15.8, 0.0, 4.9);
			b = Vector3D(0.0, 33.0, 0.0);
			TRectangle* tall_side_ptr1 = new TRectangle(p0, a, b);
			tall_side_ptr1->set_material(matte_ptr3);
			add_object(tall_side_ptr1);
	
	
			// side 2
	
			p0 = Point3D(26.5, 0.0, 29.6);
			a = Vector3D(4.9, 0.0, 15.9);
			TRectangle* tall_side_ptr2 = new TRectangle(p0, a, b);
			tall_side_ptr2->set_material(matte_ptr3);
			add_object(tall_side_ptr2);
	
	
			// side 3
	
			p0 = Point3D(31.4, 0.0, 45.5);
			a = Vector3D(15.8, 0.0, -4.9);
			TRectangle* tall_side_ptr3 = new TRectangle(p0, a, b);
			tall_side_ptr3->set_material(matte_ptr3);
			add_object(tall_side_ptr3);
	
	
			// side 4
	
			p0 = Point3D(47.2, 0.0, 40.6);
			a = Vector3D(-4.9, 0.0, -15.9);
			TRectangle* tall_side_ptr4 = new TRectangle(p0, a, b);
			tall_side_ptr4->set_material(matte_ptr3);
			add_object(tall_side_ptr4);
			break;
		}
	case 272:
		{
			//26.12b
			int num_samples = 100;	
		
			vp.set_hres(300);	  		
			vp.set_vres(300);
			vp.set_samples(num_samples); 
			vp.set_max_depth(10);
	
			background_color = black;
	
			tracer_ptr = new PathTrace(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(27.6, 27.4, -80.0);
			pinhole_ptr->set_lookat(27.6, 27.4, 0.0);
			pinhole_ptr->set_view_distance(400);      
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			Point3D p0;
			Vector3D a, b;
			Normal normal;
	
			// box dimensions
	
			double width 	= 55.28;   	// x direction
			double height 	= 54.88;  	// y direction
			double depth 	= 55.92;	// z direction
	
	
			// the ceiling light - doesn't need samples
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(1.0, 0.73, 0.4);   
			emissive_ptr->scale_radiance(100);
	
			p0 = Point3D(21.3, height - 0.001, 22.7);
			a = Vector3D(0.0, 0.0, 10.5);
			b = Vector3D(13.0, 0.0, 0.0);
			normal = Normal(0.0, -1.0, 0.0);
			TRectangle* light_ptr = new TRectangle(p0, a, b, normal);
			light_ptr->set_material(emissive_ptr);
			add_object(light_ptr);
	
		
			// left wall
	
			Matte* matte_ptr1 = new Matte;
			matte_ptr1->set_ka(0.0);
			matte_ptr1->set_kd(0.6); 
			matte_ptr1->set_cd(0.57, 0.025, 0.025);	 // red
			matte_ptr1->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(width, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(-1.0, 0.0, 0.0);
			TRectangle* left_wall_ptr = new TRectangle(p0, a, b, normal);
			left_wall_ptr->set_material(matte_ptr1);
			add_object(left_wall_ptr);
	
	
			// right wall
	
			Matte* matte_ptr2 = new Matte;
			matte_ptr2->set_ka(0.0);
			matte_ptr2->set_kd(0.6); 
			matte_ptr2->set_cd(0.37, 0.59, 0.2);	 // green   from Photoshop
			matte_ptr2->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(0.0, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(1.0, 0.0, 0.0);
			TRectangle* right_wall_ptr = new TRectangle(p0, a, b, normal);
			right_wall_ptr->set_material(matte_ptr2);
			add_object(right_wall_ptr);
	
	
			// back wall
	
			Matte* matte_ptr3 = new Matte;
			matte_ptr3->set_ka(0.0);
			matte_ptr3->set_kd(0.6); 
			matte_ptr3->set_cd(1.0);	 // white
			matte_ptr3->set_sampler(new MultiJittered(num_samples));
	
			p0 = Point3D(0.0, 0.0, depth);
			a = Vector3D(width, 0.0, 0.0);
			b = Vector3D(0.0, height, 0.0);
			normal = Normal(0.0, 0.0, -1.0);
			TRectangle* back_wall_ptr = new TRectangle(p0, a, b, normal);
			back_wall_ptr->set_material(matte_ptr3);
			add_object(back_wall_ptr);
	
	
			// floor
	
			p0 = Point3D(0.0, 0.0, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(width, 0.0, 0.0);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* floor_ptr = new TRectangle(p0, a, b, normal);
			floor_ptr->set_material(matte_ptr3);
			add_object(floor_ptr);
	
	
			// ceiling
	
			p0 = Point3D(0.0, height, 0.0);
			a = Vector3D(0.0, 0.0, depth);
			b = Vector3D(width, 0.0, 0.0);
			normal = Normal(0.0, -1.0, 0.0);
			TRectangle* ceiling_ptr = new TRectangle(p0, a, b, normal);
			ceiling_ptr->set_material(matte_ptr3);
			add_object(ceiling_ptr);

	
			// the two boxes defined as 5 rectangles each
	
			// short box
	
			// top
	
			p0 = Point3D(13.0, 16.5, 6.5);
			a = Vector3D(-4.8, 0.0, 16.0);
			b = Vector3D(16.0, 0.0, 4.9);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* short_top_ptr = new TRectangle(p0, a, b, normal);
			short_top_ptr->set_material(matte_ptr3);
			add_object(short_top_ptr);
	
	
			// side 1
	
			p0 = Point3D(13.0, 0.0, 6.5);
			a = Vector3D(-4.8, 0.0, 16.0);
			b = Vector3D(0.0, 16.5, 0.0);
			TRectangle* short_side_ptr1 = new TRectangle(p0, a, b);
			short_side_ptr1->set_material(matte_ptr3);
			add_object(short_side_ptr1);
	
	
			// side 2
	
			p0 = Point3D(8.2, 0.0, 22.5);
			a = Vector3D(15.8, 0.0, 4.7);
			TRectangle* short_side_ptr2 = new TRectangle(p0, a, b);
			short_side_ptr2->set_material(matte_ptr3);
			add_object(short_side_ptr2);
	
	
			// side 3
	
			p0 = Point3D(24.2, 0.0, 27.4);
			a = Vector3D(4.8, 0.0, -16.0);
			TRectangle* short_side_ptr3 = new TRectangle(p0, a, b);
			short_side_ptr3->set_material(matte_ptr3);
			add_object(short_side_ptr3);
	
	
			// side 4
	
			p0 = Point3D(29.0, 0.0, 11.4);
			a = Vector3D(-16.0, 0.0, -4.9);
			TRectangle* short_side_ptr4 = new TRectangle(p0, a, b);
			short_side_ptr4->set_material(matte_ptr3);
			add_object(short_side_ptr4);
	
	
	
	
			// tall box
	
			// top
	
			p0 = Point3D(42.3, 33.0, 24.7);
			a = Vector3D(-15.8, 0.0, 4.9);
			b = Vector3D(4.9, 0.0, 15.9);
			normal = Normal(0.0, 1.0, 0.0);
			TRectangle* tall_top_ptr = new TRectangle(p0, a, b, normal);
			tall_top_ptr->set_material(matte_ptr3);
			add_object(tall_top_ptr);
	
	
			// side 1
	
			p0 = Point3D(42.3, 0.0, 24.7);
			a = Vector3D(-15.8, 0.0, 4.9);
			b = Vector3D(0.0, 33.0, 0.0);
			TRectangle* tall_side_ptr1 = new TRectangle(p0, a, b);
			tall_side_ptr1->set_material(matte_ptr3);
			add_object(tall_side_ptr1);
	
	
			// side 2
	
			p0 = Point3D(26.5, 0.0, 29.6);
			a = Vector3D(4.9, 0.0, 15.9);
			TRectangle* tall_side_ptr2 = new TRectangle(p0, a, b);
			tall_side_ptr2->set_material(matte_ptr3);
			add_object(tall_side_ptr2);
	
	
			// side 3
	
			p0 = Point3D(31.4, 0.0, 45.5);
			a = Vector3D(15.8, 0.0, -4.9);
			TRectangle* tall_side_ptr3 = new TRectangle(p0, a, b);
			tall_side_ptr3->set_material(matte_ptr3);
			add_object(tall_side_ptr3);
	
	
			// side 4
	
			p0 = Point3D(47.2, 0.0, 40.6);
			a = Vector3D(-4.9, 0.0, -15.9);
			TRectangle* tall_side_ptr4 = new TRectangle(p0, a, b);
			tall_side_ptr4->set_material(matte_ptr3);
			add_object(tall_side_ptr4);
			break;
		}
	case 273:
		{
			//27.12
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);		
			vp.set_max_depth(5);		
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;
	
			// camera setup for the top down view, Figure 7.2 with maxDepth = 5 and eta = 1.5
		
			pinhole_ptr->set_eye(2.0, 50.0, -3.0);   
			pinhole_ptr->set_lookat(2.0, 0.0, -3.0);    
			pinhole_ptr->set_view_distance(1800.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(4.5);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.5);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.5);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// transparent sphere
	
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.2);
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_ior(1.5);		
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(0, 4.5, 0), 3);
			sphere_ptr1->set_material(glass_ptr);
			add_object(sphere_ptr1);
	
	
			// red sphere
		
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.3);
			reflective_ptr->set_kd(0.3); 
			reflective_ptr->set_cd(red); 
			reflective_ptr->set_ks(0.2);
			reflective_ptr->set_exp(2000.0);
			reflective_ptr->set_kr(0.25);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(4, 4, -6), 3);
			sphere_ptr2->set_material(reflective_ptr);
			add_object(sphere_ptr2);

		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4);
			checker_ptr->set_color1(0.75);  
			checker_ptr->set_color2(white);	
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	
	
			// rectangle
	
			TRectangle* rectangle_ptr = new TRectangle(Point3D(-20, -0.001, -100), Vector3D(0, 0, 120), Vector3D(40, 0, 0)); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);		
			break;
		}
	case 274:
		{
			//27.13a
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);		
			vp.set_max_depth(2);			// for Figure 27.13(a)
		//	vp.set_max_depth(4);			// for Figure 27.13(b)
		//	vp.set_max_depth(5);			// for Figure 27.13(c)	
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-8, 5.5, 40);   
			pinhole_ptr->set_lookat(1, 4, 0);    
			pinhole_ptr->set_view_distance(2400.0);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(4.5);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.5);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.5);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// transparent sphere
	
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.2);
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_ior(1.0);		
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0, 4.5, 0.0), 3.0);
			sphere_ptr1->set_material(glass_ptr);
			add_object(sphere_ptr1);
	
	
			// red sphere
		
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.3);
			reflective_ptr->set_kd(0.3); 
			reflective_ptr->set_cd(red); 
			reflective_ptr->set_ks(0.2);
			reflective_ptr->set_exp(2000.0);
			reflective_ptr->set_kr(0.25);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(4, 4, -6), 3);
			sphere_ptr2->set_material(reflective_ptr);
			add_object(sphere_ptr2);

		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4);
			checker_ptr->set_color1(0.75);  
			checker_ptr->set_color2(white);	
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	
	
			// rectangle
	
			Point3D p0(-20, 0, -100);
			Vector3D a(0, 0, 120);
			Vector3D b(40, 0, 0);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);		

			break;
		}
	case 275:
		{
			//27.13b
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);		
		//	vp.set_max_depth(2);			// for Figure 27.13(a)
			vp.set_max_depth(4);			// for Figure 27.13(b)
		//	vp.set_max_depth(5);			// for Figure 27.13(c)	
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-8, 5.5, 40);   
			pinhole_ptr->set_lookat(1, 4, 0);    
			pinhole_ptr->set_view_distance(2400.0);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(4.5);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.5);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.5);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// transparent sphere
	
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.2);
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_ior(1.0);		
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0, 4.5, 0.0), 3.0);
			sphere_ptr1->set_material(glass_ptr);
			add_object(sphere_ptr1);
	
	
			// red sphere
		
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.3);
			reflective_ptr->set_kd(0.3); 
			reflective_ptr->set_cd(red); 
			reflective_ptr->set_ks(0.2);
			reflective_ptr->set_exp(2000.0);
			reflective_ptr->set_kr(0.25);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(4, 4, -6), 3);
			sphere_ptr2->set_material(reflective_ptr);
			add_object(sphere_ptr2);

		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4);
			checker_ptr->set_color1(0.75);  
			checker_ptr->set_color2(white);	
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	
	
			// rectangle
	
			Point3D p0(-20, 0, -100);
			Vector3D a(0, 0, 120);
			Vector3D b(40, 0, 0);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);		

			break;
		}
	case 276:
		{
			//27.13c
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);		
		//	vp.set_max_depth(2);			// for Figure 27.13(a)
		//	vp.set_max_depth(4);			// for Figure 27.13(b)
			vp.set_max_depth(5);			// for Figure 27.13(c)	
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-8, 5.5, 40);   
			pinhole_ptr->set_lookat(1, 4, 0);    
			pinhole_ptr->set_view_distance(2400.0);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(4.5);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.5);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.5);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// transparent sphere
	
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.2);
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_ior(1.0);		
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0, 4.5, 0.0), 3.0);
			sphere_ptr1->set_material(glass_ptr);
			add_object(sphere_ptr1);
	
	
			// red sphere
		
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.3);
			reflective_ptr->set_kd(0.3); 
			reflective_ptr->set_cd(red); 
			reflective_ptr->set_ks(0.2);
			reflective_ptr->set_exp(2000.0);
			reflective_ptr->set_kr(0.25);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(4, 4, -6), 3);
			sphere_ptr2->set_material(reflective_ptr);
			add_object(sphere_ptr2);

		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4);
			checker_ptr->set_color1(0.75);  
			checker_ptr->set_color2(white);	
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	
	
			// rectangle
	
			Point3D p0(-20, 0, -100);
			Vector3D a(0, 0, 120);
			Vector3D b(40, 0, 0);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);		

			break;
		}
	case 277:
		{
			//27.14a
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);		
			vp.set_max_depth(5);		
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-8, 5.5, 40);   
			pinhole_ptr->set_lookat(1, 4, 0);    
			pinhole_ptr->set_view_distance(2400.0);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(4.5);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.5);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.5);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// transparent sphere
	
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.2);
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_ior(1.1);			// for Figure 27.14(a)	
		//	glass_ptr->set_ior(1.5);			// for Figure 27.14(b)
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0, 4.5, 0.0), 3.0);
			sphere_ptr1->set_material(glass_ptr);
			add_object(sphere_ptr1);
	
	
			// red sphere
		
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.3);
			reflective_ptr->set_kd(0.3); 
			reflective_ptr->set_cd(red); 
			reflective_ptr->set_ks(0.2);
			reflective_ptr->set_exp(2000.0);
			reflective_ptr->set_kr(0.25);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(4, 4, -6), 3);
			sphere_ptr2->set_material(reflective_ptr);
			add_object(sphere_ptr2);

		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4);
			checker_ptr->set_color1(0.75);  
			checker_ptr->set_color2(white);	
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	
	
			// rectangle
	
			Point3D p0(-20, 0, -100);
			Vector3D a(0, 0, 120);
			Vector3D b(40, 0, 0);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);		

			break;
		}
	case 278:
		{
			//27.14b
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);		
			vp.set_max_depth(5);		
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-8, 5.5, 40);   
			pinhole_ptr->set_lookat(1, 4, 0);    
			pinhole_ptr->set_view_distance(2400.0);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(4.5);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.5);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.5);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// transparent sphere
	
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.2);
			glass_ptr->set_exp(2000.0);
		//	glass_ptr->set_ior(1.1);			// for Figure 27.14(a)	
			glass_ptr->set_ior(1.5);			// for Figure 27.14(b)
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0, 4.5, 0.0), 3.0);
			sphere_ptr1->set_material(glass_ptr);
			add_object(sphere_ptr1);
	
	
			// red sphere
		
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.3);
			reflective_ptr->set_kd(0.3); 
			reflective_ptr->set_cd(red); 
			reflective_ptr->set_ks(0.2);
			reflective_ptr->set_exp(2000.0);
			reflective_ptr->set_kr(0.25);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(4, 4, -6), 3);
			sphere_ptr2->set_material(reflective_ptr);
			add_object(sphere_ptr2);

		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4);
			checker_ptr->set_color1(0.75);  
			checker_ptr->set_color2(white);	
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	
	
			// rectangle
	
			Point3D p0(-20, 0, -100);
			Vector3D a(0, 0, 120);
			Vector3D b(40, 0, 0);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);		

			break;
		}
	case 279:
		{
			//27.15b
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);		
			vp.set_max_depth(5);		
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-8, 5.5, 40);   
			pinhole_ptr->set_lookat(1, 4, 0);    
			pinhole_ptr->set_view_distance(2400.0);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(4.5);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.5);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.5);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// transparent sphere
	
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.2);
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_ior(0.75);		
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0, 4.5, 0.0), 3.0);
			sphere_ptr1->set_material(glass_ptr);
			add_object(sphere_ptr1);
	
	
			// red sphere
		
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.3);
			reflective_ptr->set_kd(0.3); 
			reflective_ptr->set_cd(red); 
			reflective_ptr->set_ks(0.2);
			reflective_ptr->set_exp(2000.0);
			reflective_ptr->set_kr(0.25);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(4, 4, -6), 3);
			sphere_ptr2->set_material(reflective_ptr);
			add_object(sphere_ptr2);

		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4);
			checker_ptr->set_color1(0.75);  
			checker_ptr->set_color2(white);	
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	
	
			// rectangle
	
			TRectangle* rectangle_ptr = new TRectangle(Point3D(-20, -0.001, -100), Vector3D(0, 0, 120), Vector3D(40, 0, 0)); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);		
			break;
		}
	case 280:
		{
			//27.19a
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_max_depth(10);  
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
	
			tracer_ptr = new Whitted(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 1, 4);	
			pinhole_ptr->set_lookat(0.25, 1.25, 0.0);
			pinhole_ptr->set_view_distance(500.0); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(20, 20, 5);
			light_ptr1->scale_radiance(2.75);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
		
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(-1, 0, 0); 
			light_ptr2->scale_radiance(3.0);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	

			// solid cylinder

			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.15);
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_ior(1.5);
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);

			double bottom 	= 0.0;
			double top 		= 2.25;
			double radius 	= 1.5;
	
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(glass_ptr);
			add_object(cylinder_ptr);
	
	
			// red sphere
		
			Reflective*	phong_ptr = new Reflective;
			phong_ptr->set_cd(red);			
			phong_ptr->set_ka(0.3);
			phong_ptr->set_kd(0.9);  
			phong_ptr->set_ks(0.25); 
			phong_ptr->set_exp(1000);
			phong_ptr->set_kr(0.25);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(2.0, 1.5, -2.5), 1.5);
			sphere_ptr2->set_material(phong_ptr);
			add_object(sphere_ptr2);
		
	
			// plane with checker
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(1.0);		
			checker_ptr->set_color1(white);  
			checker_ptr->set_color2(0.5);	
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.8);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);	

			break;
		}
	case 281:
		{
			//27.19b
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_max_depth(3);      
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
	
			tracer_ptr = new Whitted(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-0.25, 1, 3);
			pinhole_ptr->set_lookat(0.25, 1.25, 0);
			pinhole_ptr->set_view_distance(500);  
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(20, 20, 5);
			light_ptr1->scale_radiance(2.75);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			// red sphere
		
			Reflective*	phong_ptr2 = new Reflective;
			phong_ptr2->set_cd(1, 0, 0);
			phong_ptr2->set_ka(0.3);
			phong_ptr2->set_kd(0.9);  
			phong_ptr2->set_ks(0.2); 
			phong_ptr2->set_exp(1000);
			phong_ptr2->set_kr(0.25);
	
			Sphere* sphere_ptr = new Sphere(Point3D(2.0, 1.5, -2.5), 1.5);
			sphere_ptr->set_material(phong_ptr2);
			add_object(sphere_ptr);                


			// thick ring
	
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.15);
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_ior(1.5);
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);

	
			double ymin = 0.0;
			double ymax = 0.35;
			double inner_radius = 0.9;
			double outer_radius = 1.25;
	
			Instance* ring_ptr = new Instance (new ThickRing(ymin, ymax, inner_radius, outer_radius));
			ring_ptr->set_material(glass_ptr);
			ring_ptr->rotate_x(90);
			ring_ptr->rotate_y(-45);
			ring_ptr->translate(0, 1.25, 0);
			add_object(ring_ptr);
	
	
			// plane with checker
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(1.0);		
			checker_ptr->set_color1(white);  	
			checker_ptr->set_color2(0.5);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.8);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);	
			break;
		}
	case 282:
		{
			//27.19c
			int num_samples = 4;   // at max_depth = 10, this renders very slowly
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_max_depth(10);
			vp.set_samples(num_samples);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(1, 7.5, 20);
			pinhole_ptr->set_lookat(0, -0.35, 0);
			pinhole_ptr->set_view_distance(5250.0); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(20, 20, 15);
			light_ptr->scale_radiance(2.75);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
		
			// transparent bowl
	
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.5);
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_ior(1.5);
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);
		
			double 	inner_radius = 0.9;
			double 	outer_radius = 1.0;
	
			FlatRimmedBowl* bowl_ptr = new FlatRimmedBowl(inner_radius, outer_radius);
			bowl_ptr->set_material(glass_ptr);
			add_object(bowl_ptr);
	
	
			// the two spheres in the bowl just touch its inner surface
	
			// red sphere
		
			Reflective*	reflective_ptr1 = new Reflective;
			reflective_ptr1->set_ka(0.6);	
			reflective_ptr1->set_kd(0.4); 
			reflective_ptr1->set_cd(red);		 
			reflective_ptr1->set_ks(0.5);
			reflective_ptr1->set_exp(2000.0);
			reflective_ptr1->set_kr(0.25);
	
	
			double radius = 0.4;
			double theta = 55.0;
			theta = 3.1415926 * theta / 180.0;
			double xc = -(0.9 - radius) * cos(theta);
			double yc = -(0.9 - radius) * sin(theta);
			Sphere* sphere_ptr2 = new Sphere(Point3D(xc, yc, 0), radius);
			sphere_ptr2->set_material(reflective_ptr1);
			add_object(sphere_ptr2);
	
	
			// yellow sphere
		
			Reflective*	reflective_ptr2 = new Reflective;
			reflective_ptr2->set_ka(0.6);	
			reflective_ptr2->set_kd(0.4); 
			reflective_ptr2->set_cd(1, 1, 0);			// yellow 
			reflective_ptr2->set_ks(0.5);
			reflective_ptr2->set_exp(2000.0);
			reflective_ptr2->set_kr(0.5);
	
	
			radius = 0.35;
			theta = 35.0;
			theta = 3.1415926 * theta / 180.0;
			xc = (0.9 - radius) * cos(theta);
			yc = -(0.9 - radius) * sin(theta);
			Sphere* sphere_ptr3 = new Sphere(Point3D(xc, yc, 0), radius);
			sphere_ptr3->set_material(reflective_ptr2);
			add_object(sphere_ptr3);
	
	
			// rectangle
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(1.0);		
			checker_ptr->set_color1(white);  	
			checker_ptr->set_color2(0.5);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.8);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Point3D p0(-2, -1, -5);
			Vector3D a(0, 0, 9);
			Vector3D b(4, 0, 0);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b);  
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);	
			break;
		}
	case 283:
		{
			//27.20
			int num_samples = 1;
	
			vp.set_hres(300);	  		
			vp.set_vres(300);
			vp.set_max_depth(5);
			vp.set_samples(num_samples);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 7.5, 20);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(2000.0);
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(20, 20, 15);
			light_ptr->scale_radiance(3.25);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
		
			// beveled box shell	
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_ks(0.5);
			glass_ptr->set_exp(10000.0);
			glass_ptr->set_eta_in(1.5);
			glass_ptr->set_eta_out(1.0);
			glass_ptr->set_cf_in(RGBColor(1.0, 1.0, 0.5));
	
			Point3D p0(-1.0);
			Point3D p1(1.0);
			double bevel_radius = 0.5;

			BeveledBoxShell* box_ptr = new BeveledBoxShell(p0, p1, bevel_radius); 
			box_ptr->set_material(glass_ptr);
			add_object(box_ptr);
	
			// rectangle
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(1.0);		
			checker_ptr->set_color1(white);  	
			checker_ptr->set_color2(0.5);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.8);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(checker_ptr);
	
			p0 = Point3D(-4.0, -1.01, -4.0);
			Vector3D a(0, 0, 8);
			Vector3D b(8, 0, 0);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b);  
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);	
			break;
		}
	case 284:
		{
			//27.21a
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);		
			vp.set_max_depth(5);		
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-8, 5.5, 40);   
			pinhole_ptr->set_lookat(1, 4, 0);    
			pinhole_ptr->set_view_distance(2400.0);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(4.5);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.5);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.5);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// transparent disks
	
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.2);
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_ior(1.5);		
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);	
	
			Disk* disk_ptr1 = new Disk(Point3D(0, 4.5, 0), Normal(0, 0, 1), 3);
			disk_ptr1->set_material(glass_ptr);
			add_object(disk_ptr1);
	
			Disk* disk_ptr2 = new Disk(Point3D(0, 4.5, -3), Normal(0, 0, -1), 2);
			disk_ptr2->set_material(glass_ptr);
			add_object(disk_ptr2);
	
	
			// red sphere
		
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.3);
			reflective_ptr->set_kd(0.3); 
			reflective_ptr->set_cd(red); 
			reflective_ptr->set_ks(0.2);
			reflective_ptr->set_exp(2000.0);
			reflective_ptr->set_kr(0.25);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(4, 4, -6), 3);
			sphere_ptr2->set_material(reflective_ptr);
			add_object(sphere_ptr2);

		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4);
			checker_ptr->set_color1(0.75);  
			checker_ptr->set_color2(white);	
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	
	
			// rectangle
	
			Point3D p0(-20, 0, -100);
			Vector3D a(0, 0, 120);
			Vector3D b(40, 0, 0);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);	
			break;
		}
	case 285:
		{
			//27.21b
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);		
			vp.set_max_depth(5);		
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-8, 5.5, 40);   
			pinhole_ptr->set_lookat(1, 4, 0);    
			pinhole_ptr->set_view_distance(2400.0);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(4.5);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.5);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.5);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// transparent disks
	
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.2);
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_ior(1.5);		
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);	
	
			Disk* disk_ptr1 = new Disk(Point3D(0, 4.5, 0), Normal(0, 0, -1), 3);
			disk_ptr1->set_material(glass_ptr);
			add_object(disk_ptr1);
	
	
			// red sphere
		
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.3);
			reflective_ptr->set_kd(0.3); 
			reflective_ptr->set_cd(red); 
			reflective_ptr->set_ks(0.2);
			reflective_ptr->set_exp(2000.0);
			reflective_ptr->set_kr(0.25);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(4, 4, -6), 3);
			sphere_ptr2->set_material(reflective_ptr);
			add_object(sphere_ptr2);

		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4);
			checker_ptr->set_color1(0.75);  
			checker_ptr->set_color2(white);	
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);
		
	
			// rectangle
	
			Point3D p0(-20, 0, -100);
			Vector3D a(0, 0, 120);
			Vector3D b(40, 0, 0);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);		
			break;
		}
	case 286:
		{
			//27.23a
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_max_depth(3);      
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.75);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			tracer_ptr = new Whitted(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 20);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(4500); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(0, 50, 0);
			light_ptr1->scale_radiance(4.5);
			light_ptr1->set_shadows(false);
			add_light(light_ptr1);
	
	
			// transparent sphere
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_ks(0.15);
			glass_ptr->set_exp(100.0);
			glass_ptr->set_eta_in(1.5);
			glass_ptr->set_eta_out(1.0);
			glass_ptr->set_cf_in(RGBColor(0.47, 0.86, 0.74));
			glass_ptr->set_cf_out(white);
			
			Sphere* sphere_ptr = new Sphere;
			sphere_ptr->set_material(glass_ptr);
			add_object(sphere_ptr);                
	
	
			// plane with checker
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4.0);		
			checker_ptr->set_color1(white);  	
			checker_ptr->set_color2(black);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.65);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -5, 0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);	
			break;
		}
	case 287:
		{
			//27.23b
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_max_depth(3);      
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.75);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			tracer_ptr = new Whitted(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 1.25);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(180); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(0, 50, 0);
			light_ptr1->scale_radiance(4.5);
			light_ptr1->set_shadows(false);
			add_light(light_ptr1);
	
	
			// transparent sphere
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_ks(0.15);
			glass_ptr->set_exp(100.0);
			glass_ptr->set_eta_in(1.5);
			glass_ptr->set_eta_out(1.0);
			glass_ptr->set_cf_in(RGBColor(0.47, 0.86, 0.74));
			glass_ptr->set_cf_out(white);
			
			Sphere* sphere_ptr = new Sphere;
			sphere_ptr->set_material(glass_ptr);
			add_object(sphere_ptr);                
	
	
			// plane with checker
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4.0);		
			checker_ptr->set_color1(white);  	
			checker_ptr->set_color2(black);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.65);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -5, 0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);	
			break;
		}
	case 288:
		{
			//27.24a
			int num_samples = 1;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);		
			vp.set_max_depth(5);		
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-8, 5.5, 40); 
			pinhole_ptr->set_lookat(0, 4, 0); 
			pinhole_ptr->set_view_distance(1800);	 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(4.5);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.5);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.5);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// transparent ellipsoid
		
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.2);
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_ior(1.5);		
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);	
	
			Instance* ellipsoid_ptr = new Instance (new Sphere(Point3D(0.0), 1.0));
			ellipsoid_ptr->set_material(glass_ptr);
			ellipsoid_ptr->scale(6, 2, 3);
			ellipsoid_ptr->rotate_x(90);
			ellipsoid_ptr->translate(0, 3, 0);
			add_object(ellipsoid_ptr);
	
	
			// red sphere
		
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.3);
			reflective_ptr->set_kd(0.3); 
			reflective_ptr->set_cd(red); 
			reflective_ptr->set_ks(0.2);
			reflective_ptr->set_exp(2000.0);
			reflective_ptr->set_kr(0.25);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(4, 4, -6), 3);
			sphere_ptr2->set_material(reflective_ptr);
			add_object(sphere_ptr2);

		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4);
			checker_ptr->set_color1(0.75);  
			checker_ptr->set_color2(white);	
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	
	
			// rectangle
	
			Point3D p0(-20, 0, -100);
			Vector3D a(0, 0, 120);
			Vector3D b(40, 0, 0);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);		
			break;
		}
	case 289:
		{
			//27.26
			int num_samples = 1;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);		
			vp.set_max_depth(5);		
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-8, 5.5, 40);   
			pinhole_ptr->set_lookat(1, 4, 0);    
			pinhole_ptr->set_view_distance(2400.0);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(4.5);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.5);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.5);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// transparent disks
	
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.2);
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_ior(1.5);		
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);	
	
			Disk* disk_ptr1 = new Disk(Point3D(0, 4.5, 0), Normal(0, 0, 1), 3);
			disk_ptr1->set_material(glass_ptr);
			add_object(disk_ptr1);
	
			Disk* disk_ptr2 = new Disk(Point3D(0, 4.5, -3), Normal(0, 0, 1), 2);
			disk_ptr2->set_material(glass_ptr);
			add_object(disk_ptr2);
	
	
			// red sphere
		
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.3);
			reflective_ptr->set_kd(0.3); 
			reflective_ptr->set_cd(red); 
			reflective_ptr->set_ks(0.2);
			reflective_ptr->set_exp(2000.0);
			reflective_ptr->set_kr(0.25);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(4, 4, -6), 3);
			sphere_ptr2->set_material(reflective_ptr);
			add_object(sphere_ptr2);

		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4);
			checker_ptr->set_color1(0.75);  
			checker_ptr->set_color2(white);	
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	
	
			// rectangle
	
			Point3D p0(-20, 0, -100);
			Vector3D a(0, 0, 120);
			Vector3D b(40, 0, 0);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);		

			break;
		}
	case 290:
		{
			//27.28
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);		
			vp.set_max_depth(5);		
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-8, 5.5, 40); 
			pinhole_ptr->set_lookat(0, 4, 0); 
			pinhole_ptr->set_view_distance(1800);	 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(4.5);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.5);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.5);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// transparent ellipsoid
		
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.2);
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_ior(0.75);		
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);	
	
			Instance* ellipsoid_ptr = new Instance (new Sphere(Point3D(0.0), 1.0));
			ellipsoid_ptr->set_material(glass_ptr);
			ellipsoid_ptr->scale(6, 2, 3);
			ellipsoid_ptr->rotate_x(90);
			ellipsoid_ptr->translate(0, 3, 0);
			add_object(ellipsoid_ptr);
	
	
			// red sphere
		
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.3);
			reflective_ptr->set_kd(0.3); 
			reflective_ptr->set_cd(red); 
			reflective_ptr->set_ks(0.2);
			reflective_ptr->set_exp(2000.0);
			reflective_ptr->set_kr(0.25);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(4, 4, -6), 3);
			sphere_ptr2->set_material(reflective_ptr);
			add_object(sphere_ptr2);

		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4);
			checker_ptr->set_color1(0.75);  
			checker_ptr->set_color2(white);	
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	
	
			// rectangle
	
			Point3D p0(-20, 0, -100);
			Vector3D a(0, 0, 120);
			Vector3D b(40, 0, 0);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);		

			break;
		}
	case 291:
		{
			//27.29
			int num_samples = 9;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);		
			vp.set_max_depth(5);		
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-8, 5.5, 20);      
			pinhole_ptr->set_lookat(0, 4.5, 0);     
			pinhole_ptr->set_view_distance(1400.0);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(4.5);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.5);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.5);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// transparent torus
	
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.2);
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_ior(1.5);		
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);
	
			Instance* torus_ptr2 = new Instance (new Torus(3.0, 0.8));
			torus_ptr2->set_material(glass_ptr);
			torus_ptr2->rotate_x(90);
			torus_ptr2->rotate_y(20);
			torus_ptr2->translate(0, 4.5, 0);
			add_object(torus_ptr2);
	
	
			// red sphere
		
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.3);
			reflective_ptr->set_kd(0.3); 
			reflective_ptr->set_cd(red); 
			reflective_ptr->set_ks(0.2);
			reflective_ptr->set_exp(2000.0);
			reflective_ptr->set_kr(0.25);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(4, 4, -6), 3);
			sphere_ptr2->set_material(reflective_ptr);
			add_object(sphere_ptr2);

		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4.0);
			checker_ptr->set_color1(0.75);  
			checker_ptr->set_color2(white);	
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	
	
	
			// rectangle
	
			Point3D p0(-20, 0, -100);
			Vector3D a(0, 0, 120);
			Vector3D b(40, 0, 0);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);	
			break;
		}
	case 292:
		{
			//27.30
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny69K.ply").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);		
			vp.set_max_depth(5);		
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-5, 5.5, 35);      
			pinhole_ptr->set_lookat(1.25, 3.5, 0);     
			pinhole_ptr->set_view_distance(2400.0);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(4.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.0);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.0);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// transparent bunny
	
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.2);
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_ior(1.5);		
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);
		
		//	const char* fileName = "Bunny3K.ply"; 	// 4000 triangles
		//	const char* fileName = "Bunny10K.ply"; 	// 10000 triangles
		//	const char* fileName = "Bunny16K.ply"; 	// 16000 triangles
		//	const char* fileName = "Bunny69K.ply"; 	// 69000 triangles

			Mesh* mesh_ptr = new Mesh;
			Grid* bunny_ptr = new Grid(mesh_ptr);
		//	bunny_ptr->read_flat_triangles(fileName);	
			bunny_ptr->read_smooth_triangles(QString(plyfile+"Stanford Bunny\\Bunny69K.ply").toLatin1().data());	
			bunny_ptr->set_material(glass_ptr); 	
			bunny_ptr->setup_cells();

			Instance* big_bunny_ptr = new Instance(bunny_ptr);
			big_bunny_ptr->scale(45.0);
			big_bunny_ptr->translate(1.7, -1.5, 0.0);
			add_object(big_bunny_ptr);
	
	
			// red sphere
		
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.3);
			reflective_ptr->set_kd(0.3); 
			reflective_ptr->set_cd(red); 
			reflective_ptr->set_ks(0.2);
			reflective_ptr->set_exp(2000.0);
			reflective_ptr->set_kr(0.25);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(4, 4, -6), 3);
			sphere_ptr2->set_material(reflective_ptr);
			add_object(sphere_ptr2);

		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4.0);
			checker_ptr->set_color1(white);  
			checker_ptr->set_color2(0.75);	
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	
	
	
			// rectangle
	
			Point3D p0(-20, 0, -100);
			Vector3D a(0, 0, 120);
			Vector3D b(40, 0, 0);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);	
			break;
		}
	case 293:
		{
			//27.32a
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_max_depth(2);     		// for Figure 27.32(a) 
		//	vp.set_max_depth(3);     		// for Figure 27.32(b)
			vp.set_samples(num_samples);
	
			background_color = white;
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
	
			tracer_ptr = new Whitted(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-0.25, 1, 3);
			pinhole_ptr->set_lookat(0.25, 1.25, 0);
			pinhole_ptr->set_view_distance(500);  
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(20, 20, 5);
			light_ptr1->scale_radiance(2.75);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	         


			// thick ring
	
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.15);
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_ior(1.5);
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);

	
			double ymin = 0.0;
			double ymax = 0.35;
			double inner_radius = 0.9;
			double outer_radius = 1.25;
	
			Instance* ring_ptr = new Instance (new ThickRing(ymin, ymax, inner_radius, outer_radius));
			ring_ptr->set_material(glass_ptr);
			ring_ptr->rotate_x(90);
			ring_ptr->rotate_y(-45);
			ring_ptr->translate(0, 1.25, 0);
			add_object(ring_ptr);
	
	
			// plane with checker
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(1.0);		
			checker_ptr->set_color1(white);  	
			checker_ptr->set_color2(0.5);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.8);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);	
			break;
		}
	case 294:
		{
			//27.32b
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
		//	vp.set_max_depth(2);     		// for Figure 27.32(a) 
			vp.set_max_depth(3);     		// for Figure 27.32(b)
			vp.set_samples(num_samples);
	
			background_color = white;
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
	
			tracer_ptr = new Whitted(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-0.25, 1, 3);
			pinhole_ptr->set_lookat(0.25, 1.25, 0);
			pinhole_ptr->set_view_distance(500);  
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(20, 20, 5);
			light_ptr1->scale_radiance(2.75);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	         


			// thick ring
	
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.15);
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_ior(1.5);
			glass_ptr->set_kr(0.1);
			glass_ptr->set_kt(0.9);

	
			double ymin = 0.0;
			double ymax = 0.35;
			double inner_radius = 0.9;
			double outer_radius = 1.25;
	
			Instance* ring_ptr = new Instance (new ThickRing(ymin, ymax, inner_radius, outer_radius));
			ring_ptr->set_material(glass_ptr);
			ring_ptr->rotate_x(90);
			ring_ptr->rotate_y(-45);
			ring_ptr->translate(0, 1.25, 0);
			add_object(ring_ptr);
	
	
			// plane with checker
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(1.0);		
			checker_ptr->set_color1(white);  	
			checker_ptr->set_color2(0.5);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.8);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);	
			break;
		}
	case 295:
		{
			//28.05a
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);		
			vp.set_max_depth(5);		
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-8, 5.5, 40);   
			pinhole_ptr->set_lookat(1, 4, 0);    
			pinhole_ptr->set_view_distance(2400.0);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(4.5);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.5);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.5);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// transparent sphere
	
			Dielectric* dielectic_ptr = new Dielectric;
			dielectic_ptr->set_ks(0.2);
			dielectic_ptr->set_exp(2000.0);
			dielectic_ptr->set_eta_in(1.5);		// for Figure 28.5(a)
		//	dielectic_ptr->set_eta_in(0.75);	// for Figure 28.5(b)
			dielectic_ptr->set_eta_out(1.0);
			dielectic_ptr->set_cf_in(white);
			dielectic_ptr->set_cf_out(white);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0, 4.5, 0.0), 3.0);
			sphere_ptr1->set_material(dielectic_ptr);
			add_object(sphere_ptr1);
	
	
			// red sphere
		
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.3);
			reflective_ptr->set_kd(0.3); 
			reflective_ptr->set_cd(red); 
			reflective_ptr->set_ks(0.2);
			reflective_ptr->set_exp(2000.0);
			reflective_ptr->set_kr(0.25);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(4, 4, -6), 3);
			sphere_ptr2->set_material(reflective_ptr);
			add_object(sphere_ptr2);

		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4);
			checker_ptr->set_color1(0.75);  
			checker_ptr->set_color2(white);	
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	
	
			// rectangle
	
			Point3D p0(-20, 0, -100);
			Vector3D a(0, 0, 120);
			Vector3D b(40, 0, 0);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);		

			break;
		}
	case 296:
		{
			//28.05b
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);		
			vp.set_max_depth(5);		
	
			background_color = RGBColor(0.0, 0.3, 0.25);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-8, 5.5, 40);   
			pinhole_ptr->set_lookat(1, 4, 0);    
			pinhole_ptr->set_view_distance(2400.0);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(4.5);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.5);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.5);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// transparent sphere
	
			Dielectric* dielectic_ptr = new Dielectric;
			dielectic_ptr->set_ks(0.2);
			dielectic_ptr->set_exp(2000.0);
		//	dielectic_ptr->set_eta_in(1.5);		// for Figure 28.5(a)
			dielectic_ptr->set_eta_in(0.75);	// for Figure 28.5(b)
			dielectic_ptr->set_eta_out(1.0);
			dielectic_ptr->set_cf_in(white);
			dielectic_ptr->set_cf_out(white);
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0, 4.5, 0.0), 3.0);
			sphere_ptr1->set_material(dielectic_ptr);
			add_object(sphere_ptr1);
	
	
			// red sphere
		
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.3);
			reflective_ptr->set_kd(0.3); 
			reflective_ptr->set_cd(red); 
			reflective_ptr->set_ks(0.2);
			reflective_ptr->set_exp(2000.0);
			reflective_ptr->set_kr(0.25);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(4, 4, -6), 3);
			sphere_ptr2->set_material(reflective_ptr);
			add_object(sphere_ptr2);

		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4);
			checker_ptr->set_color1(0.75);  
			checker_ptr->set_color2(white);	
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);	
	
			// rectangle
	
			Point3D p0(-20, 0, -100);
			Vector3D a(0, 0, 120);
			Vector3D b(40, 0, 0);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b); 
			rectangle_ptr->set_material(sv_matte_ptr);
			add_object(rectangle_ptr);		

			break;
		}
	case 297:
		{
			//29.06a
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);	
			vp.set_max_depth(1);		
	
			background_color = white;
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 50);   
			pinhole_ptr->set_lookat(0);    
			pinhole_ptr->set_view_distance(4200.0);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_ka(0.0);
			dielectric_ptr->set_kd(0.0); 
			dielectric_ptr->set_ks(0.2);  
			dielectric_ptr->set_exp(2000.0);
			dielectric_ptr->set_eta_in(1.5);   
			dielectric_ptr->set_eta_out(1.0);
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white);
		
			Sphere* sphere_ptr1 = new Sphere(Point3D(0), 3);
			sphere_ptr1->set_material(dielectric_ptr);
			add_object(sphere_ptr1);		
			break;
		}
	case 298:
		{
			//29.06b
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);	
			vp.set_max_depth(1);
	
			background_color = white;
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;	
			pinhole_ptr->set_eye(0, 0, 500);   
			pinhole_ptr->set_lookat(-3, 0, 0);    
			pinhole_ptr->set_view_distance(30000000.0);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
		
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_ka(0.0);
			dielectric_ptr->set_kd(0.0); 
			dielectric_ptr->set_ks(0.2);  
			dielectric_ptr->set_exp(2000.0);
			dielectric_ptr->set_eta_in(1.5);   
			dielectric_ptr->set_eta_out(1.0);
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white);
		
			Sphere* sphere_ptr1 = new Sphere(Point3D(0), 3);
			sphere_ptr1->set_material(dielectric_ptr);
			add_object(sphere_ptr1);		
			break;
		}
	case 299:
		{
			//29.06c
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);	
			vp.set_max_depth(3);			
	
			background_color = white;
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 50);   
			pinhole_ptr->set_lookat(0);    
			pinhole_ptr->set_view_distance(4200.0);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);	
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_ka(0.0);
			dielectric_ptr->set_kd(0.0); 
			dielectric_ptr->set_ks(0.2);  
			dielectric_ptr->set_exp(2000.0);
			dielectric_ptr->set_eta_in(1.5);   
			dielectric_ptr->set_eta_out(1.0);
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white);
		
			Sphere* sphere_ptr1 = new Sphere(Point3D(0), 3);
			sphere_ptr1->set_material(dielectric_ptr);
			add_object(sphere_ptr1);		
			break;
		}
	case 300:
		{
			//28.07a
			int num_samples = 25;
	
			vp.set_hres(600);      
			vp.set_vres(600);
			vp.set_max_depth(3);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.5, 0.6666, 0.5);  // light green
	
			tracer_ptr = new Whitted(this);	

			FishEye* fisheye_ptr = new FishEye;
			fisheye_ptr->set_eye(0.0, 0.1, 0.0);
			fisheye_ptr->set_lookat(0, 10, 0);
			fisheye_ptr->set_rectangular(true);
			fisheye_ptr->set_field_of_view(265.0);
			fisheye_ptr->compute_uvw();  
			set_camera(fisheye_ptr);
	
		
			Directional* light_ptr1 = new Directional; 
			light_ptr1->set_direction(0, 1, 0);
			light_ptr1->scale_radiance(5.0);
			light_ptr1->set_shadows(false);
			add_light(light_ptr1);
	
	
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.0);
			glass_ptr->set_exp(1.0);
			glass_ptr->set_ior(1.5);			
			glass_ptr->set_kr(0.1);     
			glass_ptr->set_kt(0.9);   
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_cd(0);
			dielectric_ptr->set_ka(0.0);
			dielectric_ptr->set_kd(0.0);
			dielectric_ptr->set_ks(0.0);
			dielectric_ptr->set_exp(1.0);
			dielectric_ptr->set_eta_in(1.5);
			dielectric_ptr->set_eta_out(1.0);
	
			double radius 	= 250.0;
			double bottom 	= 10.0;
			double top 		= 10.1;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(glass_ptr);				// for Figure 28.7(a)
		//	cylinder_ptr->set_material(dielectric_ptr);			// for Figure 28.7(b)
			add_object(cylinder_ptr);
	
	
			// plane with checker
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(10.0);
			checker_ptr->set_color1(black);  
			checker_ptr->set_color2(1.0, 0.7, 0.2);  // orange	
	
			SV_Matte* sv_matte_ptr5 = new SV_Matte;		
			sv_matte_ptr5->set_ka(0.25);
			sv_matte_ptr5->set_kd(0.5);
			sv_matte_ptr5->set_cd(checker_ptr);

			Plane* plane_ptr2 = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr2->set_material(sv_matte_ptr5);
			plane_ptr2->set_shadows(false);
			add_object(plane_ptr2);	

			break;
		}
	case 301:
		{
			//28.07b
			int num_samples = 25;
	
			vp.set_hres(600);      
			vp.set_vres(600);
			vp.set_max_depth(3);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.5, 0.6666, 0.5);  // light green
	
			tracer_ptr = new Whitted(this);	

			FishEye* fisheye_ptr = new FishEye;
			fisheye_ptr->set_eye(0.0, 0.1, 0.0);
			fisheye_ptr->set_lookat(0, 10, 0);
			fisheye_ptr->set_rectangular(true);
			fisheye_ptr->set_field_of_view(265.0);
			fisheye_ptr->compute_uvw();  
			set_camera(fisheye_ptr);
	
		
			Directional* light_ptr1 = new Directional; 
			light_ptr1->set_direction(0, 1, 0);
			light_ptr1->scale_radiance(5.0);
			light_ptr1->set_shadows(false);
			add_light(light_ptr1);
	
	
			Transparent* glass_ptr = new Transparent;
			glass_ptr->set_ks(0.0);
			glass_ptr->set_exp(1.0);
			glass_ptr->set_ior(1.5);			
			glass_ptr->set_kr(0.1);     
			glass_ptr->set_kt(0.9);   
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_cd(0);
			dielectric_ptr->set_ka(0.0);
			dielectric_ptr->set_kd(0.0);
			dielectric_ptr->set_ks(0.0);
			dielectric_ptr->set_exp(1.0);
			dielectric_ptr->set_eta_in(1.5);
			dielectric_ptr->set_eta_out(1.0);
	
			double radius 	= 250.0;
			double bottom 	= 10.0;
			double top 		= 10.1;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
		//	cylinder_ptr->set_material(glass_ptr);				// for Figure 28.7(a)
			cylinder_ptr->set_material(dielectric_ptr);			// for Figure 28.7(b)
			add_object(cylinder_ptr);
	
	
			// plane with checker
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(10.0);
			checker_ptr->set_color1(black);  
			checker_ptr->set_color2(1.0, 0.7, 0.2);  // orange	
	
			SV_Matte* sv_matte_ptr5 = new SV_Matte;		
			sv_matte_ptr5->set_ka(0.25);
			sv_matte_ptr5->set_kd(0.5);
			sv_matte_ptr5->set_cd(checker_ptr);

			Plane* plane_ptr2 = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr2->set_material(sv_matte_ptr5);
			plane_ptr2->set_shadows(false);
			add_object(plane_ptr2);	
			break;
		}
	case 302:
		{
			//28.08
			int num_samples = 9;
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_max_depth(6);   // depth 6 is necessary to get rays through the three cylinders
			vp.set_pixel_size(0.012);
			vp.set_samples(num_samples);
	
			background_color = black;
	
			tracer_ptr = new Whitted(this);
	
	
			// camera looks down y axis because disks have vertical axes	
	
			Orthographic* orthographic_ptr = new Orthographic;
			orthographic_ptr->set_eye(0.23, 100, 0);    
			orthographic_ptr->set_lookat(0.23, 0, 0);  
			orthographic_ptr->compute_uvw();     
			set_camera(orthographic_ptr);
	
			// top cylinder (in image)
	
			double top1 = 0.5;
			double bottom1 = 0.0;
			double radius = 1.25;
	
			RGBColor glass_color1(0, 1, 1);    // cyan
	
			Dielectric* glass_ptr1 = new Dielectric;
			glass_ptr1->set_eta_in(1.5);		// glass
			glass_ptr1->set_eta_out(1.0);		// air
			glass_ptr1->set_cf_in(glass_color1);
			glass_ptr1->set_cf_out(white); 
	
			Instance* cylinder_ptr1 = new Instance (new SolidCylinder(bottom1,top1, radius)); 
			cylinder_ptr1->translate(1, 0, 0);
			cylinder_ptr1->set_material(glass_ptr1);
			add_object(cylinder_ptr1);	
	
	
			// left cylinder
	
			double top2 = 1.5;
			double bottom2 = 1;
	
			RGBColor glass_color2(1, 1, 0);   // yellow
	
			Dielectric* glass_ptr2 = new Dielectric;
			glass_ptr2->set_eta_in(1.5);		// glass
			glass_ptr2->set_eta_out(1.0);		// air
			glass_ptr2->set_cf_in(glass_color2);
			glass_ptr2->set_cf_out(white); 
	
			Instance* cylinder_ptr2 = new Instance (new SolidCylinder(bottom2,top2, radius)); 
			cylinder_ptr2->translate(-0.5, 0, -0.866);
			cylinder_ptr2->set_material(glass_ptr2);
			add_object(cylinder_ptr2);	
	
	
			// right cylinder
	
			double top3 = 2.5;
			double bottom3 = 2;
	
			RGBColor glass_color3(1, 0, 1);    // majenta
	
			Dielectric* glass_ptr3 = new Dielectric;
			glass_ptr3->set_eta_in(1.5);		// glass
			glass_ptr3->set_eta_out(1.0);		// air
			glass_ptr3->set_cf_in(glass_color3);
			glass_ptr3->set_cf_out(white); 
	
			Instance* cylinder_ptr3 = new Instance (new SolidCylinder(bottom3,top3, radius)); 
			cylinder_ptr3->translate(-0.5, 0, 0.866);
			cylinder_ptr3->set_material(glass_ptr3);
			add_object(cylinder_ptr3);	
	
	
			// white plane below disks
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(1.0);		// default
			emissive_ptr->set_ce(white);			// default
	
			Plane* plane_ptr = new Plane(Point3D(0, -1, 0), Normal(0, 1, 0)); 
			plane_ptr->set_material(emissive_ptr);
			add_object(plane_ptr);		
			break;
		}
	case 303:
		{
			//28.09
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_max_depth(6);		
	
			background_color = white;
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
	
		
			Pinhole* pinhole_ptr = new Pinhole;	
			pinhole_ptr->set_eye(2.8125, 0, 1000);   
			pinhole_ptr->set_lookat(2.8125, 0, 0);
			pinhole_ptr->set_view_distance(50000.0);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_ka(0.0);
			dielectric_ptr->set_kd(0.0); 
			dielectric_ptr->set_ks(0.0);    
			dielectric_ptr->set_exp(2000);
			dielectric_ptr->set_eta_in(1.5);   
			dielectric_ptr->set_eta_out(1.0);
			dielectric_ptr->set_cf_in(RGBColor(0.65, 0.45, 0));   // orange
			dielectric_ptr->set_cf_out(1.0);
	
	
			// a row of spheres
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(0), 3.0);
			sphere_ptr1->set_material(dielectric_ptr);
			add_object(sphere_ptr1);
	
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(4.5, 0, 0), 1.5);
			sphere_ptr2->set_material(dielectric_ptr);
			add_object(sphere_ptr2);
	
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(6.75, 0, 0), 0.75);
			sphere_ptr3->set_material(dielectric_ptr);
			add_object(sphere_ptr3);
	
			Sphere* sphere_ptr4 = new Sphere(Point3D(7.875, 0, 0), 0.375);
			sphere_ptr4->set_material(dielectric_ptr);
			add_object(sphere_ptr4);
	
			Sphere* sphere_ptr5 = new Sphere(Point3D(8.4375, 0, 0), 0.1875);
			sphere_ptr5->set_material(dielectric_ptr);
			add_object(sphere_ptr5);
			break;
		}
	case 304:
		{
			//28.11a
			int num_samples = 25;  
	
			vp.set_hres(600);	 		
			vp.set_vres(600);
			vp.set_max_depth(6);  
			vp.set_samples(num_samples);
	
			background_color = white;
	
			tracer_ptr = new Whitted(this);
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 2, 20);  
			pinhole_ptr->set_lookat(0.25, 4, 0);
			pinhole_ptr->set_view_distance(1275.0); 	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
		
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(2, 3, 0.5);
			light_ptr->scale_radiance(3.0);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// lens
	
			RGBColor glass_color(0.65, 0.45, 0);   // orange 	for Figure 28.11(a)
		//	RGBColor glass_color(0.0, 0.5, 0.5);   // cyan		for Figure 28.11(b)
	
			// extra imgages
	
		//	RGBColor glass_color(0.5, 0.0, 0.5);   // majenta
		//	RGBColor glass_color(0, 0.65, 0.35);   // blue-green
		//	RGBColor glass_color(0.0, 0.35, 0.65); // blue

	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_eta_in(1.5);				// glass
			glass_ptr->set_eta_out(1.0);			// air
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(RGBColor(1, 1, 1)); 
	

			double radius 		= 4.0;
			double thickness 	= 2.0;
		//	double min_distance = 0.35;  			// for cyan
			double min_distance = 0.1;   			// for all other colours
	

			Instance* concave_lens_ptr = new Instance(new ConcaveLens(radius, thickness, min_distance));
			concave_lens_ptr->set_material(glass_ptr);
			concave_lens_ptr->rotate_x(90);
			concave_lens_ptr->translate(0.0, radius, 0.0);
			add_object(concave_lens_ptr);
	
	
			// plane with checker
	
			PlaneChecker* plane_checker_ptr = new PlaneChecker;
			plane_checker_ptr->set_size(3);		
			plane_checker_ptr->set_outline_width(0.4);
			plane_checker_ptr->set_color1(white);
			plane_checker_ptr->set_color2(white);  
			plane_checker_ptr->set_outline_color(0.25); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.65);
			sv_matte_ptr->set_cd(plane_checker_ptr);

			Plane* plane_ptr = new Plane(Point3D(0, 0, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			plane_ptr->set_shadows(false);
			add_object(plane_ptr);	
			break;
		}
	case 305:
		{
			//28.11b
			int num_samples = 25;  
	
			vp.set_hres(600);	 		
			vp.set_vres(600);
			vp.set_max_depth(6);  
			vp.set_samples(num_samples);
	
			background_color = white;
	
			tracer_ptr = new Whitted(this);
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 2, 20);  
			pinhole_ptr->set_lookat(0.25, 4, 0);
			pinhole_ptr->set_view_distance(1275.0); 	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
		
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(2, 3, 0.5);
			light_ptr->scale_radiance(3.0);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// lens
	
//			RGBColor glass_color(0.65, 0.45, 0);   // orange 	for Figure 28.11(a)
			RGBColor glass_color(0.0, 0.5, 0.5);   // cyan		for Figure 28.11(b)
	
			// extra imgages
	
		//	RGBColor glass_color(0.5, 0.0, 0.5);   // majenta
		//	RGBColor glass_color(0, 0.65, 0.35);   // blue-green
		//	RGBColor glass_color(0.0, 0.35, 0.65); // blue

	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_eta_in(1.5);				// glass
			glass_ptr->set_eta_out(1.0);			// air
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(RGBColor(1, 1, 1)); 
	

			double radius 		= 4.0;
			double thickness 	= 2.0;
		//	double min_distance = 0.35;  			// for cyan
			double min_distance = 0.1;   			// for all other colours
	

			Instance* concave_lens_ptr = new Instance(new ConcaveLens(radius, thickness, min_distance));
			concave_lens_ptr->set_material(glass_ptr);
			concave_lens_ptr->rotate_x(90);
			concave_lens_ptr->translate(0.0, radius, 0.0);
			add_object(concave_lens_ptr);
	
	
			// plane with checker
	
			PlaneChecker* plane_checker_ptr = new PlaneChecker;
			plane_checker_ptr->set_size(3);		
			plane_checker_ptr->set_outline_width(0.4);
			plane_checker_ptr->set_color1(white);
			plane_checker_ptr->set_color2(white);  
			plane_checker_ptr->set_outline_color(0.25); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.65);
			sv_matte_ptr->set_cd(plane_checker_ptr);

			Plane* plane_ptr = new Plane(Point3D(0, 0, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			plane_ptr->set_shadows(false);
			add_object(plane_ptr);	
			break;
		}
	case 306:
		{
			//28.12a
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny69K.ply").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);	
			vp.set_max_depth(2);			
	
			background_color = white;
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);  
			pinhole_ptr->set_lookat(-0.4, 0.6, 0);    
			pinhole_ptr->set_view_distance(15000.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// transparent bunny
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_ka(0.0);
			dielectric_ptr->set_kd(0.0); 
			dielectric_ptr->set_ks(0.2);     
			dielectric_ptr->set_exp(2000.0);
			dielectric_ptr->set_eta_in(1.5);   
			dielectric_ptr->set_eta_out(1.0);
			dielectric_ptr->set_cf_in(RGBColor(0.65, 0.45, 0));   // orange
			dielectric_ptr->set_cf_out(white);
		
		//	const char* file_name = "Bunny4K.ply"; 		// 4000 triangles
		//	const char* file_name = "Bunny10K.ply"; 	// 10000 triangles
		//	const char* file_name = "Bunny16K.ply"; 	// 16000 triangles
		//	const char* file_name = "Bunny69K.ply"; 	// 69000 triangles


			Grid* bunny_ptr = new Grid(new Mesh);
		//	bunny_ptr->reverse_mesh_normals();				// you must use this for the 10K model
		//	bunny_ptr->read_flat_triangles(file_name);		
			bunny_ptr->read_smooth_triangles(QString(plyfile+"Stanford Bunny\\Bunny69K.ply").toLatin1().data());
			bunny_ptr->set_material(dielectric_ptr); 	
			bunny_ptr->setup_cells();

			Instance* big_bunny_ptr = new Instance(bunny_ptr);
			big_bunny_ptr->scale(20.0);
			big_bunny_ptr->translate(0, -1.5, 0.0);
			add_object(big_bunny_ptr);
			break;
		}
	case 307:
		{
			//28.12b
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny69K.ply").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);	
			vp.set_max_depth(10);		
	
			background_color = white;
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);  
			pinhole_ptr->set_lookat(-0.4, 0.6, 0);    
			pinhole_ptr->set_view_distance(15000.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// transparent bunny
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_ka(0.0);
			dielectric_ptr->set_kd(0.0); 
			dielectric_ptr->set_ks(0.2);     
			dielectric_ptr->set_exp(2000.0);
			dielectric_ptr->set_eta_in(1.5);   
			dielectric_ptr->set_eta_out(1.0);
			dielectric_ptr->set_cf_in(RGBColor(0.65, 0.45, 0));   // orange
			dielectric_ptr->set_cf_out(white);
		
		//	const char* file_name = "Bunny4K.ply"; 		// 4000 triangles
		//	const char* file_name = "Bunny10K.ply"; 	// 10000 triangles
		//	const char* file_name = "Bunny16K.ply"; 	// 16000 triangles
			const char* file_name = "Bunny69K.ply"; 	// 69000 triangles


			Grid* bunny_ptr = new Grid(new Mesh);
		//	bunny_ptr->reverse_mesh_normals();				// you must use this for the 10K model
		//	bunny_ptr->read_flat_triangles(file_name);		
			bunny_ptr->read_smooth_triangles(QString(plyfile+"Stanford Bunny\\Bunny69K.ply").toLatin1().data());
			bunny_ptr->set_material(dielectric_ptr); 	
			bunny_ptr->setup_cells();

			Instance* big_bunny_ptr = new Instance(bunny_ptr);
			big_bunny_ptr->scale(20.0);
			big_bunny_ptr->translate(0, -1.5, 0.0);
			add_object(big_bunny_ptr);
			break;
		}
	case 308:
		{
			//28.12c
			if( !CheckFile(QString(plyfile+"Horse97K.ply").toLatin1().data()))
				return;

			int num_samples = 16;

			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);	
			vp.set_max_depth(10);		
	
			background_color = white;
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);  
			pinhole_ptr->set_lookat(0);    
			pinhole_ptr->set_view_distance(3600);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			// transparent horse
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_ka(0.0);
			dielectric_ptr->set_kd(0.0); 
			dielectric_ptr->set_ks(0.2);    
			dielectric_ptr->set_exp(2000.0);
			dielectric_ptr->set_eta_in(1.5);   
			dielectric_ptr->set_eta_out(1.0);
			dielectric_ptr->set_cf_in(RGBColor(0.65, 0.65, 0.1));   // lemon
			dielectric_ptr->set_cf_out(white);	
	
			const char* file_name = "Horse97K.ply"; 	

			Grid* horse_ptr = new Grid(new Mesh);
		//	horse_ptr->read_flat_triangles(file_name);	
			horse_ptr->read_smooth_triangles(QString(plyfile+"Horse97K.ply").toLatin1().data());	
			horse_ptr->set_material(dielectric_ptr); 	
			horse_ptr->setup_cells();

			Instance* big_horse_ptr = new Instance(horse_ptr);
			big_horse_ptr->scale(20.0);
			big_horse_ptr->translate(0, 0, 0);
			add_object(big_horse_ptr);
			break;
		}
	case 309:
		{
			//28.13a
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny4K.ply").toLatin1().data()))
				return;

			int num_samples = 16;

			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(1);	
			vp.set_max_depth(9);		
	
			background_color = white;
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
	
			tracer_ptr = new Whitted(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);  
			pinhole_ptr->set_lookat(-0.15, -0.45, 0);    
			pinhole_ptr->set_view_distance(30000.0);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// directional light 
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1); 
			light_ptr->scale_radiance(5.0);
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
	
			// transparent bunny
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_ka(0.0);
			dielectric_ptr->set_kd(0.0); 
			dielectric_ptr->set_ks(0.2);    
			dielectric_ptr->set_exp(2000.0);
			dielectric_ptr->set_eta_in(1.5);   
			dielectric_ptr->set_eta_out(1.0);
			dielectric_ptr->set_cf_in(RGBColor(0.35, 0.65, 0.45));   // green
			dielectric_ptr->set_cf_out(white);
		
			const char* file_name = "Bunny4K.ply"; 				// for Figure 28.13(a)
		//	const char* file_name = "Bunny16K.ply"; 			// for Figure 28.13(b)
		//	const char* file_name = "Bunny69K.ply"; 			// for Figure 28.13(c)


			Grid* bunny_ptr = new Grid(new Mesh);
		//	bunny_ptr->read_flat_triangles(file_name);			// for Figure 28.13(b)
			bunny_ptr->read_smooth_triangles(QString(plyfile+"Stanford Bunny\\Bunny4K.ply").toLatin1().data());		// for Figures 28.13 (a) & (c)	
			bunny_ptr->set_material(dielectric_ptr); 	
			bunny_ptr->setup_cells();

			Instance* big_bunny_ptr = new Instance(bunny_ptr);
			big_bunny_ptr->scale(10.0);
			big_bunny_ptr->translate(0, -1.5, 0.0);
			add_object(big_bunny_ptr);
	
	
			// vertical checker plane
	
			PlaneChecker* plane_checker_ptr = new PlaneChecker;
			plane_checker_ptr->set_size(0.75);		
			plane_checker_ptr->set_outline_width(0.1);
			plane_checker_ptr->set_color1(white);
			plane_checker_ptr->set_color2(white);  
			plane_checker_ptr->set_outline_color(black); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.65);
			sv_matte_ptr->set_cd(plane_checker_ptr);
	
			// my PlaneChecker texture is only defined for planes parallel to the (x, z) plane
			// necessitating the use of an instance for a vertical plane

			Instance* plane_ptr = new Instance(new Plane(Point3D(0), Normal(0, 1, 0)));
			plane_ptr->set_material(sv_matte_ptr);
			plane_ptr->rotate_x(90);
			plane_ptr->translate(0, 0, -2);
			plane_ptr->set_shadows(false);
			add_object(plane_ptr);	
			break;
		}
	case 310:
		{
			//28.13b
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data()))
				return;

			int num_samples = 16;

			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(1);	
			vp.set_max_depth(9);		
	
			background_color = white;
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
	
			tracer_ptr = new Whitted(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);  
			pinhole_ptr->set_lookat(-0.15, -0.45, 0);    
			pinhole_ptr->set_view_distance(30000.0);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// directional light 
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1); 
			light_ptr->scale_radiance(5.0);
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
	
			// transparent bunny
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_ka(0.0);
			dielectric_ptr->set_kd(0.0); 
			dielectric_ptr->set_ks(0.2);    
			dielectric_ptr->set_exp(2000.0);
			dielectric_ptr->set_eta_in(1.5);   
			dielectric_ptr->set_eta_out(1.0);
			dielectric_ptr->set_cf_in(RGBColor(0.35, 0.65, 0.45));   // green
			dielectric_ptr->set_cf_out(white);
		
			const char* file_name = "Bunny4K.ply"; 				// for Figure 28.13(a)
		//	const char* file_name = "Bunny16K.ply"; 			// for Figure 28.13(b)
		//	const char* file_name = "Bunny69K.ply"; 			// for Figure 28.13(c)


			Grid* bunny_ptr = new Grid(new Mesh);
			bunny_ptr->read_flat_triangles(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data());			// for Figure 28.13(b)
			//bunny_ptr->read_smooth_triangles(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data());		// for Figures 28.13 (a) & (c)	
			bunny_ptr->set_material(dielectric_ptr); 	
			bunny_ptr->setup_cells();

			Instance* big_bunny_ptr = new Instance(bunny_ptr);
			big_bunny_ptr->scale(10.0);
			big_bunny_ptr->translate(0, -1.5, 0.0);
			add_object(big_bunny_ptr);
	
	
			// vertical checker plane
	
			PlaneChecker* plane_checker_ptr = new PlaneChecker;
			plane_checker_ptr->set_size(0.75);		
			plane_checker_ptr->set_outline_width(0.1);
			plane_checker_ptr->set_color1(white);
			plane_checker_ptr->set_color2(white);  
			plane_checker_ptr->set_outline_color(black); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.65);
			sv_matte_ptr->set_cd(plane_checker_ptr);
	
			// my PlaneChecker texture is only defined for planes parallel to the (x, z) plane
			// necessitating the use of an instance for a vertical plane

			Instance* plane_ptr = new Instance(new Plane(Point3D(0), Normal(0, 1, 0)));
			plane_ptr->set_material(sv_matte_ptr);
			plane_ptr->rotate_x(90);
			plane_ptr->translate(0, 0, -2);
			plane_ptr->set_shadows(false);
			add_object(plane_ptr);	
			break;
		}
	case 311:
		{
			//28.13c
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny69K.ply").toLatin1().data()))
				return;

			int num_samples = 16;

			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(1);	
			vp.set_max_depth(9);		
	
			background_color = white;
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
	
			tracer_ptr = new Whitted(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);  
			pinhole_ptr->set_lookat(-0.15, -0.45, 0);    
			pinhole_ptr->set_view_distance(30000.0);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// directional light 
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1); 
			light_ptr->scale_radiance(5.0);
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
	
			// transparent bunny
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_ka(0.0);
			dielectric_ptr->set_kd(0.0); 
			dielectric_ptr->set_ks(0.2);    
			dielectric_ptr->set_exp(2000.0);
			dielectric_ptr->set_eta_in(1.5);   
			dielectric_ptr->set_eta_out(1.0);
			dielectric_ptr->set_cf_in(RGBColor(0.35, 0.65, 0.45));   // green
			dielectric_ptr->set_cf_out(white);
		
			const char* file_name = "Bunny4K.ply"; 				// for Figure 28.13(a)
		//	const char* file_name = "Bunny16K.ply"; 			// for Figure 28.13(b)
		//	const char* file_name = "Bunny69K.ply"; 			// for Figure 28.13(c)


			Grid* bunny_ptr = new Grid(new Mesh);
			//bunny_ptr->read_flat_triangles(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data());			// for Figure 28.13(b)
			bunny_ptr->read_smooth_triangles(QString(plyfile+"Stanford Bunny\\Bunny69K.ply").toLatin1().data());		// for Figures 28.13 (a) & (c)	
			bunny_ptr->set_material(dielectric_ptr); 	
			bunny_ptr->setup_cells();

			Instance* big_bunny_ptr = new Instance(bunny_ptr);
			big_bunny_ptr->scale(10.0);
			big_bunny_ptr->translate(0, -1.5, 0.0);
			add_object(big_bunny_ptr);
	
	
			// vertical checker plane
	
			PlaneChecker* plane_checker_ptr = new PlaneChecker;
			plane_checker_ptr->set_size(0.75);		
			plane_checker_ptr->set_outline_width(0.1);
			plane_checker_ptr->set_color1(white);
			plane_checker_ptr->set_color2(white);  
			plane_checker_ptr->set_outline_color(black); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.65);
			sv_matte_ptr->set_cd(plane_checker_ptr);
	
			// my PlaneChecker texture is only defined for planes parallel to the (x, z) plane
			// necessitating the use of an instance for a vertical plane

			Instance* plane_ptr = new Instance(new Plane(Point3D(0), Normal(0, 1, 0)));
			plane_ptr->set_material(sv_matte_ptr);
			plane_ptr->rotate_x(90);
			plane_ptr->translate(0, 0, -2);
			plane_ptr->set_shadows(false);
			add_object(plane_ptr);	
			break;
		}
	case 312:
		{
			//28.14
			if( !CheckFile(QString(plyfile+"Horse97K.ply").toLatin1().data()))
				return;

			int num_samples = 16;

			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);	
			vp.set_max_depth(9);		
	
			background_color = white;
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);  
			pinhole_ptr->set_lookat(0, -1.5, 0);    
			pinhole_ptr->set_view_distance(15000.0);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
		
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1); 
			light_ptr->scale_radiance(5.0);
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
	
			// transparent horse
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_ka(0.0);
			dielectric_ptr->set_kd(0.0); 
			dielectric_ptr->set_ks(0.2);    
			dielectric_ptr->set_exp(2000.0);
			dielectric_ptr->set_eta_in(1.5);   
			dielectric_ptr->set_eta_out(1.0);
			dielectric_ptr->set_cf_in(RGBColor(0.35, 0.65, 0.45));   // green
			dielectric_ptr->set_cf_out(white);
	
			const char* file_name = "Horse97K.ply"; 	

			Grid* horse_ptr = new Grid(new Mesh);
		//	horse_ptr->read_flat_triangles(file_name);	
			horse_ptr->read_smooth_triangles(QString(plyfile+"Horse97K.ply").toLatin1().data());	
			horse_ptr->set_material(dielectric_ptr); 	
			horse_ptr->setup_cells();

			Instance* big_horse_ptr = new Instance(horse_ptr);
			big_horse_ptr->scale(5.0);
			big_horse_ptr->translate(0, -1.5, 0.0);
			add_object(big_horse_ptr);
	
	
			// vertical checker plane
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(1.0);		
			checker_ptr->set_color1(white);
			checker_ptr->set_color2(0.75);  
	
			PlaneChecker* plane_checker_ptr = new PlaneChecker;
			plane_checker_ptr->set_size(1.5);		
			plane_checker_ptr->set_outline_width(0.2);
			plane_checker_ptr->set_color1(white);
			plane_checker_ptr->set_color2(white);  
			plane_checker_ptr->set_outline_color(black); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.65);
			sv_matte_ptr->set_cd(plane_checker_ptr);

			Instance* plane_ptr = new Instance(new Plane(Point3D(0), Normal(0, 1, 0)));
			plane_ptr->set_material(sv_matte_ptr);
			plane_ptr->rotate_x(90);
			plane_ptr->translate(0, 0, -4);
			plane_ptr->set_shadows(false);
			add_object(plane_ptr);	
			break;
		}
	case 313:
		{
			//28.15a
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(7);

			background_color = RGBColor(0.0, 0.3, 0.25);  // blue green
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(5, 3, 10);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(700);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);

			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 1, 0);    // straight down
			light_ptr->scale_radiance(7.5);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	

			// nested spheres
	
			RGBColor glass_color(0.95, 0.95, 1);  	// faint blue
			RGBColor diamond_color(1, 1, 0.8);  	// lemon
			RGBColor water_color(1, 0.5, 1);  		// mauve
	
			Point3D center(0.5, 0, 0.5);  			// common centre
	
	
			// outer sphere - glass
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_ks(0.1);   
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_eta_in(1.5); 			// water
			glass_ptr->set_eta_out(1.0);			// air
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(white);
			
			Sphere* sphere_ptr1 = new Sphere(center, 3.5);
			sphere_ptr1->set_material(glass_ptr);
			add_object(sphere_ptr1);
	
	
			// middle sphere - diamond
	
			Dielectric* diamond_ptr = new Dielectric;
			diamond_ptr->set_ks(0.1);    
			diamond_ptr->set_exp(2000.0);
			diamond_ptr->set_eta_in(2.42); 			// diamond
			diamond_ptr->set_eta_out(1.5);			// glass
			diamond_ptr->set_cf_in(diamond_color);
			diamond_ptr->set_cf_out(glass_color);
	
			Sphere* sphere_ptr2 = new Sphere(center, 2.0);
			sphere_ptr2->set_material(diamond_ptr);
			add_object(sphere_ptr2);
	
	
			// inner sphere - water
	
			Dielectric* water_ptr = new Dielectric;
			water_ptr->set_ks(0.1);  
			water_ptr->set_exp(2000.0);
			water_ptr->set_eta_in(1.33); 			// water
			water_ptr->set_eta_out(2.42); 			// diamond
			water_ptr->set_cf_in(water_color);
			water_ptr->set_cf_out(diamond_color);
	
			Sphere* sphere_ptr3 = new Sphere(center, 0.6);
			sphere_ptr3->set_material(water_ptr);
			add_object(sphere_ptr3);
	
	
			// ground plane

			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(2.0);
			checker_ptr->set_color1(0.25); 
			checker_ptr->set_color2(white);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -6.5, 0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);

			break;
		}
	case 314:
		{
			//28.15b
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(7);

			background_color = RGBColor(0.0, 0.3, 0.25);  // blue green
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0.5, 40.0, 0.5);
			pinhole_ptr->set_lookat(0.5, 0.0, 0.5);
			pinhole_ptr->set_view_distance(3000.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);

			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 1, 0);      // straight down
			light_ptr->scale_radiance(7.5);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	

			// nested spheres
	
			RGBColor glass_color(0.95, 0.95, 1);  	// faint blue
			RGBColor diamond_color(1, 1, 0.8);  	// lemon
			RGBColor water_color(1, 0.5, 1);  		// mauve
	
			Point3D center(0.5, 0, 0.5);  			// common centre
	
	
			// outer sphere - glass
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_ks(0.1);   
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_eta_in(1.5); 			// water
			glass_ptr->set_eta_out(1.0);			// air
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(white);
			
			Sphere* sphere_ptr1 = new Sphere(center, 3.5);
			sphere_ptr1->set_material(glass_ptr);
			add_object(sphere_ptr1);
	
	
			// middle sphere - diamond
	
			Dielectric* diamond_ptr = new Dielectric;
			diamond_ptr->set_ks(0.1);    
			diamond_ptr->set_exp(2000.0);
			diamond_ptr->set_eta_in(2.42); 			// diamond
			diamond_ptr->set_eta_out(1.5);			// glass
			diamond_ptr->set_cf_in(diamond_color);
			diamond_ptr->set_cf_out(glass_color);
	
			Sphere* sphere_ptr2 = new Sphere(center, 2.0);
			sphere_ptr2->set_material(diamond_ptr);
			add_object(sphere_ptr2);
	
	
			// inner sphere - water
	
			Dielectric* water_ptr = new Dielectric;
			water_ptr->set_ks(0.1);  
			water_ptr->set_exp(2000.0);
			water_ptr->set_eta_in(1.33); 			// water
			water_ptr->set_eta_out(2.42); 			// diamond
			water_ptr->set_cf_in(water_color);
			water_ptr->set_cf_out(diamond_color);
	
			Sphere* sphere_ptr3 = new Sphere(center, 0.6);
			sphere_ptr3->set_material(water_ptr);
			add_object(sphere_ptr3);
	
	
			// ground plane

			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(2.0);
			checker_ptr->set_color1(0.25); 
			checker_ptr->set_color2(white);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -6.5, 0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 315:
		{
			//28.15c
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(7);

			background_color = RGBColor(0.0, 0.3, 0.25);  // blue green
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0.5, 40.0, 0.5);
			pinhole_ptr->set_lookat(0.5, 0.0, 0.5);
			pinhole_ptr->set_view_distance(3000.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);

			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 1, 0);      // straight down
			light_ptr->scale_radiance(7.5);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	

			// nested spheres
	
			RGBColor glass_color(0.95, 0.95, 1);  	// faint blue
			RGBColor diamond_color(1, 1, 0.8);  	// lemon
			RGBColor water_color(1, 0.5, 1);  		// mauve
	
			Point3D center(0.5, 0, 0.5);  			// common centre
	
	
			// outer sphere - glass
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_ks(0.1);   
			glass_ptr->set_exp(2000.0);
			glass_ptr->set_eta_in(1.5); 			// water
			glass_ptr->set_eta_out(1.0);			// air
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(white);
			
			Sphere* sphere_ptr1 = new Sphere(center, 3.5);
			sphere_ptr1->set_material(glass_ptr);
		//	add_object(sphere_ptr1);
	
	
			// middle sphere - diamond
	
			Dielectric* diamond_ptr = new Dielectric;
			diamond_ptr->set_ks(0.1);    
			diamond_ptr->set_exp(2000.0);
			diamond_ptr->set_eta_in(2.42); 			// diamond
			diamond_ptr->set_eta_out(1.0);			// air
			diamond_ptr->set_cf_in(diamond_color);
			diamond_ptr->set_cf_out(white);
	
			Sphere* sphere_ptr2 = new Sphere(center, 2.0);
			sphere_ptr2->set_material(diamond_ptr);
			add_object(sphere_ptr2);
	
	
			// inner sphere - water
	
			Dielectric* water_ptr = new Dielectric;
			water_ptr->set_ks(0.1);  
			water_ptr->set_exp(2000.0);
			water_ptr->set_eta_in(1.33); 			// water
			water_ptr->set_eta_out(2.42); 			// diamond
			water_ptr->set_cf_in(water_color);
			water_ptr->set_cf_out(diamond_color);
	
			Sphere* sphere_ptr3 = new Sphere(center, 0.6);
			sphere_ptr3->set_material(water_ptr);
		//	add_object(sphere_ptr3);
	
	
			// ground plane

			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(2.0);
			checker_ptr->set_color1(0.25); 
			checker_ptr->set_color2(white);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.35);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -6.5, 0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 316:
		{
			//28.16
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny4K.ply").toLatin1().data()))
				return;

			int num_samples = 100;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);	
			vp.set_max_depth(9);		
	
			background_color = RGBColor(0.5);
	
			tracer_ptr = new AreaLighting(this);
	
			Ambient* ambient_ptr = new Ambient;
			set_ambient_light(ambient_ptr);
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-4, 4, 20);  
			pinhole_ptr->set_lookat(-0.2, -0.5, 0);     
			pinhole_ptr->set_view_distance(6000.0);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	

			// rectangular area light
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(40.0);		
			emissive_ptr->set_ce(white);
	
			Point3D center(5, 6, 10);
			double width = 4.0;
			double height = 5.0;
	
			Point3D p0(-0.5 * width, center.y - 0.5 * height, center.z);
			Vector3D a(width, 0.0, 0.0);
			Vector3D b(0.0, height, 0.0);
			Normal normal(0, 0, -1);
	
			TRectangle* rectangle_ptr = new TRectangle(p0, a, b, normal);
			rectangle_ptr->set_material(emissive_ptr);
			rectangle_ptr->set_sampler(new MultiJittered(num_samples));
			rectangle_ptr->set_shadows(false);
			add_object(rectangle_ptr);	
	
			AreaLight* area_light_ptr = new AreaLight;
			area_light_ptr->set_object(rectangle_ptr);
			area_light_ptr->set_shadows(true);
			add_light(area_light_ptr);

	
			// transparent bunny
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_ka(0.0);
			dielectric_ptr->set_kd(0.0); 
			dielectric_ptr->set_ks(0.2);     
			dielectric_ptr->set_exp(2000.0);
			dielectric_ptr->set_eta_in(1.5);   
			dielectric_ptr->set_eta_out(1.0);
			dielectric_ptr->set_cf_in(RGBColor(0.75, 0.45, 0));   // orange
			dielectric_ptr->set_cf_out(white);
		
			const char* file_name = "Bunny4K.ply"; 	

			Mesh* mesh_ptr = new Mesh;
			Grid* bunny_ptr = new Grid(mesh_ptr);
			bunny_ptr->read_smooth_triangles(QString(plyfile+"Stanford Bunny\\Bunny4K.ply").toLatin1().data());	
			bunny_ptr->set_material(dielectric_ptr); 	
			bunny_ptr->setup_cells();

			Instance* big_bunny_ptr = new Instance(bunny_ptr);
			big_bunny_ptr->scale(10.0);
			big_bunny_ptr->translate(0, -1.5, 0.0);
			add_object(big_bunny_ptr);
	
	
			PlaneChecker* plane_checker_ptr = new PlaneChecker;
			plane_checker_ptr->set_size(0.25);		
			plane_checker_ptr->set_outline_width(0.02);
			plane_checker_ptr->set_color1(0.75);
			plane_checker_ptr->set_color2(0.75);  
			plane_checker_ptr->set_outline_color(black); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.15);
			sv_matte_ptr->set_kd(0.65);
			sv_matte_ptr->set_cd(plane_checker_ptr);
	
			// ground plane	
	
			Plane* plane_ptr1 = new Plane(Point3D(0, -1.175, 0), Normal(0, 1, 0));
			plane_ptr1->set_material(sv_matte_ptr);
			plane_ptr1->set_shadows(false);
			add_object(plane_ptr1);
		
			// back plane

			Instance* plane_ptr2 = new Instance(new Plane(Point3D(0), Normal(0, 1, 0)));
			plane_ptr2->set_material(sv_matte_ptr);
			plane_ptr2->rotate_x(90);
			plane_ptr2->translate(0, 0, -2);
			plane_ptr2->set_shadows(false);
			add_object(plane_ptr2);
			break;
		}
	case 317:
		{
			//28.20a
			int num_samples = 25;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(2);				// for Figure 28.20(a)
		//	vp.set_max_depth(3);				// for Figure 28.20(b)
		//	vp.set_max_depth(4);				// for Figure 28.20(c)
	
			background_color = RGBColor(0.9, 0.9, 1);  // pale blue
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 3); 
			pinhole_ptr->set_lookat(0.0); 
			pinhole_ptr->set_view_distance(450);	
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(10, 20, 20);
			light_ptr->scale_radiance(15.0);
			add_light(light_ptr);
	
	
			// transparent cube
	
			RGBColor glass_color(0.64, 0.98, 0.88);	// light cyan
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_exp(2000.0);  
			glass_ptr->set_eta_in(1.5);					// glass
			glass_ptr->set_eta_out(1.0);				// air
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(white); 
			glass_ptr->set_shadows(false);
		
			Box* box_ptr = new Box(Point3D(-1.0), Point3D(1.0));
			box_ptr->set_material(glass_ptr);
			add_object(box_ptr);
		
	
			// plane
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4.0); 
			checker_ptr->set_color1(1, 1, 0.4);    		// yellow
			checker_ptr->set_color2(1, 0.5, 0);   		// orange
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.1);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -10.1, 0), Normal(0, 1, 0)); 
			plane_ptr->set_material(sv_matte_ptr);	
			add_object(plane_ptr);
			break;
		}
	case 318:
		{
			//28.20b
			int num_samples = 25;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
		//	vp.set_max_depth(2);				// for Figure 28.20(a)
			vp.set_max_depth(3);				// for Figure 28.20(b)
		//	vp.set_max_depth(4);				// for Figure 28.20(c)
	
			background_color = RGBColor(0.9, 0.9, 1);  // pale blue
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 3); 
			pinhole_ptr->set_lookat(0.0); 
			pinhole_ptr->set_view_distance(450);	
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(10, 20, 20);
			light_ptr->scale_radiance(15.0);
			add_light(light_ptr);
	
	
			// transparent cube
	
			RGBColor glass_color(0.64, 0.98, 0.88);	// light cyan
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_exp(2000.0);  
			glass_ptr->set_eta_in(1.5);					// glass
			glass_ptr->set_eta_out(1.0);				// air
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(white); 
			glass_ptr->set_shadows(false);
		
			Box* box_ptr = new Box(Point3D(-1.0), Point3D(1.0));
			box_ptr->set_material(glass_ptr);
			add_object(box_ptr);
		
	
			// plane
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4.0); 
			checker_ptr->set_color1(1, 1, 0.4);    		// yellow
			checker_ptr->set_color2(1, 0.5, 0);   		// orange
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.1);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -10.1, 0), Normal(0, 1, 0)); 
			plane_ptr->set_material(sv_matte_ptr);	
			add_object(plane_ptr);
			break;
		}
	case 319:
		{
			//28.20c
			int num_samples = 25;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
		//	vp.set_max_depth(2);				// for Figure 28.20(a)
		//	vp.set_max_depth(3);				// for Figure 28.20(b)
			vp.set_max_depth(4);				// for Figure 28.20(c)
	
			background_color = RGBColor(0.9, 0.9, 1);  // pale blue
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 3); 
			pinhole_ptr->set_lookat(0.0); 
			pinhole_ptr->set_view_distance(450);	
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(10, 20, 20);
			light_ptr->scale_radiance(15.0);
			add_light(light_ptr);
	
	
			// transparent cube
	
			RGBColor glass_color(0.64, 0.98, 0.88);	// light cyan
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_exp(2000.0);  
			glass_ptr->set_eta_in(1.5);					// glass
			glass_ptr->set_eta_out(1.0);				// air
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(white); 
			glass_ptr->set_shadows(false);
		
			Box* box_ptr = new Box(Point3D(-1.0), Point3D(1.0));
			box_ptr->set_material(glass_ptr);
			add_object(box_ptr);
		
	
			// plane
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4.0); 
			checker_ptr->set_color1(1, 1, 0.4);    		// yellow
			checker_ptr->set_color2(1, 0.5, 0);   		// orange
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.1);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -10.1, 0), Normal(0, 1, 0)); 
			plane_ptr->set_material(sv_matte_ptr);	
			add_object(plane_ptr);
			break;
		}
	case 320:
		{
			//28.21a
			int num_samples = 25;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(5);
	
			background_color = RGBColor(0.9, 0.9, 1);  // pale blue
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 1.5, 3); 
			pinhole_ptr->set_lookat(0.0); 
			pinhole_ptr->set_view_distance(495.0);	
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(10, 20, 20);
			light_ptr->scale_radiance(15.0);
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
	
			// matte sphere inside cube
		
			Matte* matte_ptr = new Matte;			
			matte_ptr->set_ka(0.5); 
			matte_ptr->set_kd(0.5);
			matte_ptr->set_cd(0.0, 0.25, 1.0); 	 
	
			Sphere*	sphere_ptr = new Sphere(Point3D(0.0, -0.25, -1.0), 0.5);
			sphere_ptr->set_material(matte_ptr); 
			add_object(sphere_ptr);
	
	
			// transparent cube
	
			RGBColor glass_color(0.64, 0.98, 0.88);	// light cyan
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_exp(2000.0);  
			glass_ptr->set_eta_in(1.5);					// glass
			glass_ptr->set_eta_out(1.0);				// air
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(white); 
			glass_ptr->set_shadows(false);
		
			Box* box_ptr = new Box(Point3D(-1.0), Point3D(1.0));
			box_ptr->set_material(glass_ptr);
			add_object(box_ptr);
		
	
			// plane
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4.0); 
			checker_ptr->set_color1(1, 1, 0.4);    		// yellow
			checker_ptr->set_color2(1, 0.5, 0);   		// orange
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.1);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -10.1, 0), Normal(0, 1, 0)); 
			plane_ptr->set_material(sv_matte_ptr);	
			add_object(plane_ptr);
			break;
		}
	case 321:
		{
			//28.21b
			int num_samples = 25;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(5);
	
			background_color = RGBColor(0.9, 0.9, 1);  // pale blue
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 1.5, 4); 
			pinhole_ptr->set_lookat(0.0); 
			pinhole_ptr->set_view_distance(675.0);
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(10, 20, 20);
			light_ptr->scale_radiance(7.5);
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
	
			// matte sphere inside cube
		
			Matte* matte_ptr = new Matte;			
			matte_ptr->set_ka(0.5); 
			matte_ptr->set_kd(0.5);
			matte_ptr->set_cd(0.0, 0.25, 1.0); 	 
	
			Sphere*	sphere_ptr = new Sphere(Point3D(0.0, -0.25, -1.0), 0.5);
			sphere_ptr->set_material(matte_ptr); 
			add_object(sphere_ptr);
	
	
			// transparent cube
	
			RGBColor glass_color(0.64, 0.98, 0.88);	// light cyan
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_exp(2000.0);  
			glass_ptr->set_eta_in(1.5);					// glass
			glass_ptr->set_eta_out(1.33);				// water
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(white); 
			glass_ptr->set_shadows(false);
		
			Box* box_ptr = new Box(Point3D(-1.0), Point3D(1.0));
			box_ptr->set_material(glass_ptr);
			add_object(box_ptr);
		
	
			// plane
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4.0); 
			checker_ptr->set_color1(1, 1, 0.4);    		// yellow
			checker_ptr->set_color2(1, 0.5, 0);   		// orange
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.2);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -10.1, 0), Normal(0, 1, 0)); 
			plane_ptr->set_material(sv_matte_ptr);	
			add_object(plane_ptr);
			break;
		}
	case 322:
		{
			//28.22
			int num_samples = 9;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);    
			vp.set_max_depth(15);
		
			tracer_ptr = new Whitted(this);
	
			background_color = RGBColor(0.75);  
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(1.0);
			set_ambient_light(ambient_ptr);	

	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 12, 20); 
			pinhole_ptr->set_lookat(-3.75, 3, 0);     
			pinhole_ptr->set_view_distance(1500.0);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(20, 25, -20);  
			light_ptr1->scale_radiance(3.0);  
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			float c = 1.75;  // this allows us to adjust the filter color without changing the hue
			RGBColor glass_color(0.27*c, 0.49*c, 0.42*c);  

		
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_eta_in(1.50);		// glass
			glass_ptr->set_eta_out(1.0);		// air
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(white); 
	
			double 	thickness 	= 0.25;
			double 	height 		= 4.0;
			double 	delta 		= 1.0;			// length change of each box
		
			int 	num_boxes 	= 10;
			double 	x_min 		= -10.0;		// where the boxes start in the x direction
			double 	gap 		= 0.5;   		// gap between the boxes
	
			for (int j = 0; j < num_boxes; j++) {
				double length = thickness + j * delta;
				Point3D p0(x_min + j * (thickness + gap), 0.0, -length);
				Point3D p1(x_min + j * (thickness + gap) + thickness, height, 0.0);
		
				Box* box_ptr = new Box(p0, p1);     
				box_ptr->set_material(glass_ptr);
				add_object(box_ptr);
			}
	
	
			// plane
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.5);
			matte_ptr->set_kd(0.65);
			matte_ptr->set_cd(0.75);
	
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 323:
		{
			//28.25
			int num_samples = 1;  // this figure does not need antialiasing
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);	
			vp.set_max_depth(10);		
	
			background_color = black;
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 1000, 0);   
			pinhole_ptr->set_lookat(0);    
			pinhole_ptr->set_view_distance(200000.0);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
		
			// transparent box
		
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(1.5);   
			dielectric_ptr->set_eta_out(1.0);
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white);
	
			Point3D p0(-1.0, 0.0, -1.0);
			Point3D p1(1.0, 0.1, 1.0);
	
			Box* box_ptr1 = new Box(p0, p1);
			box_ptr1->set_material(dielectric_ptr);
			add_object(box_ptr1);
	
	
			// plane
		
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->set_ce(white);
			emissive_ptr->scale_radiance(1.0);
	
			Plane* plane_ptr = new Plane(Point3D(0.0, -4.0, 0.0), Normal(0, 1, 0));
			plane_ptr->set_material(emissive_ptr);
			add_object(plane_ptr);
			break;
		}
	case 324:
		{
			//28.26
			int num_samples = 16;
	
			vp.set_hres(200);	    
			vp.set_vres(200);
			vp.set_samples(num_samples);
			vp.set_max_depth(3);
	
			background_color = black;  
	
			tracer_ptr = new Whitted(this);
		
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);	

			// stereo camera 
	
			float vpd = 850.0; 

			Pinhole* left_pinhole_ptr = new Pinhole;
			left_pinhole_ptr->set_view_distance(vpd);
	
			Pinhole* right_pinhole_ptr = new Pinhole;
			right_pinhole_ptr->set_view_distance(vpd);
	
			StereoCamera* stereo_ptr = new StereoCamera;
			stereo_ptr->set_left_camera(left_pinhole_ptr);
			stereo_ptr->set_right_camera(right_pinhole_ptr);
			stereo_ptr->use_parallel_viewing();
		//	stereo_ptr->use_transverse_viewing();
			stereo_ptr->set_pixel_gap(5);
			stereo_ptr->set_eye(-9, 18, 22.5);    
			stereo_ptr->set_lookat(0.0);
			stereo_ptr->compute_uvw(); 
			stereo_ptr->set_stereo_angle(1.5);  // in degrees
			stereo_ptr->setup_cameras(); 
			set_camera(stereo_ptr);
	
	
			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(5.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.0);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.0);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// checker sphere
	
			// 2D sphere checker texture
	
			SphereChecker* checker_ptr1 = new SphereChecker;
			checker_ptr1->set_num_horizontal(12); 
			checker_ptr1->set_num_vertical(12);  
			checker_ptr1->set_horizontal_line_width(0.075);
			checker_ptr1->set_vertical_line_width(0.075);
			checker_ptr1->set_color1(white);
			checker_ptr1->set_color2(0.75);
			checker_ptr1->set_line_color(black);

			// spatially varying self-emissive material
	
			SV_Emissive* sv_emissive_ptr = new SV_Emissive;
			sv_emissive_ptr->scale_radiance(20.0);	
			sv_emissive_ptr->set_ce(checker_ptr1);		
		
			Sphere* sphere_ptr1 = new Sphere;
			sphere_ptr1->set_material(sv_emissive_ptr);   
	
			Instance* big_sphere_ptr = new Instance(sphere_ptr1);
			big_sphere_ptr->scale(30.0);
			big_sphere_ptr->translate(0, 50, 45);
			add_object(big_sphere_ptr);
	
	
			// transparent sphere with grid lines
	
			// emissive material for the grid lines 
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(0.85);
			emissive_ptr->set_ce(1, 0.7, 0);		// orange
	
	
			// dielectric material for the checkers
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_ks(0.2);
			glass_ptr->set_exp(1000.0);
			glass_ptr->set_eta_in(1.5);
			glass_ptr->set_eta_out(1.0);
			glass_ptr->set_cf_in(RGBColor(0.5, 0.95, 0.92));   	
			glass_ptr->set_cf_out(white);

			// SphereMaterials material to store the grid lines and the transparent checkers
			// See the Figure 24.15(c) build function for information on this material
	
			SphereMaterials* sphere_materials_ptr = new SphereMaterials;
			sphere_materials_ptr->set_num_horizontal(12);  
			sphere_materials_ptr->set_num_vertical(6);		
			sphere_materials_ptr->set_line_width(0.03);    
			sphere_materials_ptr->set_checker1_material(glass_ptr);
			sphere_materials_ptr->set_checker2_material(glass_ptr);
			sphere_materials_ptr->set_line_material(emissive_ptr);
	
			Sphere* sphere_ptr3 = new Sphere;
			sphere_ptr3->set_material(sphere_materials_ptr);   

			Instance* sphere_ptr4 = new Instance(sphere_ptr3);
			sphere_ptr4->scale(3.0);
			add_object(sphere_ptr4);
			break;
		}
	case 325:
		{
			//28.27a
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(6);

			background_color = RGBColor(0.0, 0.13, 0.1);

			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->set_color(0.45, 0.5, 0.45);
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);

	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10);
			pinhole_ptr->set_lookat(0, 0, 0);    
			pinhole_ptr->set_view_distance(2800.0);		
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
		
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(10, 10, 10);   
			light_ptr1->scale_radiance(7.0);  
			light_ptr1->set_shadows(false);
			add_light(light_ptr1);
		
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(-1, 0, 0);   
			light_ptr2->scale_radiance(7.0);  
			light_ptr2->set_shadows(false);
			add_light(light_ptr2);
	

			// transparent unit sphere at the origin
		
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(1.5);		// glass
			dielectric_ptr->set_eta_out(1.0);		// air
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white); 
		
			Sphere* sphere_ptr1 = new Sphere;
			sphere_ptr1->set_material(dielectric_ptr);
	
	
			// red reflective sphere inside the transparent sphere
	
			// the Reflective parameters below are for the reflective sphere in a glass sphere
			// they are too dark for the diamond sphere because of the etas
			
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.1);	
			reflective_ptr->set_kd(0.7);  
			reflective_ptr->set_cd(red);
			reflective_ptr->set_ks(0.3);  
			reflective_ptr->set_exp(200.0);
			reflective_ptr->set_kr(0.5);
			reflective_ptr->set_cr(white);
	
			double radius = 0.1;
			double distance = 0.8;   // from center of transparent sphere 
		
			Sphere* sphere_ptr2 = new Sphere(Point3D(0, 0, distance), radius);
			sphere_ptr2->set_material(reflective_ptr);
	
			// store the spheres in a compound object
	
			Compound* spheres_ptr = new Compound;
			spheres_ptr->add_object(sphere_ptr1);
			spheres_ptr->add_object(sphere_ptr2);
	
			// now store compound object in an instance so that we can rotate it
	
			Instance* rotated_spheres_ptr = new Instance(spheres_ptr);
			rotated_spheres_ptr->rotate_y(0.0);		// for Figure 28.28(a)
		//	rotated_spheres_ptr->rotate_y(120.0);  	// for Figure 28.28(b)
		//	rotated_spheres_ptr->rotate_y(162.0);  	// for Figure 28.28(c)
		//	rotated_spheres_ptr->rotate_y(164.0);  	// for Figure 28.28(d)
			add_object(rotated_spheres_ptr);
	
	
			// ground plane
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(50.0); 
			checker3D_ptr->set_color1(0.5); 
			checker3D_ptr->set_color2(1.0); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.5);
			sv_matte_ptr->set_cd(checker3D_ptr);
		
			Plane* plane_ptr = new Plane(Point3D(0, -40.5, 0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 326:
		{
			//28.27b
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(6);

			background_color = RGBColor(0.0, 0.13, 0.1);

			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->set_color(0.45, 0.5, 0.45);
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);

	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10);
			pinhole_ptr->set_lookat(0, 0, 0);    
			pinhole_ptr->set_view_distance(2800.0);		
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
		
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(10, 10, 10);   
			light_ptr1->scale_radiance(7.0);  
			light_ptr1->set_shadows(false);
			add_light(light_ptr1);
		
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(-1, 0, 0);   
			light_ptr2->scale_radiance(7.0);  
			light_ptr2->set_shadows(false);
			add_light(light_ptr2);
	

			// transparent unit sphere at the origin
		
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(1.5);		// glass
			dielectric_ptr->set_eta_out(1.0);		// air
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white); 
		
			Sphere* sphere_ptr1 = new Sphere;
			sphere_ptr1->set_material(dielectric_ptr);
	
	
			// red reflective sphere inside the transparent sphere
	
			// the Reflective parameters below are for the reflective sphere in a glass sphere
			// they are too dark for the diamond sphere because of the etas
			
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.1);	
			reflective_ptr->set_kd(0.7);  
			reflective_ptr->set_cd(red);
			reflective_ptr->set_ks(0.3);  
			reflective_ptr->set_exp(200.0);
			reflective_ptr->set_kr(0.5);
			reflective_ptr->set_cr(white);
	
			double radius = 0.1;
			double distance = 0.8;   // from center of transparent sphere 
		
			Sphere* sphere_ptr2 = new Sphere(Point3D(0, 0, distance), radius);
			sphere_ptr2->set_material(reflective_ptr);
	
			// store the spheres in a compound object
	
			Compound* spheres_ptr = new Compound;
			spheres_ptr->add_object(sphere_ptr1);
			spheres_ptr->add_object(sphere_ptr2);
	
			// now store compound object in an instance so that we can rotate it
	
			Instance* rotated_spheres_ptr = new Instance(spheres_ptr);
		//	rotated_spheres_ptr->rotate_y(0.0);		// for Figure 28.28(a)
			rotated_spheres_ptr->rotate_y(120.0);  	// for Figure 28.28(b)
		//	rotated_spheres_ptr->rotate_y(162.0);  	// for Figure 28.28(c)
		//	rotated_spheres_ptr->rotate_y(164.0);  	// for Figure 28.28(d)
			add_object(rotated_spheres_ptr);
	
	
			// ground plane
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(50.0); 
			checker3D_ptr->set_color1(0.5); 
			checker3D_ptr->set_color2(1.0); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.5);
			sv_matte_ptr->set_cd(checker3D_ptr);
		
			Plane* plane_ptr = new Plane(Point3D(0, -40.5, 0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 327:
		{
			//28.27c
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(6);

			background_color = RGBColor(0.0, 0.13, 0.1);

			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->set_color(0.45, 0.5, 0.45);
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);

	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10);
			pinhole_ptr->set_lookat(0, 0, 0);    
			pinhole_ptr->set_view_distance(2800.0);		
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
		
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(10, 10, 10);   
			light_ptr1->scale_radiance(7.0);  
			light_ptr1->set_shadows(false);
			add_light(light_ptr1);
		
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(-1, 0, 0);   
			light_ptr2->scale_radiance(7.0);  
			light_ptr2->set_shadows(false);
			add_light(light_ptr2);
	

			// transparent unit sphere at the origin
		
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(1.5);		// glass
			dielectric_ptr->set_eta_out(1.0);		// air
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white); 
		
			Sphere* sphere_ptr1 = new Sphere;
			sphere_ptr1->set_material(dielectric_ptr);
	
	
			// red reflective sphere inside the transparent sphere
	
			// the Reflective parameters below are for the reflective sphere in a glass sphere
			// they are too dark for the diamond sphere because of the etas
			
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.1);	
			reflective_ptr->set_kd(0.7);  
			reflective_ptr->set_cd(red);
			reflective_ptr->set_ks(0.3);  
			reflective_ptr->set_exp(200.0);
			reflective_ptr->set_kr(0.5);
			reflective_ptr->set_cr(white);
	
			double radius = 0.1;
			double distance = 0.8;   // from center of transparent sphere 
		
			Sphere* sphere_ptr2 = new Sphere(Point3D(0, 0, distance), radius);
			sphere_ptr2->set_material(reflective_ptr);
	
			// store the spheres in a compound object
	
			Compound* spheres_ptr = new Compound;
			spheres_ptr->add_object(sphere_ptr1);
			spheres_ptr->add_object(sphere_ptr2);
	
			// now store compound object in an instance so that we can rotate it
	
			Instance* rotated_spheres_ptr = new Instance(spheres_ptr);
		//	rotated_spheres_ptr->rotate_y(0.0);		// for Figure 28.28(a)
		//	rotated_spheres_ptr->rotate_y(120.0);  	// for Figure 28.28(b)
			rotated_spheres_ptr->rotate_y(162.0);  	// for Figure 28.28(c)
		//	rotated_spheres_ptr->rotate_y(164.0);  	// for Figure 28.28(d)
			add_object(rotated_spheres_ptr);
	
	
			// ground plane
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(50.0); 
			checker3D_ptr->set_color1(0.5); 
			checker3D_ptr->set_color2(1.0); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.5);
			sv_matte_ptr->set_cd(checker3D_ptr);
		
			Plane* plane_ptr = new Plane(Point3D(0, -40.5, 0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 328:
		{
			//28.27d
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(6);

			background_color = RGBColor(0.0, 0.13, 0.1);

			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->set_color(0.45, 0.5, 0.45);
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);

	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10);
			pinhole_ptr->set_lookat(0, 0, 0);    
			pinhole_ptr->set_view_distance(2800.0);		
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
		
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(10, 10, 10);   
			light_ptr1->scale_radiance(7.0);  
			light_ptr1->set_shadows(false);
			add_light(light_ptr1);
		
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(-1, 0, 0);   
			light_ptr2->scale_radiance(7.0);  
			light_ptr2->set_shadows(false);
			add_light(light_ptr2);
	

			// transparent unit sphere at the origin
		
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(1.5);		// glass
			dielectric_ptr->set_eta_out(1.0);		// air
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white); 
		
			Sphere* sphere_ptr1 = new Sphere;
			sphere_ptr1->set_material(dielectric_ptr);
	
	
			// red reflective sphere inside the transparent sphere
	
			// the Reflective parameters below are for the reflective sphere in a glass sphere
			// they are too dark for the diamond sphere because of the etas
			
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.1);	
			reflective_ptr->set_kd(0.7);  
			reflective_ptr->set_cd(red);
			reflective_ptr->set_ks(0.3);  
			reflective_ptr->set_exp(200.0);
			reflective_ptr->set_kr(0.5);
			reflective_ptr->set_cr(white);
	
			double radius = 0.1;
			double distance = 0.8;   // from center of transparent sphere 
		
			Sphere* sphere_ptr2 = new Sphere(Point3D(0, 0, distance), radius);
			sphere_ptr2->set_material(reflective_ptr);
	
			// store the spheres in a compound object
	
			Compound* spheres_ptr = new Compound;
			spheres_ptr->add_object(sphere_ptr1);
			spheres_ptr->add_object(sphere_ptr2);
	
			// now store compound object in an instance so that we can rotate it
	
			Instance* rotated_spheres_ptr = new Instance(spheres_ptr);
		//	rotated_spheres_ptr->rotate_y(0.0);		// for Figure 28.28(a)
		//	rotated_spheres_ptr->rotate_y(120.0);  	// for Figure 28.28(b)
		//	rotated_spheres_ptr->rotate_y(162.0);  	// for Figure 28.28(c)
			rotated_spheres_ptr->rotate_y(164.0);  	// for Figure 28.28(d)
			add_object(rotated_spheres_ptr);
	
	
			// ground plane
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(50.0); 
			checker3D_ptr->set_color1(0.5); 
			checker3D_ptr->set_color2(1.0); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.5);
			sv_matte_ptr->set_cd(checker3D_ptr);
		
			Plane* plane_ptr = new Plane(Point3D(0, -40.5, 0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 329:
		{
			//28.29a
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(6);

			background_color = RGBColor(0.0, 0.13, 0.1);

			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->set_color(0.45, 0.5, 0.45);
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);

	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10);
			pinhole_ptr->set_lookat(0, 0, 0);    
			pinhole_ptr->set_view_distance(2800.0);		
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
		
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(10, 10, 10);   
			light_ptr1->scale_radiance(7.0);  
			light_ptr1->set_shadows(false);
			add_light(light_ptr1);
		
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(-1, 0, 0);   
			light_ptr2->scale_radiance(7.0);  
			light_ptr2->scale_radiance(13.0);  
			light_ptr2->set_shadows(false);
			add_light(light_ptr2);
	

			// transparent unit sphere at the origin
		
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(2.42);		// glass
			dielectric_ptr->set_eta_out(1.0);		// air
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white); 
		
			Sphere* sphere_ptr1 = new Sphere;
			sphere_ptr1->set_material(dielectric_ptr);
	
	
			// red reflective sphere inside the transparent sphere
			// the red comes from the diffuse color
	
			// the Reflective parameters below are for the reflective sphere in a diamond sphere
			
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.1);	
			reflective_ptr->set_kd(1.0);  
			reflective_ptr->set_cd(red);
			reflective_ptr->set_ks(0.3);  
			reflective_ptr->set_exp(200.0);
			reflective_ptr->set_kr(0.75);
			reflective_ptr->set_kr(1.0);
			reflective_ptr->set_cr(white);
	
			double radius = 0.1;
			double distance = 0.8;   // from center of transparent sphere 
		
			Sphere* sphere_ptr2 = new Sphere(Point3D(0, 0, distance), radius);
			sphere_ptr2->set_material(reflective_ptr);
	
			// store the spheres in a compound object
	
			Compound* spheres_ptr = new Compound;
			spheres_ptr->add_object(sphere_ptr1);
			spheres_ptr->add_object(sphere_ptr2);
	
			// now store compound object in an instance so that we can rotate it
	
			Instance* rotated_spheres_ptr = new Instance(spheres_ptr);
			rotated_spheres_ptr->rotate_y(172.5);	// for Figure 28.29(a)
		//	rotated_spheres_ptr->rotate_y(173.0);  	// for Figure 28.29(b)
		//	rotated_spheres_ptr->rotate_y(178.0);  	// for Figure 28.29(c)
			add_object(rotated_spheres_ptr);
	
	
			// ground plane
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(50.0); 
			checker3D_ptr->set_color1(0.5); 
			checker3D_ptr->set_color2(1.0); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.5);
			sv_matte_ptr->set_cd(checker3D_ptr);
		
			Plane* plane_ptr = new Plane(Point3D(0, -40.5, 0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 330:
		{
			//28.29b
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(6);

			background_color = RGBColor(0.0, 0.13, 0.1);

			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->set_color(0.45, 0.5, 0.45);
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);

	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10);
			pinhole_ptr->set_lookat(0, 0, 0);    
			pinhole_ptr->set_view_distance(2800.0);		
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
		
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(10, 10, 10);   
			light_ptr1->scale_radiance(7.0);  
			light_ptr1->set_shadows(false);
			add_light(light_ptr1);
		
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(-1, 0, 0);   
			light_ptr2->scale_radiance(7.0);  
			light_ptr2->scale_radiance(13.0);  
			light_ptr2->set_shadows(false);
			add_light(light_ptr2);
	

			// transparent unit sphere at the origin
		
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(2.42);		// glass
			dielectric_ptr->set_eta_out(1.0);		// air
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white); 
		
			Sphere* sphere_ptr1 = new Sphere;
			sphere_ptr1->set_material(dielectric_ptr);
	
	
			// red reflective sphere inside the transparent sphere
			// the red comes from the diffuse color
	
			// the Reflective parameters below are for the reflective sphere in a diamond sphere
			
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.1);	
			reflective_ptr->set_kd(1.0);  
			reflective_ptr->set_cd(red);
			reflective_ptr->set_ks(0.3);  
			reflective_ptr->set_exp(200.0);
			reflective_ptr->set_kr(0.75);
			reflective_ptr->set_kr(1.0);
			reflective_ptr->set_cr(white);
	
			double radius = 0.1;
			double distance = 0.8;   // from center of transparent sphere 
		
			Sphere* sphere_ptr2 = new Sphere(Point3D(0, 0, distance), radius);
			sphere_ptr2->set_material(reflective_ptr);
	
			// store the spheres in a compound object
	
			Compound* spheres_ptr = new Compound;
			spheres_ptr->add_object(sphere_ptr1);
			spheres_ptr->add_object(sphere_ptr2);
	
			// now store compound object in an instance so that we can rotate it
	
			Instance* rotated_spheres_ptr = new Instance(spheres_ptr);
		//	rotated_spheres_ptr->rotate_y(172.5);	// for Figure 28.29(a)
			rotated_spheres_ptr->rotate_y(173.0);  	// for Figure 28.29(b)
		//	rotated_spheres_ptr->rotate_y(178.0);  	// for Figure 28.29(c)
			add_object(rotated_spheres_ptr);
	
	
			// ground plane
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(50.0); 
			checker3D_ptr->set_color1(0.5); 
			checker3D_ptr->set_color2(1.0); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.5);
			sv_matte_ptr->set_cd(checker3D_ptr);
		
			Plane* plane_ptr = new Plane(Point3D(0, -40.5, 0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 331:
		{
			//28.29c
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(6);

			background_color = RGBColor(0.0, 0.13, 0.1);

			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->set_color(0.45, 0.5, 0.45);
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);

	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10);
			pinhole_ptr->set_lookat(0, 0, 0);    
			pinhole_ptr->set_view_distance(2800.0);		
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
		
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(10, 10, 10);   
			light_ptr1->scale_radiance(7.0);  
			light_ptr1->set_shadows(false);
			add_light(light_ptr1);
		
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(-1, 0, 0);   
			light_ptr2->scale_radiance(7.0);  
			light_ptr2->scale_radiance(13.0);  
			light_ptr2->set_shadows(false);
			add_light(light_ptr2);
	

			// transparent unit sphere at the origin
		
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(2.42);		// glass
			dielectric_ptr->set_eta_out(1.0);		// air
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white); 
		
			Sphere* sphere_ptr1 = new Sphere;
			sphere_ptr1->set_material(dielectric_ptr);
	
	
			// red reflective sphere inside the transparent sphere
			// the red comes from the diffuse color
	
			// the Reflective parameters below are for the reflective sphere in a diamond sphere
			
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.1);	
			reflective_ptr->set_kd(1.0);  
			reflective_ptr->set_cd(red);
			reflective_ptr->set_ks(0.3);  
			reflective_ptr->set_exp(200.0);
			reflective_ptr->set_kr(0.75);
			reflective_ptr->set_kr(1.0);
			reflective_ptr->set_cr(white);
	
			double radius = 0.1;
			double distance = 0.8;   // from center of transparent sphere 
		
			Sphere* sphere_ptr2 = new Sphere(Point3D(0, 0, distance), radius);
			sphere_ptr2->set_material(reflective_ptr);
	
			// store the spheres in a compound object
	
			Compound* spheres_ptr = new Compound;
			spheres_ptr->add_object(sphere_ptr1);
			spheres_ptr->add_object(sphere_ptr2);
	
			// now store compound object in an instance so that we can rotate it
	
			Instance* rotated_spheres_ptr = new Instance(spheres_ptr);
		//	rotated_spheres_ptr->rotate_y(172.5);	// for Figure 28.29(a)
		//	rotated_spheres_ptr->rotate_y(173.0);  	// for Figure 28.29(b)
			rotated_spheres_ptr->rotate_y(178.0);  	// for Figure 28.29(c)
			add_object(rotated_spheres_ptr);
	
	
			// ground plane
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(50.0); 
			checker3D_ptr->set_color1(0.5); 
			checker3D_ptr->set_color2(1.0); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.5);
			sv_matte_ptr->set_cd(checker3D_ptr);
		
			Plane* plane_ptr = new Plane(Point3D(0, -40.5, 0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 332:
		{
			//28.34a
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(4);
		
			background_color = RGBColor(0.5, 0.5, 1.0);  // light blue
	
			tracer_ptr = new Whitted(this);
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 50, 0);      
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(500.0);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(0, 1, 0);    // straight down
			light_ptr1->scale_radiance(3.0); 
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(0, -1, 0);    // straight up
			light_ptr2->scale_radiance(2.5); 
			light_ptr2->set_shadows(false);
			add_light(light_ptr2);
	
	
			// transparent sphere
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(2.42);		// diamond
			dielectric_ptr->set_eta_out(1.0);		// air
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white); 
		
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0), 4.0);
			sphere_ptr1->set_material(dielectric_ptr);
			add_object(sphere_ptr1);	
	
	
	
			// a ring of spheres around the transparent sphere
	
			double scaling_factor 	= 2.0;  	// used to scale the radii of the ring and spheres
			double 	sphere_radius 	= 1.75 * scaling_factor;
			double 	ring_radius 	= 10.0 * scaling_factor;
			int 	num_spheres 	= 20;
			int 	delta_theta 	= 20;

			RGBColor color1(1, 0.5, 0);          // orange
			RGBColor color2(0.0, 0.5, 0.25);	  // cyan
	
	
			// Phong material for top half of each sphere
	
			Phong* phong_ptr1 = new Phong;		
			phong_ptr1->set_ka(0.2);
			phong_ptr1->set_kd(1.0);
			phong_ptr1->set_cd(color1);
			phong_ptr1->set_exp(100.0);
			phong_ptr1->set_ks(0.5);
			phong_ptr1->set_cs(1, 1, 0);
	
	
			// reflective material for bottom half of each sphere
	
			Reflective* reflective_ptr2 = new Reflective;
			reflective_ptr2->set_ka(0.2);
			reflective_ptr2->set_kd(1.0);
			reflective_ptr2->set_cd(color2);
			reflective_ptr2->set_exp(100.0);
			reflective_ptr2->set_ks(0.5);
			reflective_ptr2->set_cs(1, 1, 0);
			reflective_ptr2->set_kr(0.2);
	
	
			for (int j = 0; j < num_spheres; j++) {
				double xc = ring_radius * sin (j * delta_theta * PI / 180.0);
				double zc = ring_radius * cos (j * delta_theta * PI / 180.0);
				Point3D center(xc, 0, zc);
		
				ConvexPartSphere* top_half_ptr = new ConvexPartSphere(center, sphere_radius, 0, 360, 0, 90);
				top_half_ptr->set_material(phong_ptr1);
				add_object(top_half_ptr);
		
				ConvexPartSphere* bottom_half_ptr = new ConvexPartSphere(center, sphere_radius, 0, 360, 90, 180);
				bottom_half_ptr->set_material(reflective_ptr2);
				add_object(bottom_half_ptr);
			}
	

			// ground plane with checker
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(4.2); 
			checker3D_ptr->set_color1(white);    	
			checker3D_ptr->set_color2(0.5);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.4);
			sv_matte_ptr->set_kd(0.6);
			sv_matte_ptr->set_cd(checker3D_ptr);
		
			Plane* plane_ptr = new Plane(Point3D(0, -4.5, 0), Normal(0, 1, 0)); 
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 333:
		{
			//28.34b
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(4);
		
			background_color = RGBColor(0.5, 0.5, 1.0);  // light blue
	
			tracer_ptr = new Whitted(this);
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 2); 
			pinhole_ptr->set_lookat(0, 0, 10);    
			pinhole_ptr->set_view_distance(200.0);  
			pinhole_ptr->set_exposure_time(0.17);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(0, 1, 0);    // straight down
			light_ptr1->scale_radiance(3.0); 
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(0, -1, 0);    // straight up
			light_ptr2->scale_radiance(2.5); 
			light_ptr2->set_shadows(false);
			add_light(light_ptr2);
	
	
			// transparent sphere
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(2.42);		// diamond
			dielectric_ptr->set_eta_out(1.0);		// air
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white); 
		
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0), 4.0);
			sphere_ptr1->set_material(dielectric_ptr);
			add_object(sphere_ptr1);	
	
	
	
			// a ring of spheres around the transparent sphere
	
			double scaling_factor 	= 2.0;  	// used to scale the radii of the ring and spheres
			double 	sphere_radius 	= 1.75 * scaling_factor;
			double 	ring_radius 	= 10.0 * scaling_factor;
			int 	num_spheres 	= 20;
			int 	delta_theta 	= 20;

			RGBColor color1(1, 0.5, 0);          // orange
			RGBColor color2(0.0, 0.5, 0.25);	  // cyan
	
	
			// Phong material for top half of each sphere
	
			Phong* phong_ptr1 = new Phong;		
			phong_ptr1->set_ka(0.2);
			phong_ptr1->set_kd(1.0);
			phong_ptr1->set_cd(color1);
			phong_ptr1->set_exp(100.0);
			phong_ptr1->set_ks(0.5);
			phong_ptr1->set_cs(1, 1, 0);
	
	
			// reflective material for bottom half of each sphere
	
			Reflective* reflective_ptr2 = new Reflective;
			reflective_ptr2->set_ka(0.2);
			reflective_ptr2->set_kd(1.0);
			reflective_ptr2->set_cd(color2);
			reflective_ptr2->set_exp(100.0);
			reflective_ptr2->set_ks(0.5);
			reflective_ptr2->set_cs(1, 1, 0);
			reflective_ptr2->set_kr(0.2);
	
	
			for (int j = 0; j < num_spheres; j++) {
				double xc = ring_radius * sin (j * delta_theta * PI / 180.0);
				double zc = ring_radius * cos (j * delta_theta * PI / 180.0);
				Point3D center(xc, 0, zc);
		
				ConvexPartSphere* top_half_ptr = new ConvexPartSphere(center, sphere_radius, 0, 360, 0, 90);
				top_half_ptr->set_material(phong_ptr1);
				add_object(top_half_ptr);
		
				ConvexPartSphere* bottom_half_ptr = new ConvexPartSphere(center, sphere_radius, 0, 360, 90, 180);
				bottom_half_ptr->set_material(reflective_ptr2);
				add_object(bottom_half_ptr);
			}
	

			// ground plane with checker
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(4.2); 
			checker3D_ptr->set_color1(white);    	
			checker3D_ptr->set_color2(0.5);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.4);
			sv_matte_ptr->set_kd(0.6);
			sv_matte_ptr->set_cd(checker3D_ptr);
		
			Plane* plane_ptr = new Plane(Point3D(0, -4.5, 0), Normal(0, 1, 0)); 
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 334:
		{
			//28.34c
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(4);
		
			background_color = RGBColor(0.5, 0.5, 1.0);  // light blue
	
			tracer_ptr = new Whitted(this);
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 2);      
			pinhole_ptr->set_lookat(10, 0, 2);    
			pinhole_ptr->set_view_distance(100.0);
			pinhole_ptr->set_exposure_time(0.17);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(0, 1, 0);    // straight down
			light_ptr1->scale_radiance(3.0); 
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(0, -1, 0);    // straight up
			light_ptr2->scale_radiance(2.5); 
			light_ptr2->set_shadows(false);
			add_light(light_ptr2);
	
	
			// transparent sphere
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(2.42);		// diamond
			dielectric_ptr->set_eta_out(1.0);		// air
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white); 
		
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0), 4.0);
			sphere_ptr1->set_material(dielectric_ptr);
			add_object(sphere_ptr1);	
	
	
	
			// a ring of spheres around the transparent sphere
	
			double scaling_factor 	= 2.0;  	// used to scale the radii of the ring and spheres
			double 	sphere_radius 	= 1.75 * scaling_factor;
			double 	ring_radius 	= 10.0 * scaling_factor;
			int 	num_spheres 	= 20;
			int 	delta_theta 	= 20;

			RGBColor color1(1, 0.5, 0);          // orange
			RGBColor color2(0.0, 0.5, 0.25);	  // cyan
	
	
			// Phong material for top half of each sphere
	
			Phong* phong_ptr1 = new Phong;		
			phong_ptr1->set_ka(0.2);
			phong_ptr1->set_kd(1.0);
			phong_ptr1->set_cd(color1);
			phong_ptr1->set_exp(100.0);
			phong_ptr1->set_ks(0.5);
			phong_ptr1->set_cs(1, 1, 0);
	
	
			// reflective material for bottom half of each sphere
	
			Reflective* reflective_ptr2 = new Reflective;
			reflective_ptr2->set_ka(0.2);
			reflective_ptr2->set_kd(1.0);
			reflective_ptr2->set_cd(color2);
			reflective_ptr2->set_exp(100.0);
			reflective_ptr2->set_ks(0.5);
			reflective_ptr2->set_cs(1, 1, 0);
			reflective_ptr2->set_kr(0.2);
	
	
			for (int j = 0; j < num_spheres; j++) {
				double xc = ring_radius * sin (j * delta_theta * PI / 180.0);
				double zc = ring_radius * cos (j * delta_theta * PI / 180.0);
				Point3D center(xc, 0, zc);
		
				ConvexPartSphere* top_half_ptr = new ConvexPartSphere(center, sphere_radius, 0, 360, 0, 90);
				top_half_ptr->set_material(phong_ptr1);
				add_object(top_half_ptr);
		
				ConvexPartSphere* bottom_half_ptr = new ConvexPartSphere(center, sphere_radius, 0, 360, 90, 180);
				bottom_half_ptr->set_material(reflective_ptr2);
				add_object(bottom_half_ptr);
			}
	

			// ground plane with checker
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(4.2); 
			checker3D_ptr->set_color1(white);    	
			checker3D_ptr->set_color2(0.5);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.4);
			sv_matte_ptr->set_kd(0.6);
			sv_matte_ptr->set_cd(checker3D_ptr);
		
			Plane* plane_ptr = new Plane(Point3D(0, -4.5, 0), Normal(0, 1, 0)); 
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 335:
		{
			//28.34d
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(4);
		
			background_color = RGBColor(0.5, 0.5, 1.0);  // light blue
	
			tracer_ptr = new Whitted(this);
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 2);      
			pinhole_ptr->set_lookat(0, 0, -10);    
			pinhole_ptr->set_view_distance(200.0);
			pinhole_ptr->set_exposure_time(0.17);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(0, 1, 0);    // straight down
			light_ptr1->scale_radiance(3.0); 
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(0, -1, 0);    // straight up
			light_ptr2->scale_radiance(2.5); 
			light_ptr2->set_shadows(false);
			add_light(light_ptr2);
	
	
			// transparent sphere
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(2.42);		// diamond
			dielectric_ptr->set_eta_out(1.0);		// air
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white); 
		
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0), 4.0);
			sphere_ptr1->set_material(dielectric_ptr);
			add_object(sphere_ptr1);	
	
	
	
			// a ring of spheres around the transparent sphere
	
			double scaling_factor 	= 2.0;  	// used to scale the radii of the ring and spheres
			double 	sphere_radius 	= 1.75 * scaling_factor;
			double 	ring_radius 	= 10.0 * scaling_factor;
			int 	num_spheres 	= 20;
			int 	delta_theta 	= 20;

			RGBColor color1(1, 0.5, 0);          // orange
			RGBColor color2(0.0, 0.5, 0.25);	  // cyan
	
	
			// Phong material for top half of each sphere
	
			Phong* phong_ptr1 = new Phong;		
			phong_ptr1->set_ka(0.2);
			phong_ptr1->set_kd(1.0);
			phong_ptr1->set_cd(color1);
			phong_ptr1->set_exp(100.0);
			phong_ptr1->set_ks(0.5);
			phong_ptr1->set_cs(1, 1, 0);
	
	
			// reflective material for bottom half of each sphere
	
			Reflective* reflective_ptr2 = new Reflective;
			reflective_ptr2->set_ka(0.2);
			reflective_ptr2->set_kd(1.0);
			reflective_ptr2->set_cd(color2);
			reflective_ptr2->set_exp(100.0);
			reflective_ptr2->set_ks(0.5);
			reflective_ptr2->set_cs(1, 1, 0);
			reflective_ptr2->set_kr(0.2);
	
	
			for (int j = 0; j < num_spheres; j++) {
				double xc = ring_radius * sin (j * delta_theta * PI / 180.0);
				double zc = ring_radius * cos (j * delta_theta * PI / 180.0);
				Point3D center(xc, 0, zc);
		
				ConvexPartSphere* top_half_ptr = new ConvexPartSphere(center, sphere_radius, 0, 360, 0, 90);
				top_half_ptr->set_material(phong_ptr1);
				add_object(top_half_ptr);
		
				ConvexPartSphere* bottom_half_ptr = new ConvexPartSphere(center, sphere_radius, 0, 360, 90, 180);
				bottom_half_ptr->set_material(reflective_ptr2);
				add_object(bottom_half_ptr);
			}
	

			// ground plane with checker
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(4.2); 
			checker3D_ptr->set_color1(white);    	
			checker3D_ptr->set_color2(0.5);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.4);
			sv_matte_ptr->set_kd(0.6);
			sv_matte_ptr->set_cd(checker3D_ptr);
		
			Plane* plane_ptr = new Plane(Point3D(0, -4.5, 0), Normal(0, 1, 0)); 
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 336:
		{
			//28.38a
			int num_samples = 9;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(10);
	
			background_color = RGBColor(0.5);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(5, 6, 10); 
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(2000.0);			
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 30); 
			light_ptr1->scale_radiance(3.0);    
			light_ptr1->set_shadows(false);      
			add_light(light_ptr1);


			// materials for the glass of water
	
			// glass-air boundary
	
			RGBColor glass_color(0.65, 1, 0.75);   
			RGBColor water_color(1, 0.25, 1);       
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_eta_in(1.50);			// glass  
			glass_ptr->set_eta_out(1.0);			// air
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(white);  
	
			// water-air boundary
	
			Dielectric* water_ptr = new Dielectric;
			water_ptr->set_eta_in(1.33);			// water
			water_ptr->set_eta_out(1.0);			// air
			water_ptr->set_cf_in(water_color);
			water_ptr->set_cf_out(white);

			// water-glass boundary

			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(1.33); 		// water
			dielectric_ptr->set_eta_out(1.50); 		// glass
			dielectric_ptr->set_cf_in(water_color);
			dielectric_ptr->set_cf_out(glass_color);
	
	
			// Define the GlassOfWater object
			// The parameters below are the default values, but using the constructor that
			// takes these as arguments makes it easier to experiment with different values
	
			double height 			= 2.0;
			double inner_radius 	= 0.9;
			double wall_thickness 	= 0.1;  
			double base_thickness 	= 0.3;
			double water_height 	= 1.5;
			double meniscus_radius 	= 0.1;
	
			GlassOfWater* glass_of_water_ptr = new GlassOfWater(height,
																inner_radius,
																wall_thickness,  
																base_thickness,
																water_height,
																meniscus_radius);
	
			glass_of_water_ptr->set_glass_air_material(glass_ptr);
			glass_of_water_ptr->set_water_air_material(water_ptr);
			glass_of_water_ptr->set_water_glass_material(dielectric_ptr);
			add_object(glass_of_water_ptr);
	
	
			// define the straw
	
			Matte* matte_ptr = new Matte;
			matte_ptr->set_cd(1, 1, 0);  			
			matte_ptr->set_ka(0.25);	
			matte_ptr->set_kd(0.65);
			matte_ptr->set_shadows(false);  // there are no shadows cast on the straw
	
			Instance* straw_ptr = new Instance(new OpenCylinder(-1.2, 1.7, 0.05));
			straw_ptr->set_material(matte_ptr);
			straw_ptr->rotate_z(40);
			straw_ptr->translate(0, 1.25, 0);
			add_object(straw_ptr);
	
			// ground plane

			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(0.5); 
			checker_ptr->set_color1(0.75); 
			checker_ptr->set_color2(white);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.75);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 337:
		{
			//28.38b
			int num_samples = 9;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(10);
	
			background_color = RGBColor(0.5);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(2.5, 0, 5); 
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(1000.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 30); 
			light_ptr1->scale_radiance(3.0);    
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);


			// materials for the glass of water
	
			// glass-air boundary
	
			RGBColor glass_color(0.65, 1, 0.75);   
			RGBColor water_color(1, 0.25, 1);       
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_eta_in(1.50);			// glass  
			glass_ptr->set_eta_out(1.0);			// air
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(white);  
	
			// water-air boundary
	
			Dielectric* water_ptr = new Dielectric;
			water_ptr->set_eta_in(1.33);			// water
			water_ptr->set_eta_out(1.0);			// air
			water_ptr->set_cf_in(water_color);
			water_ptr->set_cf_out(white);

			// water-glass boundary

			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(1.33); 		// water
			dielectric_ptr->set_eta_out(1.50); 		// glass
			dielectric_ptr->set_cf_in(water_color);
			dielectric_ptr->set_cf_out(glass_color);
	
	
			// Define the GlassOfWater object
			// The parameters below are the default values, but using the constructor that
			// takes these as arguments makes it easier to experiment with different values
	
			double height 			= 2.0;
			double inner_radius 	= 0.9;
			double wall_thickness 	= 0.1;  
			double base_thickness 	= 0.3;
			double water_height 	= 1.5;
			double meniscus_radius 	= 0.1;
	
			GlassOfWater* glass_of_water_ptr = new GlassOfWater(height,
																inner_radius,
																wall_thickness,  
																base_thickness,
																water_height,
																meniscus_radius);
	
			glass_of_water_ptr->set_glass_air_material(glass_ptr);
			glass_of_water_ptr->set_water_air_material(water_ptr);
			glass_of_water_ptr->set_water_glass_material(dielectric_ptr);
			add_object(glass_of_water_ptr);
	
	
			// define the straw
	
			Matte* matte_ptr = new Matte;
			matte_ptr->set_cd(1, 1, 0);  			
			matte_ptr->set_ka(0.25);	
			matte_ptr->set_kd(0.65);
			matte_ptr->set_shadows(false);  // there are no shadows cast on the straw
	
			Instance* straw_ptr = new Instance(new OpenCylinder(-1.2, 1.7, 0.05));
			straw_ptr->set_material(matte_ptr);
			straw_ptr->rotate_z(40);
			straw_ptr->translate(0, 1.25, 0);
			add_object(straw_ptr);
	
			// ground plane

			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(0.5); 
			checker_ptr->set_color1(0.75); 
			checker_ptr->set_color2(white);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.75);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 338:
		{
			//28.38c
			int num_samples = 9;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(10);
	
			background_color = RGBColor(0.5);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			Pinhole* pinhole_ptr = new Pinhole;

	
			pinhole_ptr->set_eye(5, 6, 10); 
			pinhole_ptr->set_lookat(0, 1, 0); 
			pinhole_ptr->set_view_distance(2000.0);			
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 30); 
			light_ptr1->scale_radiance(3.0);    
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);


			// materials for the glass of water
	
			// glass-air boundary
	
			RGBColor glass_color(0.65, 1, 0.75);   
			RGBColor water_color(1, 0.25, 1);       
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_eta_in(1.50);			// glass  
			glass_ptr->set_eta_out(1.0);			// air
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(white);  
	
			// water-air boundary
	
			Dielectric* water_ptr = new Dielectric;
			water_ptr->set_eta_in(1.33);			// water
			water_ptr->set_eta_out(1.0);			// air
			water_ptr->set_cf_in(water_color);
			water_ptr->set_cf_out(white);

			// water-glass boundary

			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(1.33); 		// water
			dielectric_ptr->set_eta_out(1.50); 		// glass
			dielectric_ptr->set_cf_in(water_color);
			dielectric_ptr->set_cf_out(glass_color);
	
	
			// Define the GlassOfWater object
			// The parameters below are the default values, but using the constructor that
			// takes these as arguments makes it easier to experiment with different values
	
			double height 			= 2.0;
			double inner_radius 	= 0.9;
			double wall_thickness 	= 0.1;  
			double base_thickness 	= 0.3;
			double water_height 	= 1.5;
			double meniscus_radius 	= 0.1;
	
			GlassOfWater* glass_of_water_ptr = new GlassOfWater(height,
																inner_radius,
																wall_thickness,  
																base_thickness,
																water_height,
																meniscus_radius);
	
			glass_of_water_ptr->set_glass_air_material(glass_ptr);
			glass_of_water_ptr->set_water_air_material(water_ptr);
			glass_of_water_ptr->set_water_glass_material(dielectric_ptr);
			add_object(glass_of_water_ptr);
	
	
			// define the straw
	
			Matte* matte_ptr = new Matte;
			matte_ptr->set_cd(1, 1, 0);  			
			matte_ptr->set_ka(0.25);	
			matte_ptr->set_kd(0.65);
			matte_ptr->set_shadows(false);  // there are no shadows cast on the straw
	
			Instance* straw_ptr = new Instance(new OpenCylinder(-1.2, 1.7, 0.05));
			straw_ptr->set_material(matte_ptr);
			straw_ptr->rotate_z(40);
			straw_ptr->translate(0, 1.25, 0);
			add_object(straw_ptr);
	
			// ground plane

			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(0.5); 
			checker_ptr->set_color1(0.75); 
			checker_ptr->set_color2(white);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.75);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 339:
		{
			//28.41a
			if( !CheckFile(QString(plyfile+"goldfish_high_res.ply").toLatin1().data()))
				return;

			int num_samples = 9;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(10);  
	
			tracer_ptr = new Whitted(this);
	
			background_color = RGBColor(0.75);  
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(4.5, 6, 4); 
			pinhole_ptr->set_lookat(0.0); 
			pinhole_ptr->set_view_distance(1800.0);  			
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 25, -10); 
			light_ptr1->scale_radiance(5.0);  
			light_ptr1->set_shadows(true);   
			add_light(light_ptr1);
	

			// fishbowl
	
			// glass-air interface
	
			float c = 2;
			RGBColor glass_color(0.27*c, 0.49*c, 0.42*c);   
			RGBColor water_color(0.75, 1, 0.75);
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_ks(0.5);
			glass_ptr->set_exp(8000.0);  
			glass_ptr->set_eta_in(1.50);			// glass
			glass_ptr->set_eta_out(1.0);			// air
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(white); 
		
			// water-air interface
	
			Dielectric* water_ptr = new Dielectric;
			water_ptr->set_ks(0.5);
			water_ptr->set_exp(8000);
			water_ptr->set_eta_in(1.33);			// water
			water_ptr->set_eta_out(1.0);			// air
			water_ptr->set_cf_in(water_color);
			water_ptr->set_cf_out(white);

			// water-glass interface

			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_ks(0.5);
			dielectric_ptr->set_exp(8000);
			dielectric_ptr->set_eta_in(1.33); 		// water
			dielectric_ptr->set_eta_out(1.5); 		// glass
			dielectric_ptr->set_cf_in(water_color);
			dielectric_ptr->set_cf_out(glass_color);
	
			// physical bowl parameters (also the defaults)
	
			double inner_radius		= 1.0;
			double glass_thickness	= 0.1;
			double water_depth		= 1.25;
			double meniscus_radius 	= 0.05;
			double opening_angle 	= 90.0;
	
	
			FishBowl* fishbowl_ptr = new FishBowl(	inner_radius,
													glass_thickness,
													water_depth,
													meniscus_radius,
													opening_angle);
			fishbowl_ptr->set_glass_air_material(glass_ptr);
			fishbowl_ptr->set_water_air_material(water_ptr);
			fishbowl_ptr->set_water_glass_material(dielectric_ptr);
			add_object(fishbowl_ptr);
	

	
			// goldfish
	
			Phong* phong_ptr = new Phong;			
			phong_ptr->set_ka(0.4); 
			phong_ptr->set_kd(0.8); 
			phong_ptr->set_cd(1.0, 0.15, 0.0);   	// orange 
			phong_ptr->set_ks(0.5);  
			phong_ptr->set_cs(1.0, 0.35, 0.0);		// orange
			phong_ptr->set_exp(50.0); 
			phong_ptr->set_shadows(false); 
	
		
		//	const char* file_name = "goldfish_low_res.ply";		// for scene design
			const char* file_name = "goldfish_high_res.ply";  // for production
			Grid* grid_ptr = new Grid(new Mesh);
		//	grid_ptr->read_flat_triangles(file_name);		
			grid_ptr->read_smooth_triangles(QString(plyfile+"goldfish_high_res.ply").toLatin1().data());		
			grid_ptr->set_material(phong_ptr);
			grid_ptr->setup_cells();
	
			Instance* gold_fish_ptr = new Instance(grid_ptr);
			gold_fish_ptr->scale(0.03);
			gold_fish_ptr->translate(0.5, 0.0, 0.0);
			add_object(gold_fish_ptr);
	
	
			// plane
	
			PlaneChecker* checker_ptr = new PlaneChecker;
			checker_ptr->set_size(0.5);		
			checker_ptr->set_outline_width(0.05);
			checker_ptr->set_color1(0.75);
			checker_ptr->set_color2(0.75);  
			checker_ptr->set_outline_color(0.45); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.65);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -1.51, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 340:
		{
			//28.41b
			if( !CheckFile(QString(plyfile+"goldfish_high_res.ply").toLatin1().data()))
				return;

			int num_samples = 9;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(10);   
	
			tracer_ptr = new Whitted(this);
	
			background_color = RGBColor(0.9);  
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-0.5, -1.0, 4); 
			pinhole_ptr->set_lookat(0.0); 
			pinhole_ptr->set_view_distance(900.0); 			
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 25, 10); 
			light_ptr1->scale_radiance(2.5);  
			light_ptr1->set_shadows(true);   
			add_light(light_ptr1);
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(-1, 0, 0);    
			light_ptr2->scale_radiance(2.5);  
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	

			// fishbowl
	
			// glass-air interface
	
			float c = 2;
			RGBColor glass_color(0.27*c, 0.49*c, 0.42*c);   
			RGBColor water_color(0.75, 1, 0.75);
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_ks(0.5);
			glass_ptr->set_exp(8000.0);  
			glass_ptr->set_eta_in(1.50);			// glass
			glass_ptr->set_eta_out(1.0);			// air
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(white); 
		
			// water-air interface
	
			Dielectric* water_ptr = new Dielectric;
			water_ptr->set_ks(0.5);
			water_ptr->set_exp(8000);
			water_ptr->set_eta_in(1.33);			// water
			water_ptr->set_eta_out(1.0);			// air
			water_ptr->set_cf_in(water_color);
			water_ptr->set_cf_out(white);

			// water-glass interface

			Dielectric* dielectric_ptr1 = new Dielectric;
			dielectric_ptr1->set_ks(0.5);
			dielectric_ptr1->set_exp(8000);
			dielectric_ptr1->set_eta_in(1.33); 		// water
			dielectric_ptr1->set_eta_out(1.5); 		// glass
			dielectric_ptr1->set_cf_in(water_color);
			dielectric_ptr1->set_cf_out(glass_color);
	
			// physical bowl parameters (also the defaults)
	
			double inner_radius		= 1.0;
			double glass_thickness	= 0.1;
			double water_depth		= 1.25;
			double meniscus_radius 	= 0.05;
			double opening_angle 	= 90.0;
	
	
			FishBowl* fishbowl_ptr = new FishBowl(	inner_radius,
													glass_thickness,
													water_depth,
													meniscus_radius,
													opening_angle);
			fishbowl_ptr->set_glass_air_material(glass_ptr);
			fishbowl_ptr->set_water_air_material(water_ptr);
			fishbowl_ptr->set_water_glass_material(dielectric_ptr1);
			add_object(fishbowl_ptr);
	

	
			// goldfish
	
			Phong* phong_ptr1 = new Phong;			
			phong_ptr1->set_ka(0.4); 
			phong_ptr1->set_kd(0.8); 
			phong_ptr1->set_cd(1.0, 0.15, 0.0);   	// orange 
			phong_ptr1->set_ks(0.5);
			phong_ptr1->set_cs(1.0, 0.35, 0.0);		// orange
			phong_ptr1->set_exp(50.0); 
			phong_ptr1->set_shadows(false); 
	
	
			// we read the fish file once, and instance it
		
		//	const char* file_name = "goldfish_low_res.ply";		// for scene design
			const char* file_name = "goldfish_high_res.ply";	// for production
			Grid* grid_ptr = new Grid(new Mesh);
		//	grid_ptr->read_flat_triangles(file_name);		
			grid_ptr->read_smooth_triangles(QString(plyfile+"goldfish_high_res.ply").toLatin1().data());		
			grid_ptr->set_material(phong_ptr1);    
			grid_ptr->setup_cells();
	
			Instance* gold_fish_ptr1 = new Instance(grid_ptr);
			gold_fish_ptr1->scale(0.03);
			gold_fish_ptr1->rotate_y(-45);
			gold_fish_ptr1->translate(0.5, 0.0, 0.0);
			add_object(gold_fish_ptr1);
	
			Instance* goldfish_ptr2 = new Instance(grid_ptr);
			goldfish_ptr2->scale(0.02);
			goldfish_ptr2->rotate_y(90);
			goldfish_ptr2->translate(-0.75, 0.0, 0.0);
			goldfish_ptr2->rotate_y(-60);
			add_object(goldfish_ptr2);
	
			Instance* goldfish_ptr3 = new Instance(grid_ptr);
			goldfish_ptr3->scale(0.02);
			goldfish_ptr3->rotate_x(20);
			goldfish_ptr3->rotate_y(-45);
			goldfish_ptr3->translate(-0.1, -0.4, 0.0);
			add_object(goldfish_ptr3);
	
	
			// cylinder under the bowl
	
			Phong* phong_ptr2 = new Phong;			
			phong_ptr2->set_ka(0.4); 
			phong_ptr2->set_kd(0.8); 
			phong_ptr2->set_cd(0.05); 
			phong_ptr2->set_ks(0.2); 
			phong_ptr2->set_exp(100.0);  
	
			double bottom = -1.2;
			double radius = 0.5;
			double top = -sqrt(1.1 * 1.1 - radius * radius);
	
			ConvexOpenCylinder* cylinder_ptr = new ConvexOpenCylinder(bottom, top, radius);
			cylinder_ptr->set_material(phong_ptr2);
			add_object(cylinder_ptr);
	
	
			// single air bubble
	
			Dielectric* dielectric_ptr2 = new Dielectric;
			dielectric_ptr2->set_eta_in(1.0); 		// air
			dielectric_ptr2->set_eta_out(1.33); 	// water
			dielectric_ptr2->set_cf_in(white);
			dielectric_ptr2->set_cf_out(water_color);
	
			Sphere* bubble_ptr = new Sphere(Point3D(0.2, 0.2, 0.2), 0.05);
			bubble_ptr->set_material(dielectric_ptr2);
			add_object(bubble_ptr);
	
	
			// streams of air bubbles
	
			set_rand_seed(1000);
	
			double bubble_radius		= 0.045;         	
			double yc_bottom 			= -0.9;    			// height of bottom bubble center
			double yc_top 				= 0.2;    			// height of top bubble center
			double num_bubbles 			= 8;				// number of bubbles in stream
			double spacing 				= (yc_top - yc_bottom) / num_bubbles; // vertical spacing between bubble centers
			double translation_factor 	= bubble_radius / 2.0;
			double min 					= 0.9;   			// minimum bubble scaling
			double max 					= 1.1;				// maximum bubble scaling
			double xc 					= -0.1;   			// center x 
			double zc 					= 0.3;				// center y
	
	
	
			// bubble stream 1
		
			Grid* bubble_stream_ptr_1 = new Grid;
	
			for (int j = 0; j <= num_bubbles; j++) {		
				Instance* bubble_ptr = new Instance(new Sphere);

				bubble_ptr->scale(	min + rand_float() * (max - min), 
									min + rand_float() * (max - min),
									min + rand_float() * (max - min));
				
				bubble_ptr->scale(bubble_radius);
		
				bubble_ptr->rotate_x(360.0 * rand_float());
				bubble_ptr->rotate_y(360.0 * rand_float());
				bubble_ptr->rotate_z(360.0 * rand_float());  
		
				bubble_ptr->translate(	xc + (2.0 * rand_float() - 1.0) * translation_factor, 
										yc_bottom + j * spacing + (2.0 * rand_float() - 1.0) * translation_factor,
										zc + (2.0 * rand_float() - 1.0) * translation_factor);					
				
				bubble_ptr->set_material(dielectric_ptr2);
				bubble_stream_ptr_1->add_object(bubble_ptr);
			}
		
			bubble_stream_ptr_1->setup_cells();
			add_object(bubble_stream_ptr_1);

			// bubble stream 2 
	
			num_bubbles = 7;
			xc = 0.075; 
			zc = 0.1;
	
			Grid* bubble_stream_ptr_2 = new Grid;
	
			for (int j = 0; j <= num_bubbles; j++) {
				Instance* bubble_ptr = new Instance(new Sphere);
	
				bubble_ptr->scale(	min + rand_float() * (max - min), 
									min + rand_float() * (max - min),
									min + rand_float() * (max - min));
				
				bubble_ptr->scale(bubble_radius);
		
				bubble_ptr->rotate_x(360.0 * rand_float());
				bubble_ptr->rotate_y(360.0 * rand_float());
				bubble_ptr->rotate_z(360.0 * rand_float());  
		
				bubble_ptr->translate(	xc + (2.0 * rand_float() - 1.0) * translation_factor, 
										yc_bottom + j * spacing + (2.0 * rand_float() - 1.0) * translation_factor,
										zc + (2.0 * rand_float() - 1.0) * translation_factor);					
				
				bubble_ptr->set_material(dielectric_ptr2);
				bubble_stream_ptr_2->add_object(bubble_ptr);
			}
	
			bubble_stream_ptr_2->setup_cells();
			add_object(bubble_stream_ptr_2);
	
	
	
			// bubble stream 3 
	
			num_bubbles = 9;
			xc = -0.15;
			zc = -0.3;
	
			Grid* bubble_stream_ptr_3 = new Grid;
	
			for (int j = 0; j <= num_bubbles; j++) {
				Instance* bubble_ptr = new Instance(new Sphere);
	
				bubble_ptr->scale(	min + rand_float() * (max - min), 
									min + rand_float() * (max - min),
									min + rand_float() * (max - min));
				
				bubble_ptr->scale(bubble_radius);
		
				bubble_ptr->rotate_x(360.0 * rand_float());
				bubble_ptr->rotate_y(360.0 * rand_float());
				bubble_ptr->rotate_z(360.0 * rand_float());  
		
				bubble_ptr->translate(	xc + (2.0 * rand_float() - 1.0) * translation_factor, 
										yc_bottom + j * spacing + (2.0 * rand_float() - 1.0) * translation_factor,
										zc + (2.0 * rand_float() - 1.0) * translation_factor);					
				
				bubble_ptr->set_material(dielectric_ptr2);
				bubble_stream_ptr_3->add_object(bubble_ptr);
			}
	
			bubble_stream_ptr_3->setup_cells();
			add_object(bubble_stream_ptr_3);

			// plane
	
			PlaneChecker* checker_ptr = new PlaneChecker;
			checker_ptr->set_size(0.5);		
			checker_ptr->set_outline_width(0.05);
			checker_ptr->set_color1(0.75);
			checker_ptr->set_color2(0.75);  
			checker_ptr->set_outline_color(0.45); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.5);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -1.2, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr);
	
			Instance* plane_ptr2 = new Instance(plane_ptr); // to adjust the reflection of the grid lines off the top of the water
			plane_ptr2->rotate_y(30);
			plane_ptr2->translate(0.25, 0, 0.15);
			add_object(plane_ptr2);
			break;
		}
	case 341:
		{
			//28.43
			int num_samples = 9;
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_max_depth(6);   // depth 6 is necessary to get rays through the three cylinders
			vp.set_pixel_size(0.012);
			vp.set_samples(num_samples);
	
			background_color = black;
	
			tracer_ptr = new Whitted(this);
	
	
			// camera looks down y axis because disks have vertical axes	
	
			Orthographic* orthographic_ptr = new Orthographic;
			orthographic_ptr->set_eye(0.23, 100, 0);    
			orthographic_ptr->set_lookat(0.23, 0, 0);  
			orthographic_ptr->compute_uvw();     
			set_camera(orthographic_ptr);

	
			// top cylinder (in image)
	
			double top1 = 0.5;
			double bottom1 = 0.0;
			double radius = 1.25;
	
			RGBColor glass_color1(1, 0, 0);    	// red
	
			Dielectric* glass_ptr1 = new Dielectric;
			glass_ptr1->set_eta_in(1.5);		// glass
			glass_ptr1->set_eta_out(1.0);		// air
			glass_ptr1->set_cf_in(glass_color1);
			glass_ptr1->set_cf_out(white); 
	
			Instance* cylinder_ptr1 = new Instance (new SolidCylinder(top1, bottom1, radius)); 
			cylinder_ptr1->translate(1, 0, 0);
			cylinder_ptr1->set_material(glass_ptr1);
			add_object(cylinder_ptr1);	
	
	
			// left cylinder
	
			double top2 	= 1.5;
			double bottom2 	= 1;
	
			RGBColor glass_color2(0, 1, 0);   	// green
	
			Dielectric* glass_ptr2 = new Dielectric;
			glass_ptr2->set_eta_in(1.5);		// glass
			glass_ptr2->set_eta_out(1.0);		// air
			glass_ptr2->set_cf_in(glass_color2);
			glass_ptr2->set_cf_out(white); 
	
			Instance* cylinder_ptr2 = new Instance (new SolidCylinder(top2, bottom2, radius)); 
			cylinder_ptr2->translate(-0.5, 0, -0.866);
			cylinder_ptr2->set_material(glass_ptr2);
			add_object(cylinder_ptr2);	
	
	
			// right cylinder
	
			double top3 	= 2.5;
			double bottom3 	= 2;
	
			RGBColor glass_color3(0, 0, 1);    	// blue
	
			Dielectric* glass_ptr3 = new Dielectric;
			glass_ptr3->set_eta_in(1.5);		// glass
			glass_ptr3->set_eta_out(1.0);		// air
			glass_ptr3->set_cf_in(glass_color3);
			glass_ptr3->set_cf_out(white); 
	
			Instance* cylinder_ptr3 = new Instance (new SolidCylinder(top3, bottom3, radius)); 
			cylinder_ptr3->translate(-0.5, 0, 0.866);
			cylinder_ptr3->set_material(glass_ptr3);
			add_object(cylinder_ptr3);	
	
	
			// white plane below disks
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(1.0);		// default
			emissive_ptr->set_ce(white);			// default
	
			Plane* plane_ptr = new Plane(Point3D(0, -1, 0), Normal(0, 1, 0)); 
			plane_ptr->set_material(emissive_ptr);
			add_object(plane_ptr);		
			break;
		}
	case 342:
		{
			//28.44a
			int num_samples = 25;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(12);
	
			background_color = RGBColor(0.9, 0.9, 1);  // pale blue
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 3); 
			pinhole_ptr->set_lookat(0.0); 
			pinhole_ptr->set_view_distance(450.0);		// for Figure 28.44(a)
		//	pinhole_ptr->set_view_distance(1800.0);		// for Figure 28.44(b)
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(10, 20, 20);
			light_ptr->scale_radiance(15.0);
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
	
			// reflective sphere inside cube
		
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.3);	
			reflective_ptr->set_kd(0.25); 
			reflective_ptr->set_cd(0, 0.25, 1);  
			reflective_ptr->set_kr(0.65); 
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(0.0), 0.75);
			sphere_ptr1->set_material(reflective_ptr); 
			add_object(sphere_ptr1);
	
	
			// transparent cube
	
			RGBColor glass_color(0.64, 0.98, 0.88);	// light cyan
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_exp(2000.0);  
			glass_ptr->set_eta_in(1.5);					// glass
			glass_ptr->set_eta_out(1.0);				// air
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(white); 
			glass_ptr->set_shadows(false);
		
			Box* box_ptr = new Box(Point3D(-1.0), Point3D(1.0));
			box_ptr->set_material(glass_ptr);
			add_object(box_ptr);
		
	
			// plane
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4.0); 
			checker_ptr->set_color1(1, 1, 0.4);    		// yellow
			checker_ptr->set_color2(1, 0.5, 0);   		// orange
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.1);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -10.1, 0), Normal(0, 1, 0)); 
			plane_ptr->set_material(sv_matte_ptr);	
			add_object(plane_ptr);
			break;
		}
	case 343:
		{
			//28.44b
			int num_samples = 25;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(12);
	
			background_color = RGBColor(0.9, 0.9, 1);  // pale blue
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 3); 
			pinhole_ptr->set_lookat(0.0); 
		//	pinhole_ptr->set_view_distance(450.0);		// for Figure 28.44(a)
			pinhole_ptr->set_view_distance(1800.0);		// for Figure 28.44(b)
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(10, 20, 20);
			light_ptr->scale_radiance(15.0);
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
	
			// reflective sphere inside cube
		
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.3);	
			reflective_ptr->set_kd(0.25); 
			reflective_ptr->set_cd(0, 0.25, 1);  
			reflective_ptr->set_kr(0.65); 
	
			Sphere*	sphere_ptr1 = new Sphere(Point3D(0.0), 0.75);
			sphere_ptr1->set_material(reflective_ptr); 
			add_object(sphere_ptr1);
	
	
			// transparent cube
	
			RGBColor glass_color(0.64, 0.98, 0.88);	// light cyan
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_exp(2000.0);  
			glass_ptr->set_eta_in(1.5);					// glass
			glass_ptr->set_eta_out(1.0);				// air
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(white); 
			glass_ptr->set_shadows(false);
		
			Box* box_ptr = new Box(Point3D(-1.0), Point3D(1.0));
			box_ptr->set_material(glass_ptr);
			add_object(box_ptr);
		
	
			// plane
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(4.0); 
			checker_ptr->set_color1(1, 1, 0.4);    		// yellow
			checker_ptr->set_color2(1, 0.5, 0);   		// orange
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.1);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Plane* plane_ptr = new Plane(Point3D(0, -10.1, 0), Normal(0, 1, 0)); 
			plane_ptr->set_material(sv_matte_ptr);	
			add_object(plane_ptr);
			break;
		}
	case 344:
		{
			//28.45
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);    
			vp.set_max_depth(4);
		
			tracer_ptr = new Whitted(this);
	
			background_color = RGBColor(0.75);  
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(1.0);
			set_ambient_light(ambient_ptr);	

	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 12, 20); 
			pinhole_ptr->set_lookat(-3.75, 3, 0);     
			pinhole_ptr->set_view_distance(1500.0);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(20, 25, -20);  
			light_ptr1->scale_radiance(3.0);  
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			float c = 1.75;  // this allows us to adjust the filter color without changing the hue
			RGBColor glass_color(0.27*c, 0.49*c, 0.42*c);  

		
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_eta_in(1.50);		// glass
			glass_ptr->set_eta_out(1.0);		// air
			glass_ptr->set_cf_in(glass_color);
			glass_ptr->set_cf_out(white); 
	
			double 	thickness 	= 0.25;
			double 	height 		= 4.0;
			double 	delta 		= 1.0;			// length change of each box
		
			int 	num_boxes 	= 10;
			double 	x_min 		= -10.0;		// where the boxes start in the x direction
			double 	gap 		= 0.5;   		// gap between the boxes
	
			for (int j = 0; j < num_boxes; j++) {
				double length = thickness + j * delta;
				Point3D p0(x_min + j * (thickness + gap), 0.0, -length);
				Point3D p1(x_min + j * (thickness + gap) + thickness, height, 0.0);
		
				Box* box_ptr = new Box(p0, p1);     
				box_ptr->set_material(glass_ptr);
				add_object(box_ptr);
			}
	
	
			// plane
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.5);
			matte_ptr->set_kd(0.65);
			matte_ptr->set_cd(0.75);
	
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 345:
		{
			//28.46
			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(3);
	
			background_color = black;  
	
			tracer_ptr = new Whitted(this);
		
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);	

			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(-1.45, 25, 22.5);  
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(3000);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
		

			// point light 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(40, 50, 0); 
			light_ptr1->scale_radiance(5.0);
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	

			// point light 
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(-10, 20, 10); 
			light_ptr2->scale_radiance(4.0);
			light_ptr2->set_shadows(true);
			add_light(light_ptr2);
	
	
			// directional light 
	
			Directional* light_ptr3 = new Directional;
			light_ptr3->set_direction(-1, 0, 0); 
			light_ptr3->scale_radiance(4.0);
			light_ptr3->set_shadows(true);
			add_light(light_ptr3);
	
	
			// checker sphere
	
			// 2D sphere checker texture
	
			SphereChecker* checker_ptr1 = new SphereChecker;
			checker_ptr1->set_num_horizontal(12); 
			checker_ptr1->set_num_vertical(12);  
			checker_ptr1->set_horizontal_line_width(0.075);
			checker_ptr1->set_vertical_line_width(0.075);
			checker_ptr1->set_color1(white);
			checker_ptr1->set_color2(0.75);
			checker_ptr1->set_line_color(black);

			// spatially varying self-emissive material
	
			SV_Emissive* sv_emissive_ptr = new SV_Emissive;
			sv_emissive_ptr->scale_radiance(20.0);	
			sv_emissive_ptr->set_ce(checker_ptr1);		
		
			Sphere* sphere_ptr1 = new Sphere;
			sphere_ptr1->set_material(sv_emissive_ptr);   
	
			Instance* big_sphere_ptr = new Instance(sphere_ptr1);
			big_sphere_ptr->scale(30.0);
			big_sphere_ptr->translate(0, 50, 45);
			add_object(big_sphere_ptr);
	
	
			// transparent sphere with grid lines
	
			// emissive material for the grid lines 
	
			Emissive* emissive_ptr = new Emissive;
			emissive_ptr->scale_radiance(0.85);
			emissive_ptr->set_ce(1, 0.7, 0);		// orange
	
	
			// dielectric material for the checkers
	
			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_ks(0.2);
			glass_ptr->set_exp(1000.0);
			glass_ptr->set_eta_in(1.5);
			glass_ptr->set_eta_out(1.0);
			glass_ptr->set_cf_in(RGBColor(0.5, 0.95, 0.92));   	
			glass_ptr->set_cf_out(white);

			// SphereMaterials material to store the grid lines and the transparent checkers
			// See the Figure 24.15(c) build function for information on this material
	
			SphereMaterials* sphere_materials_ptr = new SphereMaterials;
			sphere_materials_ptr->set_num_horizontal(12);  
			sphere_materials_ptr->set_num_vertical(6);		
			sphere_materials_ptr->set_line_width(0.03);    
			sphere_materials_ptr->set_checker1_material(glass_ptr);
			sphere_materials_ptr->set_checker2_material(glass_ptr);
			sphere_materials_ptr->set_line_material(emissive_ptr);
	
			Sphere* sphere_ptr3 = new Sphere;
			sphere_ptr3->set_material(sphere_materials_ptr);   

			Instance* sphere_ptr4 = new Instance(sphere_ptr3);
			sphere_ptr4->scale(3.0);
			add_object(sphere_ptr4);

			break;
		}
	case 346:
		{
			//28.47a
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(3);		// for Figure 28.47(a)
		//	vp.set_max_depth(4);		// for Figure 28.47(b)
		//	vp.set_max_depth(6);		// for Figure 28.47(c)
		//	vp.set_max_depth(8);		// for Figure 28.47(d)

			background_color = RGBColor(0.0, 0.13, 0.1);

			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->set_color(0.45, 0.5, 0.45);
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);

			// zoomed view of reflective sphere rotated 164 degrees
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10);
			pinhole_ptr->set_lookat(0.5, 0.0, 0.0);    
			pinhole_ptr->set_view_distance(9000.0);  	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
		
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(10, 10, 10);   
			light_ptr1->scale_radiance(7.0);  
			light_ptr1->set_shadows(false);
			add_light(light_ptr1);
		
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(-1, 0, 0);   
			light_ptr2->scale_radiance(7.0);  
			light_ptr2->set_shadows(false);
			add_light(light_ptr2);
	

			// transparent unit sphere at the origin
		
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(1.5);		// glass
			dielectric_ptr->set_eta_out(1.0);		// air
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white); 
		
			Sphere* sphere_ptr1 = new Sphere;
			sphere_ptr1->set_material(dielectric_ptr);
	
	
			// red reflective sphere inside the transparent sphere
	
			// the Reflective parameters below are for the reflective sphere in a glass sphere
			// they are too dark for the diamond sphere because of the etas
			
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.1);	
			reflective_ptr->set_kd(0.7);  
			reflective_ptr->set_cd(red);
			reflective_ptr->set_ks(0.3);  
			reflective_ptr->set_exp(200.0);
			reflective_ptr->set_kr(0.5);
			reflective_ptr->set_cr(white);
	
			double radius = 0.1;
			double distance = 0.8;   // from center of transparent sphere 
		
			Sphere* sphere_ptr2 = new Sphere(Point3D(0, 0, distance), radius);
			sphere_ptr2->set_material(reflective_ptr);
	
			// store the spheres in a compound object
	
			Compound* spheres_ptr = new Compound;
			spheres_ptr->add_object(sphere_ptr1);
			spheres_ptr->add_object(sphere_ptr2);
	
			// now store compound object in an instance so that we can rotate it
	
			Instance* rotated_spheres_ptr = new Instance(spheres_ptr);
			rotated_spheres_ptr->rotate_y(164.0);  	
			add_object(rotated_spheres_ptr);
	
	
			// ground plane
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(50.0); 
			checker3D_ptr->set_color1(0.5); 
			checker3D_ptr->set_color2(1.0); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.5);
			sv_matte_ptr->set_cd(checker3D_ptr);
		
			Plane* plane_ptr = new Plane(Point3D(0, -40.5, 0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 347:
		{
			//28.47b
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
		//	vp.set_max_depth(3);		// for Figure 28.47(a)
			vp.set_max_depth(4);		// for Figure 28.47(b)
		//	vp.set_max_depth(6);		// for Figure 28.47(c)
		//	vp.set_max_depth(8);		// for Figure 28.47(d)

			background_color = RGBColor(0.0, 0.13, 0.1);

			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->set_color(0.45, 0.5, 0.45);
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);

			// zoomed view of reflective sphere rotated 164 degrees
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10);
			pinhole_ptr->set_lookat(0.5, 0.0, 0.0);    
			pinhole_ptr->set_view_distance(9000.0);  	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
		
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(10, 10, 10);   
			light_ptr1->scale_radiance(7.0);  
			light_ptr1->set_shadows(false);
			add_light(light_ptr1);
		
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(-1, 0, 0);   
			light_ptr2->scale_radiance(7.0);  
			light_ptr2->set_shadows(false);
			add_light(light_ptr2);
	

			// transparent unit sphere at the origin
		
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(1.5);		// glass
			dielectric_ptr->set_eta_out(1.0);		// air
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white); 
		
			Sphere* sphere_ptr1 = new Sphere;
			sphere_ptr1->set_material(dielectric_ptr);
	
	
			// red reflective sphere inside the transparent sphere
	
			// the Reflective parameters below are for the reflective sphere in a glass sphere
			// they are too dark for the diamond sphere because of the etas
			
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.1);	
			reflective_ptr->set_kd(0.7);  
			reflective_ptr->set_cd(red);
			reflective_ptr->set_ks(0.3);  
			reflective_ptr->set_exp(200.0);
			reflective_ptr->set_kr(0.5);
			reflective_ptr->set_cr(white);
	
			double radius = 0.1;
			double distance = 0.8;   // from center of transparent sphere 
		
			Sphere* sphere_ptr2 = new Sphere(Point3D(0, 0, distance), radius);
			sphere_ptr2->set_material(reflective_ptr);
	
			// store the spheres in a compound object
	
			Compound* spheres_ptr = new Compound;
			spheres_ptr->add_object(sphere_ptr1);
			spheres_ptr->add_object(sphere_ptr2);
	
			// now store compound object in an instance so that we can rotate it
	
			Instance* rotated_spheres_ptr = new Instance(spheres_ptr);
			rotated_spheres_ptr->rotate_y(164.0);  	
			add_object(rotated_spheres_ptr);
	
	
			// ground plane
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(50.0); 
			checker3D_ptr->set_color1(0.5); 
			checker3D_ptr->set_color2(1.0); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.5);
			sv_matte_ptr->set_cd(checker3D_ptr);
		
			Plane* plane_ptr = new Plane(Point3D(0, -40.5, 0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 348:
		{
			//28.47c
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
		//	vp.set_max_depth(3);		// for Figure 28.47(a)
		//	vp.set_max_depth(4);		// for Figure 28.47(b)
			vp.set_max_depth(6);		// for Figure 28.47(c)
		//	vp.set_max_depth(8);		// for Figure 28.47(d)

			background_color = RGBColor(0.0, 0.13, 0.1);

			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->set_color(0.45, 0.5, 0.45);
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);

			// zoomed view of reflective sphere rotated 164 degrees
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10);
			pinhole_ptr->set_lookat(0.5, 0.0, 0.0);    
			pinhole_ptr->set_view_distance(9000.0);  	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
		
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(10, 10, 10);   
			light_ptr1->scale_radiance(7.0);  
			light_ptr1->set_shadows(false);
			add_light(light_ptr1);
		
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(-1, 0, 0);   
			light_ptr2->scale_radiance(7.0);  
			light_ptr2->set_shadows(false);
			add_light(light_ptr2);
	

			// transparent unit sphere at the origin
		
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(1.5);		// glass
			dielectric_ptr->set_eta_out(1.0);		// air
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white); 
		
			Sphere* sphere_ptr1 = new Sphere;
			sphere_ptr1->set_material(dielectric_ptr);
	
	
			// red reflective sphere inside the transparent sphere
	
			// the Reflective parameters below are for the reflective sphere in a glass sphere
			// they are too dark for the diamond sphere because of the etas
			
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.1);	
			reflective_ptr->set_kd(0.7);  
			reflective_ptr->set_cd(red);
			reflective_ptr->set_ks(0.3);  
			reflective_ptr->set_exp(200.0);
			reflective_ptr->set_kr(0.5);
			reflective_ptr->set_cr(white);
	
			double radius = 0.1;
			double distance = 0.8;   // from center of transparent sphere 
		
			Sphere* sphere_ptr2 = new Sphere(Point3D(0, 0, distance), radius);
			sphere_ptr2->set_material(reflective_ptr);
	
			// store the spheres in a compound object
	
			Compound* spheres_ptr = new Compound;
			spheres_ptr->add_object(sphere_ptr1);
			spheres_ptr->add_object(sphere_ptr2);
	
			// now store compound object in an instance so that we can rotate it
	
			Instance* rotated_spheres_ptr = new Instance(spheres_ptr);
			rotated_spheres_ptr->rotate_y(164.0);  	
			add_object(rotated_spheres_ptr);
	
	
			// ground plane
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(50.0); 
			checker3D_ptr->set_color1(0.5); 
			checker3D_ptr->set_color2(1.0); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.5);
			sv_matte_ptr->set_cd(checker3D_ptr);
		
			Plane* plane_ptr = new Plane(Point3D(0, -40.5, 0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 349:
		{
			//28.47d
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
		//	vp.set_max_depth(3);		// for Figure 28.47(a)
		//	vp.set_max_depth(4);		// for Figure 28.47(b)
		//	vp.set_max_depth(6);		// for Figure 28.47(c)
			vp.set_max_depth(8);		// for Figure 28.47(d)

			background_color = RGBColor(0.0, 0.13, 0.1);

			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->set_color(0.45, 0.5, 0.45);
			ambient_ptr->scale_radiance(0.25);
			set_ambient_light(ambient_ptr);

			// zoomed view of reflective sphere rotated 164 degrees
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 10);
			pinhole_ptr->set_lookat(0.5, 0.0, 0.0);    
			pinhole_ptr->set_view_distance(9000.0);  	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
		
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(10, 10, 10);   
			light_ptr1->scale_radiance(7.0);  
			light_ptr1->set_shadows(false);
			add_light(light_ptr1);
		
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(-1, 0, 0);   
			light_ptr2->scale_radiance(7.0);  
			light_ptr2->set_shadows(false);
			add_light(light_ptr2);
	

			// transparent unit sphere at the origin
		
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(1.5);		// glass
			dielectric_ptr->set_eta_out(1.0);		// air
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white); 
		
			Sphere* sphere_ptr1 = new Sphere;
			sphere_ptr1->set_material(dielectric_ptr);
	
	
			// red reflective sphere inside the transparent sphere
	
			// the Reflective parameters below are for the reflective sphere in a glass sphere
			// they are too dark for the diamond sphere because of the etas
			
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.1);	
			reflective_ptr->set_kd(0.7);  
			reflective_ptr->set_cd(red);
			reflective_ptr->set_ks(0.3);  
			reflective_ptr->set_exp(200.0);
			reflective_ptr->set_kr(0.5);
			reflective_ptr->set_cr(white);
	
			double radius = 0.1;
			double distance = 0.8;   // from center of transparent sphere 
		
			Sphere* sphere_ptr2 = new Sphere(Point3D(0, 0, distance), radius);
			sphere_ptr2->set_material(reflective_ptr);
	
			// store the spheres in a compound object
	
			Compound* spheres_ptr = new Compound;
			spheres_ptr->add_object(sphere_ptr1);
			spheres_ptr->add_object(sphere_ptr2);
	
			// now store compound object in an instance so that we can rotate it
	
			Instance* rotated_spheres_ptr = new Instance(spheres_ptr);
			rotated_spheres_ptr->rotate_y(164.0);  	
			add_object(rotated_spheres_ptr);
	
	
			// ground plane
	
			Checker3D* checker3D_ptr = new Checker3D;
			checker3D_ptr->set_size(50.0); 
			checker3D_ptr->set_color1(0.5); 
			checker3D_ptr->set_color2(1.0); 
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.5);
			sv_matte_ptr->set_cd(checker3D_ptr);
		
			Plane* plane_ptr = new Plane(Point3D(0, -40.5, 0), Normal(0, 1, 0));  
			plane_ptr->set_material(sv_matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 350:
		{
			//28.48
			int num_samples = 9;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(8);
		
			background_color = RGBColor(0.5, 0.5, 1.0);  // light blue
	
			tracer_ptr = new Whitted(this);
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, -2, 0);      
			pinhole_ptr->set_lookat(0, -10, 0);
			pinhole_ptr->set_view_distance(200.0);  
			pinhole_ptr->set_exposure_time(0.17);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(0, 1, 0);    // straight down
			light_ptr1->scale_radiance(3.0); 
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);
	
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(0, -1, 0);    // straight up
			light_ptr2->scale_radiance(2.5); 
			light_ptr2->set_shadows(false);
			add_light(light_ptr2);
	
	
			// transparent sphere
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(2.42);		// diamond
			dielectric_ptr->set_eta_out(1.0);		// air
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white); 
		
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0), 4.0);
			sphere_ptr1->set_material(dielectric_ptr);
			add_object(sphere_ptr1);	
	
	
	
			// a ring of spheres around the transparent sphere
	
			double 	scaling_factor 	= 2.0;  	// used to scale the radii of the ring and spheres
			double 	sphere_radius 	= 1.75 * scaling_factor;
			double 	ring_radius 	= 10.0 * scaling_factor;
			int 	num_spheres 	= 20;
			int 	delta_theta 	= 20;

			RGBColor color1(1, 0.5, 0);          // orange
			RGBColor color2(0.0, 0.5, 0.25);	  // cyan
	
	
			// Phong material for top half of each sphere
	
			Phong* phong_ptr1 = new Phong;		
			phong_ptr1->set_ka(0.2);
			phong_ptr1->set_kd(1.0);
			phong_ptr1->set_cd(color1);
			phong_ptr1->set_exp(100.0);
			phong_ptr1->set_ks(0.5);
			phong_ptr1->set_cs(1, 1, 0);
	
	
			// reflective material for bottom half of each sphere
	
			Reflective* reflective_ptr2 = new Reflective;
			reflective_ptr2->set_ka(0.2);
			reflective_ptr2->set_kd(1.0);
			reflective_ptr2->set_cd(color2);
			reflective_ptr2->set_exp(100.0);
			reflective_ptr2->set_ks(0.5);
			reflective_ptr2->set_cs(1, 1, 0);
			reflective_ptr2->set_kr(0.2);
	
	
			for (int j = 0; j < num_spheres; j++) {
				double xc = ring_radius * sin (j * delta_theta * PI / 180.0);
				double zc = ring_radius * cos (j * delta_theta * PI / 180.0);
				Point3D center(xc, 0, zc);
		
				ConvexPartSphere* top_half_ptr = new ConvexPartSphere(center, sphere_radius, 0, 360, 0, 90);
				top_half_ptr->set_material(phong_ptr1);
				add_object(top_half_ptr);
		
				ConvexPartSphere* bottom_half_ptr = new ConvexPartSphere(center, sphere_radius, 0, 360, 90, 180);
				bottom_half_ptr->set_material(reflective_ptr2);
				add_object(bottom_half_ptr);
			}
	

			// reflective ground plane
	
			Reflective* reflective_ptr = new Reflective;
			reflective_ptr->set_ka(0.0);
			reflective_ptr->set_kd(0.1);
			reflective_ptr->set_cd(1, 1, 0);
			reflective_ptr->set_kr(1.0);
			reflective_ptr->set_cr(white);
		
			Plane* plane_ptr = new Plane(Point3D(0, -4.5, 0), Normal(0, 1, 0)); 
			plane_ptr->set_material(reflective_ptr);
			add_object(plane_ptr);
			break;
		}
	case 351:
		{
			//28.49
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(350);
			vp.set_samples(num_samples);	
			vp.set_max_depth(6);		
	
			background_color = white;
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			tracer_ptr = new Whitted(this);
	
			Pinhole* pinhole_ptr = new Pinhole;	
			pinhole_ptr->set_eye(0, 0, 1000);    
			pinhole_ptr->set_lookat(0, 0, 0);
			pinhole_ptr->set_view_distance(35000.0);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(1.5);   
			dielectric_ptr->set_eta_out(1.0);
			dielectric_ptr->set_cf_in(RGBColor(0.9, 0.7, 0));   // orange
			dielectric_ptr->set_cf_out(1.0);

			Instance* sphere_ptr1 = new Instance(new Sphere);
			sphere_ptr1->set_material(dielectric_ptr);
			sphere_ptr1->scale(4.0);
			sphere_ptr1->translate(-4.2, 0.0, 0.0);
			add_object(sphere_ptr1);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(4.2, 0, 0), 4);
			sphere_ptr2->set_material(dielectric_ptr);
			add_object(sphere_ptr2);
			break;
		}
	case 352:
		{
			//28.50
			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(15);
	
			tracer_ptr = new Whitted(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(1, 0.5, 4);      
			pinhole_ptr->set_lookat(-3, -10, 0); 	   
			pinhole_ptr->set_view_distance(200.0);  
			pinhole_ptr->set_exposure_time(0.17);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
	
			// transparent sphere
	
			Dielectric* dielectric_ptr = new Dielectric;
			dielectric_ptr->set_eta_in(2.42);		// diamond
			dielectric_ptr->set_eta_out(1.0);		// air
			dielectric_ptr->set_cf_in(white);
			dielectric_ptr->set_cf_out(white); 
		
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0), 4.0);
			sphere_ptr1->set_material(dielectric_ptr);
		
	
			// scale the sphere into an ellipsoid
	
			Instance* ellipsoid_ptr = new Instance(sphere_ptr1);
			ellipsoid_ptr->scale(1.0, 0.75, 2.0);
			add_object(ellipsoid_ptr);
		
	
			// emissive concave sphere with checkers
	
			RGBColor c1(0, 0.25, 0.35);
			RGBColor c2(1, 1, 0.5);
	
			SphereChecker* checker_ptr = new SphereChecker;
			checker_ptr->set_num_horizontal(12);  
			checker_ptr->set_num_vertical(6);    
			checker_ptr->set_horizontal_line_width(0.0);
			checker_ptr->set_vertical_line_width(0.0);
			checker_ptr->set_color1(c1);   
			checker_ptr->set_color2(c2); 
			checker_ptr->set_line_color(black);  
		
			SV_Emissive* sv_emissive_ptr = new SV_Emissive;
			sv_emissive_ptr->scale_radiance(1.0);
			sv_emissive_ptr->set_ce(checker_ptr);

			ConcaveSphere* sphere_ptr2 = new ConcaveSphere;  // you will have to implement this
			sphere_ptr2->set_material(sv_emissive_ptr);		 // or use a default ConcavePartSphere
	
			Instance* sphere_ptr3 = new Instance(sphere_ptr2);
			sphere_ptr3->scale(100.0);
			add_object(sphere_ptr3);
			break;
		}
	case 353:
		{
			//28.52
			int num_samples = 25;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_max_depth(12);    

			background_color = RGBColor(0.8, 0.9, 1);
	
			tracer_ptr = new Whitted(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);

	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, -1, 4);     
			pinhole_ptr->set_lookat(0, 0, 0);    
			pinhole_ptr->set_view_distance(700.0);	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr);
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(10, 30, 30); 
			light_ptr->scale_radiance(3.0);        
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// reflective unit sphere
	
			Reflective*	reflective_ptr = new Reflective;
			reflective_ptr->set_ka(1.0);	
			reflective_ptr->set_kd(0.5);  
			reflective_ptr->set_cd(1, 0.5, 0);			// orange
			reflective_ptr->set_ks(0.5);
			reflective_ptr->set_exp(500.0);
			reflective_ptr->set_kr(0.5);
			reflective_ptr->set_shadows(false);
		
			Sphere* sphere_ptr = new Sphere;
			sphere_ptr->set_material(reflective_ptr);
	

			Dielectric* glass_ptr = new Dielectric;
			glass_ptr->set_eta_in(1.5);
			glass_ptr->set_eta_out(1.0);
			double c = 0.9;
			glass_ptr->set_cf_in(RGBColor(0.9 * c, 1 * c, 0.85 * c));
			glass_ptr->set_cf_out(white);

			// concave cap
	
			double radius 			= 1.5;									
			double min_angle 		= 115;  			
			double max_angle 		= 180;
			double displacement 	= -radius * cos(min_angle * PI_ON_180);
			double rim_radius 		= radius * sin(min_angle * PI_ON_180);
			Point3D center(0.0);
		
			ConcavePartSphere* part_sphere_ptr = new ConcavePartSphere(center, radius, 0, 360, min_angle, max_angle); 

			Instance* concave_cap_ptr = new Instance (part_sphere_ptr); 
			concave_cap_ptr->translate(0, displacement, 0);

			CutFace* cut_face_ptr = new CutFace(4.0, rim_radius);
	
			// put these two objects in a compound object so that they can be transformed together
	
			Compound* facet_ptr = new Compound;
			facet_ptr->add_object(concave_cap_ptr);
			facet_ptr->add_object(cut_face_ptr);
			facet_ptr->set_material(glass_ptr);

			// define the six cube faces

			// front face (+ve z)
	
			Instance* front_ptr = new Instance(facet_ptr); 
			front_ptr->rotate_x(90);
			front_ptr->translate(0, 0, 2);	
	
	
			// back face (-ve z)
	
			Instance* back_ptr = new Instance(facet_ptr); 
			back_ptr->rotate_x(-90);
			back_ptr->translate(0, 0, -2);
	
		
			// bottom face (-ve y)
	
			Instance* bottom_ptr = new Instance(facet_ptr); 
			bottom_ptr->rotate_z(180);
			bottom_ptr->translate(0, -2, 0);
	
	
			// top face (+ve y)
	
			Instance* top_ptr = new Instance(facet_ptr); 
			top_ptr->translate(0, 2, 0);
	
	
	
	
			// a rectangle for the left and right cube faces

			Point3D p0(-2.0, 0.0, -2.0);
			Vector3D a(0.0, 0.0, 4.0);
			Vector3D b(4.0, 0.0, 0.0);
			TRectangle* rect = new TRectangle(p0, a, b);  
			rect->set_material(glass_ptr);
	
	
			// left face (-ve x)
	
			Instance* left_ptr = new Instance(rect); 
			left_ptr->rotate_z(90);
			left_ptr->translate(-2, 0, 0);
	
	
			// right face (+ve x)
	
			Instance* right_ptr = new Instance(rect); 
			right_ptr->rotate_z(-90);
			right_ptr->translate(2, 0, 0);
	
	
			// put all six faces into a compound object so we can rotate it
	
			Compound* cube_ptr = new Compound;
			cube_ptr->add_object(front_ptr);			// facet
			cube_ptr->add_object(back_ptr);				// facet
			cube_ptr->add_object(top_ptr);				// facet
			cube_ptr->add_object(bottom_ptr);			// facet
			cube_ptr->add_object(left_ptr);				// rectangle
			cube_ptr->add_object(right_ptr);			// rectangle
			cube_ptr->add_object(sphere_ptr);
	
			Instance* cube_ptr2 = new Instance(cube_ptr);
			cube_ptr2->rotate_z(45);
			cube_ptr2->rotate_x(35);
			add_object(cube_ptr2);
	
	
	
			// ground plane with checker
		
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(1.0);
			checker_ptr->set_color1(white);  
			checker_ptr->set_color2(0.5);
		
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.75);
			sv_matte_ptr->set_cd(checker_ptr);

			Plane* plane_ptr1 = new Plane(Point3D(0, -4.01, 0), Normal(0, 1, 0));  
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);	
			break;
		}
	case 354:
		{
			//29.01
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(ppmfile+"GreenAndYellow.ppm").toLatin1().data()))
				return;
			if( !CheckFile(QString(ppmfile+"EarthHighRes.ppm").toLatin1().data()))
				return;
			if( !CheckFile(QString(ppmfile+"BlueGlass.ppm").toLatin1().data()))
				return;
			if( !CheckFile(QString(ppmfile+"GrayMarbleRamp.ppm").toLatin1().data()))
				return;
			if( !CheckFile(QString(ppmfile+"sandstone_ramp1.ppm").toLatin1().data()))
				return;

			//	int num_samples = 1;			// development
			int num_samples = 16;			// production
	
		//	vp.set_hres(475);				// development
		//	vp.set_vres(250); 
			vp.set_hres(950);				// production
			vp.set_vres(500);
			vp.set_samples(num_samples);	
			vp.set_max_depth(2);
		
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			tracer_ptr = new Whitted(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 15, 50);
			pinhole_ptr->set_lookat(0.4, 3.0, 0.0); 
		//	pinhole_ptr->set_view_distance(600.0);		// for 475 x 250
			pinhole_ptr->set_view_distance(1200.0);   	// for 950 X 500
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(14, 50, 50);  
			light_ptr->scale_radiance(3.0);  
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
	
			// ************************************************************************************************* walls
	
			// these are not textured
	
			// back wall 
	
			Matte* matte_ptr1 = new Matte;		
			matte_ptr1->set_ka(0.75);
			matte_ptr1->set_kd(0.5);
			matte_ptr1->set_cd(0.85);  
	
			Plane* back_wall_ptr = new Plane(Point3D(0, 0, 0), Normal(0, 0, 1));
			back_wall_ptr->set_material(matte_ptr1);
			add_object(back_wall_ptr);
	
	
			// front wall 
	
			Matte* matte_ptr2 = new Matte;		
			matte_ptr2->set_ka(1.0);
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(white);
	
			Plane* front_wall_ptr = new Plane(Point3D(0, 0, 51), Normal(0, 0, -1));
			front_wall_ptr->set_material(matte_ptr2);
			add_object(front_wall_ptr);
	
	
			// left wall 
	
			Matte* matte_ptr3 = new Matte;		
			matte_ptr3->set_ka(0.25);
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(0.75, 1.0, 1.0);    
	
			Plane* left_wall_ptr = new Plane(Point3D(-15, 0, 0), Normal(1, 0, 0));
			left_wall_ptr->set_material(matte_ptr3);
			add_object(left_wall_ptr);

	
			// right wall 
	
			Matte* matte_ptr4 = new Matte;		
			matte_ptr4->set_ka(0.5);
			matte_ptr4->set_kd(0.5);
			matte_ptr4->set_cd(0.75, 1.0, 1.0); 

			Plane* right_wall_ptr = new Plane(Point3D(15, 0, 0), Normal(-1, 0, 0));
			right_wall_ptr->set_material(matte_ptr4);
			add_object(right_wall_ptr);
	
	
			// there is no ceiling

			// ************************************************************************************************* floor planks
	
			// plain material	
	
			Phong* phong_ptr = new Phong;		
			phong_ptr->set_ka(0.5);  
			phong_ptr->set_kd(1.0);
			phong_ptr->set_ks(0.2);  
			phong_ptr->set_exp(20.0);
			phong_ptr->set_cd(0.5, 0.3, 0.1);
			
			// the floor is a simulation of wood planks using beveled boxes with random lengths in the x direction
	
			double 	x0 					= -15.0;				// planks start at x = x0
			double 	z0 					= 0.0;					// planks start at z = z0
			double 	min_length 			= 4.0;   				// minumum plank length in x direction
			double 	max_length 			= 10.0;	  				// maximum plank length in x direction
			double 	plank_thickness 	= 1.0;					// common plank thickness - in y direction
			double 	y0					= -plank_thickness; 	// places top of planks at y = 0;
			double	plank_width			= 1.0;  				// common plank width 
			double 	plank_bevel			= 0.25;    				// the bevel radius
			int 	num_x_planks		= 6;					// number of planks in the x direction (a single column)
			int 	num_z_columns		= 50;  					// number of plank columns in the z direction
		
			Grid* planks_ptr = new Grid;
	
			for (int iz = 0; iz < num_z_columns; iz++) {     // to the front
				double p0x = x0;
		
				for (int ix = 0; ix < num_x_planks; ix++) {  // to the right
					TInstance* wood_ptr = new TInstance(new Wood(RGBColor(0.5, 0.3, 0.1), black));
					wood_ptr->scale(5.0);
					wood_ptr->rotate_y(90);
					set_rand_seed(ix * 1000 + iz * 10000);  // this must go right here
					wood_ptr->translate(10.0 * (2.0 * rand_float() - 1.0), 20.0 * (2.0 * rand_float() - 1.0), 30.0 * (2.0 * rand_float() - 1.0));
			
					SV_Phong* sv_phong_ptr = new SV_Phong;		
					sv_phong_ptr->set_ka(0.5);  
					sv_phong_ptr->set_kd(1);
					sv_phong_ptr->set_ks(0.2);  
					sv_phong_ptr->set_exp(20.0);
					sv_phong_ptr->set_cd(wood_ptr);
					sv_phong_ptr->set_cs(new ConstantColor());   // white, by default
				
					set_rand_seed(ix * 10000 + iz * 100);
					double plank_length = min_length + rand_float() * (max_length - min_length);
						
					Point3D p0(p0x ,y0, iz * plank_width);
					Point3D p1(p0x + plank_length, y0 + plank_thickness, (iz + 1) * plank_width);
		
					BeveledBox* plank_ptr = new BeveledBox(p0, p1, plank_bevel);
					plank_ptr->set_material(phong_ptr);			// plain
		//			plank_ptr->set_material(sv_phong_ptr);		// textured
					planks_ptr->add_object(plank_ptr);
			
					p0x += plank_length;
				}
			}
		
			planks_ptr->setup_cells();
			add_object(planks_ptr);   
	
			// ************************************************************************************************* checkered cylinder
	
			// plain material 
	
			Matte* matte_ptr5 = new Matte;		
			matte_ptr5->set_ka(0.25);
			matte_ptr5->set_kd(0.95);
			matte_ptr5->set_cd(0.1, 0.4, 0.15);

			// textured material for the curved surface
			// this is a checker image
	
			Image* image_ptr1 = new Image;					
			image_ptr1->read_ppm_file(QString(ppmfile+"GreenAndYellow.ppm").toLatin1().data());
			CylindericalMap* cylindrical_map_ptr = new CylindericalMap;   
			ImageTexture* image_texture_ptr1 = new ImageTexture(image_ptr1); 
			image_texture_ptr1->set_mapping(cylindrical_map_ptr);

			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.25);
			sv_matte_ptr1->set_kd(0.95);
			sv_matte_ptr1->set_cd(image_texture_ptr1);
	
			OpenCylinder* cylinder_ptr1 = new OpenCylinder(-1.0, 1.0, 1.0);  // default
			cylinder_ptr1->set_material(matte_ptr5);		// plain
		//	cylinder_ptr1->set_material(sv_matte_ptr1); 	// textured
	
			Instance* cylinder_ptr2 = new Instance(cylinder_ptr1); 
			cylinder_ptr2->translate(Vector3D(0, 1, 0));
			cylinder_ptr2->scale(2, 2.5, 2);
			cylinder_ptr2->translate(Vector3D(-11, 0, 12));
			add_object(cylinder_ptr2);
	
	
			// a disk for the cylinder top
			// this is a 2D procedural checker texture designed to match the checkers
			// on the curved surface
	
			DiskChecker* disk_checker_ptr = new DiskChecker;
			disk_checker_ptr->set_num_angular_checkers(20);
			disk_checker_ptr->set_num_radial_checkers(4);
			disk_checker_ptr->set_angular_line_width(0.0);
			disk_checker_ptr->set_radial_line_width(0.0);
			disk_checker_ptr->set_color1(0.08, 0.39, 0.14);  	// dark green
			disk_checker_ptr->set_color2(1.0, 1.0, 0.5);		// yellow
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.35);
			sv_matte_ptr2->set_kd(0.5);
			sv_matte_ptr2->set_cd(disk_checker_ptr);
	
			Disk* disk_ptr = new Disk;					// default - center (0, 0, 0), radius 1
			disk_ptr->set_material(matte_ptr5);			// plain
		//	disk_ptr->set_material(sv_matte_ptr2);		// textured
			Instance* cylinder_top_ptr = new Instance(disk_ptr);
			cylinder_top_ptr->scale(2, 1, 2);
			cylinder_top_ptr->translate(-11, 5, 12);
			add_object(cylinder_top_ptr); 
	
			// ************************************************************************************************* Earth sphere
	
			// plain material
	
			Matte* matte_ptr6 = new Matte;		
			matte_ptr6->set_ka(0.5);
			matte_ptr6->set_kd(0.5);
			matte_ptr6->set_cd(0.2, 0.5, 1);

			// Earth image texture
	
			Image* image_ptr2 = new Image;					
		//	image_ptr2->read_ppm_file("EarthLowRes.ppm");
			image_ptr2->read_ppm_file(QString(ppmfile+"EarthHighRes.ppm").toLatin1().data());
			SphericalMap* spherical_map_ptr = new SphericalMap;   
			ImageTexture* image_texture_ptr2 = new ImageTexture(image_ptr2); 
			image_texture_ptr2->set_mapping(spherical_map_ptr);
	
			SV_Matte* sv_matte_ptr3 = new SV_Matte;		
			sv_matte_ptr3->set_ka(0.5);
			sv_matte_ptr3->set_kd(0.95);
			sv_matte_ptr3->set_cd(image_texture_ptr2);
	
			Sphere* sphere_ptr1 = new Sphere;
			sphere_ptr1->set_material(matte_ptr6);				// plain 
		//	sphere_ptr1->set_material(sv_matte_ptr3);			// textured with Earth image
		
			Instance* sphere_ptr2 = new Instance(sphere_ptr1);
			sphere_ptr2->rotate_y(75);
			sphere_ptr2->scale(3);
			sphere_ptr2->translate(-11, 8, 12);
			add_object(sphere_ptr2);
	
			// ************************************************************************************************* picture on back wall
	
			// this is initially constructed in the (x, z) plane, and then moved to the back wall
			// the picture and its frame are stored in a compound object:
	
			Compound* framed_picture_ptr = new Compound;
	
			// dimensions
	
			double a = 3.5;  	// +ve x coordinate of untransformed image
			double b = 5.05; 	// +ve z coordinate of untransformed image
			double w = 1.0;		// width of the frame
	
	
			// plain material picture
	
			Matte* matte_ptr7 = new Matte;		
			matte_ptr7->set_ka(0.75);
			matte_ptr7->set_kd(0.5);
			matte_ptr7->set_cd(0.3, 0.65, 0.71);
	
			// the image is applied to a rectangle
	
			Image* image_ptr3 = new Image;					
			image_ptr3->read_ppm_file(QString(ppmfile+"BlueGlass.ppm").toLatin1().data());
	
			//SquareMap* square_map_ptr = new SquareMap;   
			RectangularMap* square_map_ptr = new RectangularMap;   
	
			ImageTexture* image_texture_ptr3 = new ImageTexture(image_ptr3); 
			image_texture_ptr3->set_mapping(square_map_ptr);
	
			SV_Matte* sv_matte_ptr4 = new SV_Matte;		
			sv_matte_ptr4->set_ka(0.5);
			sv_matte_ptr4->set_kd(0.75);
			sv_matte_ptr4->set_cd(image_texture_ptr3);
	
			// construct the picture
	
			TRectangle* rectangle_ptr = new TRectangle;
			rectangle_ptr->set_material(matte_ptr7);  	// plain
		//	rectangle_ptr->set_material(sv_matte_ptr4);  // textured with Blue Glass
	
			Instance* picture_ptr = new Instance(rectangle_ptr);  
			picture_ptr->scale(a, 1, b);
	
			// construct the frame
	
			// plain material for the frame
	
			Matte* matte_ptr8 = new Matte;		
			matte_ptr8->set_ka(0.75);
			matte_ptr8->set_kd(0.5);
			matte_ptr8->set_cd(0.5, 0.3, 0.14);
	
			// wood materials for the frame

			// for front and back sides

			TInstance* wood_ptr1 = new TInstance(new Wood(RGBColor(0.55, 0.43, 0.13), black));
			wood_ptr1->scale(2);
			wood_ptr1->rotate_y(90);
	
			SV_Matte* sv_matte_ptr5 = new SV_Matte;		
			sv_matte_ptr5->set_ka(1.0);
			sv_matte_ptr5->set_kd(1.0);
			sv_matte_ptr5->set_cd(wood_ptr1);
	
			// for right and left sides

			TInstance* wood_ptr2 = new TInstance(new Wood(RGBColor(0.55, 0.43, 0.13), black));
			wood_ptr2->scale(2.0);

			SV_Matte* sv_matte_ptr6 = new SV_Matte;		
			sv_matte_ptr6->set_ka(1.0);
			sv_matte_ptr6->set_kd(1.0);
			sv_matte_ptr6->set_cd(wood_ptr2);
		
			// construct the frame: two triangles per side
	
			// front side: +ve z before any transformations
	
			Triangle* triangle_ptr1 = new Triangle (Point3D(-a, 0, b), Point3D(-a - w, 0, b + w), Point3D(a + w, 0, b + w));
			triangle_ptr1->set_material(sv_matte_ptr5);
			framed_picture_ptr->add_object(triangle_ptr1);
	
			Triangle* triangle_ptr2 = new Triangle (Point3D(-a, 0, b), Point3D(a + w, 0, b + w), Point3D(a, 0, b));
			triangle_ptr2->set_material(sv_matte_ptr5);
			framed_picture_ptr->add_object(triangle_ptr2);
	
			// back side: -ve z before any transformations
	
			Triangle* triangle_ptr3 = new Triangle (Point3D(a, 0, -b), Point3D(a + w, 0, -b - w), Point3D(-a - w, 0, -b - w));
			triangle_ptr3->set_material(sv_matte_ptr5);
			framed_picture_ptr->add_object(triangle_ptr3);
	
			Triangle* triangle_ptr4 = new Triangle (Point3D(a, 0, -b), Point3D(-a - w, 0, -b - w), Point3D(-a, 0, -b));
			triangle_ptr4->set_material(sv_matte_ptr5);
			framed_picture_ptr->add_object(triangle_ptr4);
	
			// right side: +ve x before any transformations
	
			Triangle* triangle_ptr5 = new Triangle (Point3D(a, 0, b), Point3D(a + w, 0, b + w), Point3D(a + w, 0, -b - w));
			triangle_ptr5->set_material(sv_matte_ptr6);
			framed_picture_ptr->add_object(triangle_ptr5);
	
			Triangle* triangle_ptr6 = new Triangle (Point3D(a, 0, b), Point3D(a + w, 0, -b - w), Point3D(a, 0, -b));
			triangle_ptr6->set_material(sv_matte_ptr6);
			framed_picture_ptr->add_object(triangle_ptr6);
	
			// left side: -ve x before any transformations
	
			Triangle* triangle_ptr7 = new Triangle (Point3D(-a, 0, -b), Point3D(-a - w, 0, -b - w), Point3D(-a - w, 0, b + w));
			triangle_ptr7->set_material(sv_matte_ptr6);
			framed_picture_ptr->add_object(triangle_ptr7);
	
			Triangle* triangle_ptr8 = new Triangle (Point3D(-a, 0, -b), Point3D(-a - w, 0, b + w), Point3D(-a, 0, b));
			triangle_ptr8->set_material(sv_matte_ptr6);
			framed_picture_ptr->add_object(triangle_ptr8);
	
			framed_picture_ptr->set_material(matte_ptr8);    // plain material for the frame - replaces all the wood textures - see Listing 19.13
			framed_picture_ptr->add_object(picture_ptr);	
	
			Instance* wall_picture_ptr = new Instance(framed_picture_ptr);	
			wall_picture_ptr->rotate_y(90);
			wall_picture_ptr->rotate_x(90);
			wall_picture_ptr->translate(-6, 8, 0.5);
			add_object(wall_picture_ptr);

			// ************************************************************************************************* bunny
	
			// plain material for the bunny	
	
			Matte* matte_ptr9 = new Matte;		
			matte_ptr9->set_ka(0.25);
			matte_ptr9->set_kd(0.75);   
			matte_ptr9->set_cd(0.8);	
	
			// ramp based marble texture
	
			Image* image_ptr4 = new Image;						
			image_ptr4->read_ppm_file(QString(ppmfile+"GrayMarbleRamp.ppm").toLatin1().data());
	
			int 	num_octaves = 4;
			float 	fbm_amount 	= 3.0;
			TInstance* marble_ptr = new TInstance(new RampFBmTexture(image_ptr4, num_octaves, fbm_amount));	//RampMarble
			marble_ptr->scale(0.0075);  // the bunny is small
			marble_ptr->translate(0.5, 0.0, 0.0);
			marble_ptr->rotate_x(100);
			marble_ptr->rotate_z(30);
			marble_ptr->rotate_y(20);

			// marble material

			SV_Matte* sv_matte_ptr7 = new SV_Matte;		
			sv_matte_ptr7->set_ka(0.25);
			sv_matte_ptr7->set_kd(0.75);
			sv_matte_ptr7->set_cd(marble_ptr);
	
			Mesh* mesh_ptr = new Mesh;
		//	const char* fileName = "Bunny4K.ply"; 		// development
		//	const char* fileName = "Bunny16K.ply";   	// production
	
			Grid* grid_ptr = new Grid(mesh_ptr);
			grid_ptr->read_smooth_triangles(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data());
			grid_ptr->set_material(matte_ptr9);			// plain
		//	grid_ptr->set_material(sv_matte_ptr7); 		// textured
			grid_ptr->setup_cells();
	
			Instance* bunny_ptr = new Instance(grid_ptr);
			bunny_ptr->scale(47.0);
			bunny_ptr->translate(-3.25, -1.65, 10);
			add_object(bunny_ptr);
	
			// ************************************************************************************************* bath sides
	
			// the front and back sides of the bath run right across the bath in the x direction
			// the left and right sides fit between the front and back in the z direction
			// the sides are rows of beveled boxes with a random sandstone texture applied
			// these are stored in a single grid
	
			double 	bath_xmin 			= 1.0;
			double 	bath_zmin 			= 0.0;  
			double 	bath_xmax 			= 15.0;
			double 	bath_zmax 			= 15.0;   
			double 	x_size 				= bath_xmax - bath_xmin;
			double 	z_size 				= bath_zmax - bath_zmin;
			double 	thickness 			= 1.5;  	// common box thickness = side thickness
			double 	bath_height 		= 2.5;		// common box height 
			double 	bath_bevel_radius	= 0.25;  
			int 	num_xboxes			= 4;		// number of boxes along the back and front sides
			int 	num_zboxes			= 3;		// number of boxes along the left and right sides
		
			float bath_ka 				= 0.5;  	// common material property
			float bath_kd 				= 0.85; 	// common material property
	
			// plain material 
	
			Matte* matte_ptr10 = new Matte;				
			matte_ptr10->set_ka(bath_ka);
			matte_ptr10->set_kd(bath_kd);
			matte_ptr10->set_cd(0.53, 0.51, 0.45);
	
			// sandstone texture
	
			Image* image_ptr5 = new Image;						
			image_ptr5->read_ppm_file(QString(ppmfile+"sandstone_ramp1.ppm").toLatin1().data());
	
			num_octaves = 4;
			fbm_amount	= 0.1;
	
			Grid* bath_ptr = new Grid;
	
			// build back - runs in x direction
	
			for (int j = 0; j < num_xboxes; j++) {
	
				// put a sandstone texture with a random set of intrinsic transformations on the beveled boxes
				
				TInstance* sandstone_ptr = new TInstance(new RampFBmTexture(image_ptr5, num_octaves, fbm_amount));
				sandstone_ptr->scale(2.0);
				set_rand_seed(j * 10);
				sandstone_ptr->rotate_x(20.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->rotate_y(30.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->rotate_z(45.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->translate(10.0 * (2.0 * rand_float() - 1.0), 20.0 * (2.0 * rand_float() - 1.0), 30.0 * (2.0 * rand_float() - 1.0));
		
				SV_Matte* sv_matte_ptr = new SV_Matte;		
				sv_matte_ptr->set_ka(bath_ka);
				sv_matte_ptr->set_kd(bath_kd);
				sv_matte_ptr->set_cd(sandstone_ptr);
				
				BeveledBox* box_ptr = new BeveledBox(	Point3D(bath_xmin + j * (x_size / num_xboxes), 0, bath_zmin), 
														Point3D(bath_xmin + (j + 1) * (x_size / num_xboxes), bath_height, bath_zmin + thickness),
														bath_bevel_radius);
				box_ptr->set_material(sv_matte_ptr);
				bath_ptr->add_object(box_ptr);
			}
		
			// build front - runs in xw direction
	
			for (int j = 0; j < num_xboxes; j++) {
				
				TInstance* sandstone_ptr = new TInstance(new RampFBmTexture(image_ptr5, num_octaves, fbm_amount));
				sandstone_ptr->scale(2.0);
				set_rand_seed(j * 1000000);
				sandstone_ptr->rotate_x(20.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->rotate_y(30.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->rotate_z(45.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->translate(10.0 * (2.0 * rand_float() - 1.0), 20.0 * (2.0 * rand_float() - 1.0), 30.0 * (2.0 * rand_float() - 1.0));
			
				SV_Matte* sv_matte_ptr = new SV_Matte;		
				sv_matte_ptr->set_ka(bath_ka);
				sv_matte_ptr->set_kd(bath_kd);
				sv_matte_ptr->set_cd(sandstone_ptr);
		
				BeveledBox* box_ptr = new BeveledBox(	Point3D(bath_xmin + j * (x_size / num_xboxes), 0, bath_zmax - thickness), 
														Point3D(bath_xmin + (j + 1) * (x_size / num_xboxes), bath_height, bath_zmax),
														bath_bevel_radius);
				box_ptr->set_material(sv_matte_ptr);
				bath_ptr->add_object(box_ptr);
			}
	
			// build left side - runs in yw direction
	
			for (int j = 0; j < num_zboxes; j++) {
		
				TInstance* sandstone_ptr = new TInstance(new RampFBmTexture(image_ptr5, num_octaves, fbm_amount));
				sandstone_ptr->scale(2.0);
				set_rand_seed(j * 1000);
				sandstone_ptr->rotate_x(20.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->rotate_y(30.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->rotate_z(45.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->translate(10.0 * (2.0 * rand_float() - 1.0), 20.0 * (2.0 * rand_float() - 1.0), 30.0 * (2.0 * rand_float() - 1.0));
	
				SV_Matte* sv_matte_ptr = new SV_Matte;		
				sv_matte_ptr->set_ka(bath_ka);
				sv_matte_ptr->set_kd(bath_kd);
				sv_matte_ptr->set_cd(sandstone_ptr);
		
				BeveledBox* box_ptr = new BeveledBox(	Point3D(bath_xmin, 0, bath_zmin + thickness + j * ((z_size - 2 * thickness) / num_zboxes)),
														Point3D(bath_xmin + thickness, bath_height, bath_zmin + thickness + (j + 1) * ((z_size - 2 * thickness) / num_zboxes)),
														bath_bevel_radius);
				box_ptr->set_material(sv_matte_ptr);
				bath_ptr->add_object(box_ptr);
			}
	
			// build right side - runs in yw direction
	
			for (int j = 0; j < num_zboxes; j++) {
		
				TInstance* sandstone_ptr = new TInstance(new RampFBmTexture(image_ptr5, num_octaves, fbm_amount));
				sandstone_ptr->scale(2.0);
				set_rand_seed(j * 10000);
				sandstone_ptr->rotate_x(20.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->rotate_y(30.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->rotate_z(45.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->translate(10.0 * (2.0 * rand_float() - 1.0), 20.0 * (2.0 * rand_float() - 1.0), 30.0 * (2.0 * rand_float() - 1.0));
	
				SV_Matte* sv_matte_ptr = new SV_Matte;		
				sv_matte_ptr->set_ka(bath_ka);
				sv_matte_ptr->set_kd(bath_kd);
				sv_matte_ptr->set_cd(sandstone_ptr);
		
				BeveledBox* box_ptr = new BeveledBox(	Point3D(bath_xmax - thickness, 0, bath_zmin + thickness + j * ((z_size - 2 * thickness) / num_zboxes)),
														Point3D(bath_xmax, bath_height, bath_zmin + thickness + (j + 1) * ((z_size - 2 * thickness) / num_zboxes)),
														bath_bevel_radius);
				box_ptr->set_material(sv_matte_ptr);
				bath_ptr->add_object(box_ptr);
			}
		
			bath_ptr->set_material(matte_ptr10);  // sets plain material for all boxes
			bath_ptr->setup_cells();
			add_object(bath_ptr);
	
			// ************************************************************************************************* bath water
	
			// the bath water
			// this is a bump mapped rectangle with a transparent material	
	
			float c = 1.2;
			RGBColor water_color(0.50 * c, 0.8 * c, 0.8 * c); 
			Dielectric* water_ptr = new Dielectric;
			water_ptr->set_eta_in(1.33);		// water
			water_ptr->set_eta_out(1.0);		// air
			water_ptr->set_cf_in(water_color);
			water_ptr->set_cf_out(white);
			water_ptr->set_shadows(false);
	
			double waterHeight = bath_height - 0.45;
			TRectangle* water_surface_ptr = new TRectangle(	Point3D(bath_xmin + thickness - bath_bevel_radius, waterHeight, bath_zmin + thickness - bath_bevel_radius), 
															Vector3D(0, 0, z_size - 2 * thickness + 2 * bath_bevel_radius), 
															Vector3D(x_size - 2 * thickness + 2 * bath_bevel_radius, 0, 0),
															Normal(0, 1, 0));

			water_surface_ptr->set_shadows(false);
			water_surface_ptr->set_material(water_ptr);
			add_object(water_surface_ptr);						// no bump map - use this for Figure 29.1

			// the bump mapped object
	
			num_octaves = 2;
			float 	lacunarity 			= 2.0;
			float 	gain 				= 0.33333;
			float 	perturbation_amount = 1.0;
	
			/*
			FBM_Bump* fBm_bump_ptr = new FBM_Bump(num_octaves, lacunarity, gain, perturbation_amount);    // Ken Musgrave's water
	
			BumpedObject* bumped_water_ptr = new BumpedObject;
			bumped_water_ptr->set_material(water_ptr);
			bumped_water_ptr->set_object(water_surface_ptr);
			bumped_water_ptr->set_bump_map(fBm_bump_ptr);*/
		//	add_object(bumped_water_ptr);						// use this for Figure 29.2

			// ************************************************************************************************* tiles

			// build reflective tiles on the wall behind the bath
			// these are beveled boxes with a spatially varying reflective material
			// there is grout between the tiles which is a rectangle just in front of the back wall
			// because the reflective material has no ambient, there are black areas in the image where the tiles are reflected in each other
			// this can be minimised by placing the back wall at z = 0.1 for a bevel radius of 0.25 and thickness of 0.6
			// this is where the grout rectangle should be.
		
			double 	tile_size 			= 3.25;	  						// tiles are square with dimensions tile_size in the x and y directions
			double	tile_thickness		= 0.6;							// tile thickness in the z direction 
			double	grout_width			= 0.25;							// the grout width
			double 	tiles_xmin 			= bath_xmin;					// left boundary of the tiles is at left side of bath
			double 	tiles_ymin 			= bath_height + grout_width; 	// tiles start at bath height + the grout width
			double 	tiles_zmin			= -tile_thickness / 2.0; 		// back wall goes through the middle of the tiles
			double 	tiles_zmax			= tile_thickness / 2.0;
			double 	tile_bevel_radius	= 0.25;    						// the bevel radius
			int 	num_x_tiles			= 4;							// number of tiles in the x direction
			int 	num_y_tiles			= 3;							// number of tiles in the y direction
	
	
			// plain material
	
			Reflective* reflective_ptr = new Reflective;		
			reflective_ptr->set_cr(0.75, 1.0, 0.85);
			reflective_ptr->set_kr(1.0);
		
			Grid* tiles_ptr = new Grid;
	
			for (int ix = 0; ix < num_x_tiles; ix++) {    	// across
				for (int iy = 0; iy < num_y_tiles; iy++) {  // up
			
					// the noise
			
					CubicNoise* noise_ptr = new CubicNoise;	
					noise_ptr->set_num_octaves(4);
					noise_ptr->set_gain(0.5);	
					noise_ptr->set_lacunarity(2.0);
			
					// the texture:

					TurbulenceTexture* texture_ptr = new TurbulenceTexture(noise_ptr);			
					texture_ptr->set_color(0.75, 1.0, 0.85);		// green
					texture_ptr->set_min_value(0.25);
			//		texture_ptr->set_max_value(1.0);   // original - now renders darker
					texture_ptr->set_max_value(1.2);   // new value - lighter
			
					TInstance* scaled_texture_ptr = new TInstance(texture_ptr); 
					scaled_texture_ptr->scale(0.5);
			
					// the material
			
					SV_Reflector* reflector_ptr = new SV_Reflector;
					reflector_ptr->set_kr(1.0);
					reflector_ptr->set_cr(scaled_texture_ptr);
			
					// the tiles
						
					Point3D p0(tiles_xmin + ix * (tile_size + grout_width), tiles_ymin + iy * (tile_size + grout_width), tiles_zmin);
					Point3D p1(tiles_xmin + (ix + 1) * tile_size + ix * grout_width, tiles_ymin + (iy + 1) * tile_size + iy * grout_width, tiles_zmax);
					BeveledBox* tile_ptr = new BeveledBox(p0, p1, tile_bevel_radius);
					tile_ptr->set_material(reflective_ptr);  	// plain
		//			tile_ptr->set_material(reflector_ptr);		// textured
					tiles_ptr->add_object(tile_ptr);
				}
			}
		
			tiles_ptr->setup_cells();

	 	
			// ************************************************************************************************* grout
	
			// this is not textured
	
			Matte* matte_ptr11 = new Matte;
			matte_ptr11->set_ka(0.5);
			matte_ptr11->set_kd(0.75);
			matte_ptr11->set_cd(0.92, 0.85, 0.6);
	
			TRectangle* grout_ptr = new TRectangle(	Point3D(tiles_xmin, bath_height, tile_thickness / 2.0 - tile_bevel_radius * 0.666),
													Vector3D(num_x_tiles * (tile_size + grout_width), 0.0, 0.0),
													Vector3D(0.0, num_y_tiles * (tile_size + grout_width), 0.0));
			grout_ptr->set_material(matte_ptr11);	
										
			Compound* tiles_and_grout_ptr = new Compound; 
			tiles_and_grout_ptr->add_object(tiles_ptr); 
			tiles_and_grout_ptr->add_object(grout_ptr);
	
			Instance* instance_ptr = new Instance(tiles_and_grout_ptr);
			instance_ptr->translate(0, 0, -0.99 * (tile_thickness / 2.0 - tile_bevel_radius * 0.666));
			add_object(instance_ptr);
			break;
		}
	case 355:
		{
			//29.02
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(ppmfile+"GreenAndYellow.ppm").toLatin1().data()))
				return;
			if( !CheckFile(QString(ppmfile+"EarthHighRes.ppm").toLatin1().data()))
				return;
			if( !CheckFile(QString(ppmfile+"BlueGlass.ppm").toLatin1().data()))
				return;
			if( !CheckFile(QString(ppmfile+"GrayMarbleRamp.ppm").toLatin1().data()))
				return;
			if( !CheckFile(QString(ppmfile+"sandstone_ramp1.ppm").toLatin1().data()))
				return;

			//	int num_samples = 1;			// development
			int num_samples = 16;			// production
	
		//	vp.set_hres(475);				// development
		//	vp.set_vres(250); 
			vp.set_hres(950);				// production
			vp.set_vres(500);
			vp.set_samples(num_samples);	
			vp.set_max_depth(2);
		
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			tracer_ptr = new Whitted(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 15, 50);
			pinhole_ptr->set_lookat(0.4, 3.0, 0.0); 
		//	pinhole_ptr->set_view_distance(600.0);		// for 475 x 250
			pinhole_ptr->set_view_distance(1200.0);   	// for 950 X 500
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(14, 50, 50);  
			light_ptr->scale_radiance(3.0);  
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
	
			// ************************************************************************************************* walls
	
			// these are not textured
	
			// back wall 
	
			Matte* matte_ptr1 = new Matte;		
			matte_ptr1->set_ka(0.75);
			matte_ptr1->set_kd(0.5);
			matte_ptr1->set_cd(0.85);  
	
			Plane* back_wall_ptr = new Plane(Point3D(0, 0, 0), Normal(0, 0, 1));
			back_wall_ptr->set_material(matte_ptr1);
			add_object(back_wall_ptr);
	
	
			// front wall 
	
			Matte* matte_ptr2 = new Matte;		
			matte_ptr2->set_ka(1.0);
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(white);
	
			Plane* front_wall_ptr = new Plane(Point3D(0, 0, 51), Normal(0, 0, -1));
			front_wall_ptr->set_material(matte_ptr2);
			add_object(front_wall_ptr);
	
	
			// left wall 
	
			Matte* matte_ptr3 = new Matte;		
			matte_ptr3->set_ka(0.25);
			matte_ptr3->set_kd(0.75);
			matte_ptr3->set_cd(0.75, 1.0, 1.0);    
	
			Plane* left_wall_ptr = new Plane(Point3D(-15, 0, 0), Normal(1, 0, 0));
			left_wall_ptr->set_material(matte_ptr3);
			add_object(left_wall_ptr);

	
			// right wall 
	
			Matte* matte_ptr4 = new Matte;		
			matte_ptr4->set_ka(0.5);
			matte_ptr4->set_kd(0.5);
			matte_ptr4->set_cd(0.75, 1.0, 1.0); 

			Plane* right_wall_ptr = new Plane(Point3D(15, 0, 0), Normal(-1, 0, 0));
			right_wall_ptr->set_material(matte_ptr4);
			add_object(right_wall_ptr);
	
	
			// there is no ceiling
	
	
	
			// ************************************************************************************************* floor planks
	
			// plain material	
	
			Phong* phong_ptr = new Phong;		
			phong_ptr->set_ka(0.5);  
			phong_ptr->set_kd(1.0);
			phong_ptr->set_ks(0.2);  
			phong_ptr->set_exp(20.0);
			phong_ptr->set_cd(0.5, 0.3, 0.1);
			
			// the floor is a simulation of wood planks using beveled boxes with random lengths in the x direction
	
			double 	x0 					= -15.0;				// planks start at x = x0
			double 	z0 					= 0.0;					// planks start at z = z0
			double 	min_length 			= 4.0;   				// minumum plank length in x direction
			double 	max_length 			= 10.0;	  				// maximum plank length in x direction
			double 	plank_thickness 	= 1.0;					// common plank thickness - in y direction
			double 	y0					= -plank_thickness; 	// places top of planks at y = 0;
			double	plank_width			= 1.0;  				// common plank width 
			double 	plank_bevel			= 0.25;    				// the bevel radius
			int 	num_x_planks		= 6;					// number of planks in the x direction (a single column)
			int 	num_z_columns		= 50;  					// number of plank columns in the z direction
		
			Grid* planks_ptr = new Grid;
	
			for (int iz = 0; iz < num_z_columns; iz++) {     // to the front
				double p0x = x0;
		
				for (int ix = 0; ix < num_x_planks; ix++) {  // to the right
					TInstance* wood_ptr = new TInstance(new Wood(RGBColor(0.5, 0.3, 0.1), black));
					wood_ptr->scale(5.0);
					wood_ptr->rotate_y(90);
					set_rand_seed(ix * 1000 + iz * 10000);  // this must go right here
					wood_ptr->translate(10.0 * (2.0 * rand_float() - 1.0), 20.0 * (2.0 * rand_float() - 1.0), 30.0 * (2.0 * rand_float() - 1.0));
			
					SV_Phong* sv_phong_ptr = new SV_Phong;		
					sv_phong_ptr->set_ka(0.5);  
					sv_phong_ptr->set_kd(1);
					sv_phong_ptr->set_ks(0.2);  
					sv_phong_ptr->set_exp(20.0);
					sv_phong_ptr->set_cd(wood_ptr);
					sv_phong_ptr->set_cs(new ConstantColor());   // white, by default
				
					set_rand_seed(ix * 10000 + iz * 100);
					double plank_length = min_length + rand_float() * (max_length - min_length);
						
					Point3D p0(p0x ,y0, iz * plank_width);
					Point3D p1(p0x + plank_length, y0 + plank_thickness, (iz + 1) * plank_width);
		
					BeveledBox* plank_ptr = new BeveledBox(p0, p1, plank_bevel);
		//			plank_ptr->set_material(phong_ptr);				// plain
					plank_ptr->set_material(sv_phong_ptr);	// textured
					planks_ptr->add_object(plank_ptr);
			
					p0x += plank_length;
				}
			}
		
			planks_ptr->setup_cells();
			add_object(planks_ptr);      
	
	
	
			// ************************************************************************************************* checkered cylinder
	
			// plain material 
	
			Matte* matte_ptr5 = new Matte;		
			matte_ptr5->set_ka(0.25);
			matte_ptr5->set_kd(0.95);
			matte_ptr5->set_cd(0.1, 0.4, 0.15);

			// textured material
			// this is a checker image
	
			Image* image_ptr1 = new Image;					
			image_ptr1->read_ppm_file(QString(ppmfile+"GreenAndYellow.ppm").toLatin1().data());
			CylindericalMap* cylinderical_map_ptr = new CylindericalMap;   
			ImageTexture* image_texture_ptr1 = new ImageTexture(image_ptr1); 
			image_texture_ptr1->set_mapping(cylinderical_map_ptr);

			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.25);
			sv_matte_ptr1->set_kd(0.95);
			sv_matte_ptr1->set_cd(image_texture_ptr1);
	
			OpenCylinder* cylinder_ptr1 = new OpenCylinder(-1.0, 1.0, 1.0);  // default
			cylinder_ptr1->set_material(matte_ptr5);			// plain
			cylinder_ptr1->set_material(sv_matte_ptr1); 		// textured
	
			Instance* cylinder_ptr2 = new Instance(cylinder_ptr1); 
			cylinder_ptr2->translate(Vector3D(0, 1, 0));
			cylinder_ptr2->scale(2, 2.5, 2);
			cylinder_ptr2->translate(Vector3D(-11, 0, 12));
			add_object(cylinder_ptr2);
	
	
			// a disk for the cylinder top
			// this is a 2D procedural checker texture designed to match the checkers
			// on the curved surface
	
			DiskChecker* disk_checker_ptr = new DiskChecker;
			disk_checker_ptr->set_num_angular_checkers(20);
			disk_checker_ptr->set_num_radial_checkers(4);
			disk_checker_ptr->set_angular_line_width(0.0);
			disk_checker_ptr->set_radial_line_width(0.0);
			disk_checker_ptr->set_color1(0.08, 0.39, 0.14);  	// dark green
			disk_checker_ptr->set_color2(1.0, 1.0, 0.5);		// yellow
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.35);
			sv_matte_ptr2->set_kd(0.5);
			sv_matte_ptr2->set_cd(disk_checker_ptr);
	
			Disk* disk_ptr = new Disk;					// default - center (0, 0, 0), radius 1
		//	disk_ptr->set_material(matte_ptr5);			// plain
			disk_ptr->set_material(sv_matte_ptr2);		// textured
			Instance* cylinder_top_ptr = new Instance(disk_ptr);
			cylinder_top_ptr->scale(2, 1, 2);
			cylinder_top_ptr->translate(-11, 5, 12);
			add_object(cylinder_top_ptr); 
	
	
	
	
			// ************************************************************************************************* Earth sphere
	
			// plain material
	
			Matte* matte_ptr6 = new Matte;		
			matte_ptr6->set_ka(0.5);
			matte_ptr6->set_kd(0.5);
			matte_ptr6->set_cd(0.2, 0.5, 1);

			// Earth image texture
	
			Image* image_ptr2 = new Image;					
		//	image_ptr2->read_ppm_file("EarthLowRes.ppm");
			image_ptr2->read_ppm_file(QString(ppmfile+"GreenAndYellow.ppm").toLatin1().data());
			SphericalMap* spherical_map_ptr = new SphericalMap;   
			ImageTexture* image_texture_ptr2 = new ImageTexture(image_ptr2); 
			image_texture_ptr2->set_mapping(spherical_map_ptr);
	
			SV_Matte* sv_matte_ptr3 = new SV_Matte;		
			sv_matte_ptr3->set_ka(0.5);
			sv_matte_ptr3->set_kd(0.95);
			sv_matte_ptr3->set_cd(image_texture_ptr2);
	
			Sphere* sphere_ptr = new Sphere;
		//	sphere_ptr->set_material(matte_ptr6);				// plain 
			sphere_ptr->set_material(sv_matte_ptr3);			// textured with Earth image
		
			Instance* earth_ptr = new Instance(sphere_ptr);
			earth_ptr->rotate_y(75);
			earth_ptr->scale(3);
			earth_ptr->translate(-11, 8, 12);
			add_object(earth_ptr);
	


			// ************************************************************************************************* picture on back wall
	
			// this is initially constructed in the (x, z) plane, and then moved to the back wall
			// the picture and its frame are stored in a compound object:
	
			Compound* framed_picture_ptr = new Compound;
	
			// dimensions
	
			double a = 3.5;  	// +ve x coordinate of untransformed image
			double b = 5.05; 	// +ve z coordinate of untransformed image
			double w = 1.0;		// width of the frame
	
	
			// plain material picture
	
			Matte* matte_ptr7 = new Matte;		
			matte_ptr7->set_ka(0.75);
			matte_ptr7->set_kd(0.5);
			matte_ptr7->set_cd(0.3, 0.65, 0.71);
	
			// the image is applied to a rectangle
	
			Image* image_ptr3 = new Image;					
			image_ptr3->read_ppm_file(QString(ppmfile+"BlueGlass.ppm").toLatin1().data());   
	
			//SquareMap* square_map_ptr = new SquareMap;   
			RectangularMap * square_map_ptr = new RectangularMap;
			ImageTexture* image_texture_ptr3 = new ImageTexture(image_ptr3); 
			image_texture_ptr3->set_mapping(square_map_ptr);
	
			SV_Matte* sv_matte_ptr4 = new SV_Matte;		
			sv_matte_ptr4->set_ka(0.5);
			sv_matte_ptr4->set_kd(0.75);
			sv_matte_ptr4->set_cd(image_texture_ptr3);
	
	
			// construct the picture
	
			TRectangle* rectangle_ptr = new TRectangle;
		//	rectangle_ptr->set_material(matte_ptr7);  		// plain
			rectangle_ptr->set_material(sv_matte_ptr4);  	// textured with Blue Glass
	
			Instance* picture_ptr = new Instance(rectangle_ptr);  
			picture_ptr->scale(a, 1, b);

	
			// construct the frame
	
			// plain material for the frame
	
			Matte* matte_ptr8 = new Matte;		
			matte_ptr8->set_ka(0.75);
			matte_ptr8->set_kd(0.5);
			matte_ptr8->set_cd(0.5, 0.3, 0.14);
	
	
			// wood materials for the frame

			// for front and back sides

			TInstance* wood_ptr1 = new TInstance(new Wood(RGBColor(0.55, 0.43, 0.13), black));
			wood_ptr1->scale(2);
			wood_ptr1->rotate_y(90);
	
			SV_Matte* sv_matte_ptr5 = new SV_Matte;		
			sv_matte_ptr5->set_ka(1.0);
			sv_matte_ptr5->set_kd(1.0);
			sv_matte_ptr5->set_cd(wood_ptr1);
	
			// for right and left sides

			TInstance* wood_ptr2 = new TInstance(new Wood(RGBColor(0.55, 0.43, 0.13), black));
			wood_ptr2->scale(2.0);

			SV_Matte* sv_matte_ptr6 = new SV_Matte;		
			sv_matte_ptr6->set_ka(1.0);
			sv_matte_ptr6->set_kd(1.0);
			sv_matte_ptr6->set_cd(wood_ptr2);
	
		
			// construct the frame: two triangles per side
	
			// front side: +ve z before any transformations
	
			Triangle* triangle_ptr1 = new Triangle (Point3D(-a, 0, b), Point3D(-a - w, 0, b + w), Point3D(a + w, 0, b + w));
			triangle_ptr1->set_material(sv_matte_ptr5);
			framed_picture_ptr->add_object(triangle_ptr1);
	
			Triangle* triangle_ptr2 = new Triangle (Point3D(-a, 0, b), Point3D(a + w, 0, b + w), Point3D(a, 0, b));
			triangle_ptr2->set_material(sv_matte_ptr5);
			framed_picture_ptr->add_object(triangle_ptr2);
	
	
			// back side: -ve z before any transformations
	
			Triangle* triangle_ptr3 = new Triangle (Point3D(a, 0, -b), Point3D(a + w, 0, -b - w), Point3D(-a - w, 0, -b - w));
			triangle_ptr3->set_material(sv_matte_ptr5);
			framed_picture_ptr->add_object(triangle_ptr3);
	
			Triangle* triangle_ptr4 = new Triangle (Point3D(a, 0, -b), Point3D(-a - w, 0, -b - w), Point3D(-a, 0, -b));
			triangle_ptr4->set_material(sv_matte_ptr5);
			framed_picture_ptr->add_object(triangle_ptr4);
	
	
			// right side: +ve x before any transformations
	
			Triangle* triangle_ptr5 = new Triangle (Point3D(a, 0, b), Point3D(a + w, 0, b + w), Point3D(a + w, 0, -b - w));
			triangle_ptr5->set_material(sv_matte_ptr6);
			framed_picture_ptr->add_object(triangle_ptr5);
	
			Triangle* triangle_ptr6 = new Triangle (Point3D(a, 0, b), Point3D(a + w, 0, -b - w), Point3D(a, 0, -b));
			triangle_ptr6->set_material(sv_matte_ptr6);
			framed_picture_ptr->add_object(triangle_ptr6);
	
	
			// left side: -ve x before any transformations
	
			Triangle* triangle_ptr7 = new Triangle (Point3D(-a, 0, -b), Point3D(-a - w, 0, -b - w), Point3D(-a - w, 0, b + w));
			triangle_ptr7->set_material(sv_matte_ptr6);
			framed_picture_ptr->add_object(triangle_ptr7);
	
			Triangle* triangle_ptr8 = new Triangle (Point3D(-a, 0, -b), Point3D(-a - w, 0, b + w), Point3D(-a, 0, b));
			triangle_ptr8->set_material(sv_matte_ptr6);
			framed_picture_ptr->add_object(triangle_ptr8);
	
		//	framed_picture_ptr->set_material(matte_ptr8);    // plain material for the frame - replaces all the wood textures - see Listing 19.13
			framed_picture_ptr->add_object(picture_ptr);	
	
	
			Instance* wall_picture_ptr = new Instance(framed_picture_ptr);	
			wall_picture_ptr->rotate_y(90);
			wall_picture_ptr->rotate_x(90);
			wall_picture_ptr->translate(-6, 8, 0.5);
			add_object(wall_picture_ptr);
	


			// ************************************************************************************************* bunny
	
			// plain material for the bunny	
	
			Matte* matte_ptr9 = new Matte;		
			matte_ptr9->set_ka(0.25);
			matte_ptr9->set_kd(0.75);   
			matte_ptr9->set_cd(0.8);	
	
			// ramp based marble texture
	
			Image* image_ptr4 = new Image;						
			image_ptr4->read_ppm_file(QString(ppmfile+"GrayMarbleRamp.ppm").toLatin1().data());
	
			int 	num_octaves = 4;
			float	fbm_amount 	= 3.0;
			TInstance* marble_ptr = new TInstance(new RampFBmTexture(image_ptr4, num_octaves, fbm_amount));
			marble_ptr->scale(0.0075);  // the bunny is small
			marble_ptr->translate(0.5, 0.0, 0.0);
			marble_ptr->rotate_x(100);
			marble_ptr->rotate_z(30);
			marble_ptr->rotate_y(20);

			// marble material

			SV_Matte* sv_matte_ptr7 = new SV_Matte;		
			sv_matte_ptr7->set_ka(0.25);
			sv_matte_ptr7->set_kd(0.75);
			sv_matte_ptr7->set_cd(marble_ptr);
	
			Mesh* mesh_ptr = new Mesh;
		//	const char* fileName = "Bunny4K.ply"; 		// development 
			const char* fileName = "Bunny16K.ply";   	// production
	
			Grid* grid_ptr = new Grid(mesh_ptr);
			grid_ptr->read_smooth_triangles(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data());
		//	grid_ptr->set_material(matte_ptr9);			// plain
			grid_ptr->set_material(sv_matte_ptr7); 		// textured
			grid_ptr->setup_cells();
	
			Instance* bunny_ptr = new Instance(grid_ptr);
			bunny_ptr->scale(47.0);
			bunny_ptr->translate(-3.25, -1.65, 10);
			add_object(bunny_ptr);	
	
	
	
			// ************************************************************************************************* bath sides
	
			// the front and back sides of the bath run right across the bath in the x direction
			// the left and right sides fit between the front and back in the z direction
			// the sides are rows of beveled boxes with a random sandstone texture applied
			// these are stored in a single grid
	
			double 	bath_xmin 			= 1.0;
			double 	bath_zmin 			= 0.0;  
			double 	bath_xmax 			= 15.0;
			double 	bath_zmax 			= 15.0;   
			double 	x_size 				= bath_xmax - bath_xmin;
			double 	z_size 				= bath_zmax - bath_zmin;
			double 	thickness 			= 1.5;  	// common box thickness = side thickness
			double 	bath_height 		= 2.5;		// common box height 
			double 	bath_bevel_radius	= 0.25;  
			int  	num_xboxes			= 4;		// number of boxes along the back and front sides
			int 	num_zboxes			= 3;		// number of boxes along the left and right sides
		
			float 	bath_ka 			= 0.5;  	// common material property
			float 	bath_kd 			= 0.85; 	// common material property
	
	
			// plain material 
	
			Matte* matte_ptr10 = new Matte;				
			matte_ptr10->set_ka(bath_ka);
			matte_ptr10->set_kd(bath_kd);
			matte_ptr10->set_cd(0.53, 0.51, 0.45);
	
	
			// sandstone texture
	
			// Sandstone is implemented with a ramp marble texture
	
			Image* image_ptr5 = new Image;						
			image_ptr5->read_ppm_file(QString(ppmfile+"sandstone_ramp1.ppm").toLatin1().data());
	
			num_octaves = 4;
			fbm_amount	= 0.1;
	
			Grid* bath_ptr = new Grid;
	
			// build back - runs in x direction
	
			for (int j = 0; j < num_xboxes; j++) {
	
				// put a sandstone texture with a random set of intrinsic transformations on the beveled boxes
				
				TInstance* sandstone_ptr = new TInstance(new RampFBmTexture(image_ptr5, num_octaves, fbm_amount));
				sandstone_ptr->scale(2.0);
				set_rand_seed(j * 10);
				sandstone_ptr->rotate_x(20.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->rotate_y(30.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->rotate_z(45.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->translate(10.0 * (2.0 * rand_float() - 1.0), 20.0 * (2.0 * rand_float() - 1.0), 30.0 * (2.0 * rand_float() - 1.0));
		
				SV_Matte* sv_matte_ptr = new SV_Matte;		
				sv_matte_ptr->set_ka(bath_ka);
				sv_matte_ptr->set_kd(bath_kd);
				sv_matte_ptr->set_cd(sandstone_ptr);
				
				BeveledBox* box_ptr = new BeveledBox(	Point3D(bath_xmin + j * (x_size / num_xboxes), 0, bath_zmin), 
														Point3D(bath_xmin + (j + 1) * (x_size / num_xboxes), bath_height, bath_zmin + thickness),
														bath_bevel_radius);
				box_ptr->set_material(sv_matte_ptr);
				bath_ptr->add_object(box_ptr);
			}
		
			// build front - runs in xw direction
	
			for (int j = 0; j < num_xboxes; j++) {
				
				TInstance* sandstone_ptr = new TInstance(new RampFBmTexture(image_ptr5, num_octaves, fbm_amount));
				sandstone_ptr->scale(2.0);
				set_rand_seed(j * 1000000);
				sandstone_ptr->rotate_x(20.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->rotate_y(30.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->rotate_z(45.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->translate(10.0 * (2.0 * rand_float() - 1.0), 20.0 * (2.0 * rand_float() - 1.0), 30.0 * (2.0 * rand_float() - 1.0));
			
				SV_Matte* sv_matte_ptr = new SV_Matte;		
				sv_matte_ptr->set_ka(bath_ka);
				sv_matte_ptr->set_kd(bath_kd);
				sv_matte_ptr->set_cd(sandstone_ptr);
		
				BeveledBox* box_ptr = new BeveledBox(	Point3D(bath_xmin + j * (x_size / num_xboxes), 0, bath_zmax - thickness), 
														Point3D(bath_xmin + (j + 1) * (x_size / num_xboxes), bath_height, bath_zmax),
														bath_bevel_radius);
				box_ptr->set_material(sv_matte_ptr);
				bath_ptr->add_object(box_ptr);
			}
	
	
			// build left side - runs in yw direction
	
			for (int j = 0; j < num_zboxes; j++) {
		
				TInstance* sandstone_ptr = new TInstance(new RampFBmTexture(image_ptr5, num_octaves, fbm_amount));
				sandstone_ptr->scale(2.0);
				set_rand_seed(j * 1000);
				sandstone_ptr->rotate_x(20.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->rotate_y(30.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->rotate_z(45.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->translate(10.0 * (2.0 * rand_float() - 1.0), 20.0 * (2.0 * rand_float() - 1.0), 30.0 * (2.0 * rand_float() - 1.0));
	
				SV_Matte* sv_matte_ptr = new SV_Matte;		
				sv_matte_ptr->set_ka(bath_ka);
				sv_matte_ptr->set_kd(bath_kd);
				sv_matte_ptr->set_cd(sandstone_ptr);
		
				BeveledBox* box_ptr = new BeveledBox(	Point3D(bath_xmin, 0, bath_zmin + thickness + j * ((z_size - 2 * thickness) / num_zboxes)),
														Point3D(bath_xmin + thickness, bath_height, bath_zmin + thickness + (j + 1) * ((z_size - 2 * thickness) / num_zboxes)),
														bath_bevel_radius);
				box_ptr->set_material(sv_matte_ptr);
				bath_ptr->add_object(box_ptr);
			}
	
	
			// build right side - runs in yw direction
	
			for (int j = 0; j < num_zboxes; j++) {
		
				TInstance* sandstone_ptr = new TInstance(new RampFBmTexture(image_ptr5, num_octaves, fbm_amount));
				sandstone_ptr->scale(2.0);
				set_rand_seed(j * 10000);
				sandstone_ptr->rotate_x(20.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->rotate_y(30.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->rotate_z(45.0 * (2.0 * rand_float() - 1.0));
				sandstone_ptr->translate(10.0 * (2.0 * rand_float() - 1.0), 20.0 * (2.0 * rand_float() - 1.0), 30.0 * (2.0 * rand_float() - 1.0));
	
				SV_Matte* sv_matte_ptr = new SV_Matte;		
				sv_matte_ptr->set_ka(bath_ka);
				sv_matte_ptr->set_kd(bath_kd);
				sv_matte_ptr->set_cd(sandstone_ptr);
		
				BeveledBox* box_ptr = new BeveledBox(	Point3D(bath_xmax - thickness, 0, bath_zmin + thickness + j * ((z_size - 2 * thickness) / num_zboxes)),
														Point3D(bath_xmax, bath_height, bath_zmin + thickness + (j + 1) * ((z_size - 2 * thickness) / num_zboxes)),
														bath_bevel_radius);
				box_ptr->set_material(sv_matte_ptr);
				bath_ptr->add_object(box_ptr);
			}
		
		//	bath_ptr->set_material(matte_ptr10);  // sets plain material for all boxes
			bath_ptr->setup_cells();
			add_object(bath_ptr);
	
	
	
			// ************************************************************************************************* bath water
	
			// the bath water
			// this is a bump mapped rectangle with a transparent material	
	
			float c = 1.2;
			RGBColor water_color(0.50 * c, 0.8 * c, 0.8 * c); 
			Dielectric* water_ptr = new Dielectric;
			water_ptr->set_eta_in(1.33);		// water
			water_ptr->set_eta_out(1.0);		// air
			water_ptr->set_cf_in(water_color);
			water_ptr->set_cf_out(white);
			water_ptr->set_shadows(false);
	
			double waterHeight = bath_height - 0.45;
			TRectangle* water_surface_ptr = new TRectangle(	Point3D(bath_xmin + thickness - bath_bevel_radius, waterHeight, bath_zmin + thickness - bath_bevel_radius), 
															Vector3D(0, 0, z_size - 2 * thickness + 2 * bath_bevel_radius), 
															Vector3D(x_size - 2 * thickness + 2 * bath_bevel_radius, 0, 0),
															Normal(0, 1, 0));

			water_surface_ptr->set_shadows(false);
			water_surface_ptr->set_material(water_ptr);
		//	add_object(water_surface_ptr);					// no bump map - use this for Figure 29.1

			// the bump mapped object
	
					num_octaves 		= 2;
			float 	lacunarity 			= 2.0;
			float 	gain 				= 0.33333;
			float 	perturbation_amount = 1.0;
	
			//FBM_Bump* fBm_bump_ptr = new FBM_Bump(num_octaves, lacunarity, gain, perturbation_amount);    // Ken Musgrave's water
	/*
			BumpedObject* bumped_water_ptr = new BumpedObject;
			bumped_water_ptr->set_material(water_ptr);
			bumped_water_ptr->set_object(water_surface_ptr);
			bumped_water_ptr->set_bump_map(fBm_bump_ptr);
			add_object(bumped_water_ptr);					// use this for Figure 29.2
			*/




			// ************************************************************************************************* tiles

			// build reflective tiles on the wall behind the bath
			// these are beveled boxes with a spatially varying reflective material
			// there is grout between the tiles which is a rectangle just in front of the back wall
			// because the reflective material has no ambient, there are black areas in the image where the tiles are reflected in each other
			// this can be minimised by placing the back wall at z = 0.1 for a bevel radius of 0.25 and thickness of 0.6
			// this is where the grout rectangle should be.
		
			double 	tile_size 			= 3.25;	  						// tiles are square with dimensions tile_size in the x and y directions
			double	tile_thickness		= 0.6;							// tile thickness in the z direction 
			double	grout_width			= 0.25;							// the grout width
			double 	tiles_xmin 			= bath_xmin;					// left boundary of the tiles is at left side of bath
			double 	tiles_ymin 			= bath_height + grout_width; 	// tiles start at bath height + the grout width
			double 	tiles_zmin			= -tile_thickness / 2.0; 		// back wall goes through the middle of the tiles
			double 	tiles_zmax			= tile_thickness / 2.0;
			double 	tile_bevel_radius	= 0.25;    						// the bevel radius
			int 	num_x_tiles			= 4;							// number of tiles in the x direction
			int 	num_y_tiles			= 3;							// number of tiles in the y direction
	
	
			// plain material
	
			Reflective* reflective_ptr = new Reflective;		
			reflective_ptr->set_cr(0.75, 1.0, 0.85);
			reflective_ptr->set_kr(1.0);
		
			Grid* tiles_ptr = new Grid;
	
			for (int ix = 0; ix < num_x_tiles; ix++) {    	// across
				for (int iy = 0; iy < num_y_tiles; iy++) {  // up
			
					// the noise
			
					CubicNoise* noise_ptr = new CubicNoise;	
					noise_ptr->set_num_octaves(4);
					noise_ptr->set_gain(0.5);	
					noise_ptr->set_lacunarity(2.0);
			
					// the texture:

					TurbulenceTexture* texture_ptr = new TurbulenceTexture(noise_ptr);			
					texture_ptr->set_color(0.75, 1.0, 0.85);		// green
					texture_ptr->set_min_value(0.25);
			//		texture_ptr->set_max_value(1.0);   // original - now renders darker
					texture_ptr->set_max_value(1.2);   // new value - lighter
			
					TInstance* scaled_texture_ptr = new TInstance(texture_ptr); 
					scaled_texture_ptr->scale(0.5);
			
					// the material
			
					SV_Reflector* reflector_ptr = new SV_Reflector;
					reflector_ptr->set_kr(1.0);
					reflector_ptr->set_cr(scaled_texture_ptr);
			
					// the tiles
						
					Point3D p0(tiles_xmin + ix * (tile_size + grout_width), tiles_ymin + iy * (tile_size + grout_width), tiles_zmin);
					Point3D p1(tiles_xmin + (ix + 1) * tile_size + ix * grout_width, tiles_ymin + (iy + 1) * tile_size + iy * grout_width, tiles_zmax);
					BeveledBox* tile_ptr = new BeveledBox(p0, p1, tile_bevel_radius);
		//			tile_ptr->set_material(reflective_ptr);  	// plain
					tile_ptr->set_material(reflector_ptr);		// textured
					tiles_ptr->add_object(tile_ptr);
				}
			}
		
			tiles_ptr->setup_cells();

	 	
			// ************************************************************************************************* grout
	
			// this is not textured
	
			Matte* matte_ptr11 = new Matte;
			matte_ptr11->set_ka(0.5);
			matte_ptr11->set_kd(0.75);
			matte_ptr11->set_cd(0.92, 0.85, 0.6);
	
			TRectangle* grout_ptr = new TRectangle(	Point3D(tiles_xmin, bath_height, tile_thickness / 2.0 - tile_bevel_radius * 0.666),
													Vector3D(num_x_tiles * (tile_size + grout_width), 0.0, 0.0),
													Vector3D(0.0, num_y_tiles * (tile_size + grout_width), 0.0));
			grout_ptr->set_material(matte_ptr11);	
										
			Compound* tiles_and_grout_ptr = new Compound; 
			tiles_and_grout_ptr->add_object(tiles_ptr); 
			tiles_and_grout_ptr->add_object(grout_ptr);
	
			Instance* instance_ptr = new Instance(tiles_and_grout_ptr);
			instance_ptr->translate(0, 0, -0.99 * (tile_thickness / 2.0 - tile_bevel_radius * 0.666));
			add_object(instance_ptr);
			break;
		}
	case 356:
		{
			//29.04
			if( !CheckFile(QString(ppmfile+"Lightlace.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400); 
			vp.set_samples(num_samples);
			vp.set_max_depth(0);
		
			background_color = RGBColor(0.0);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(5, 1.5, 8);
			pinhole_ptr->set_lookat(0.25, 0.0, 0.0); 
			pinhole_ptr->set_view_distance(1000.0);
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(-15, 20, 25);  
			light_ptr->scale_radiance(2.5);  
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
			// image:

			Image* image_ptr = new Image;					
			image_ptr->read_ppm_file(QString(ppmfile+"Lightlace.ppm").toLatin1().data());
	
			// mapping:
	
			//SquareMap* map_ptr = new SquareMap;   
			RectangularMap *map_ptr = new RectangularMap;	//I can't find SquareMap class in original code, Here we may try to use another similar class to simulate this effect 
	
			// image texture:
	
			ImageTexture* texture_ptr = new ImageTexture(image_ptr); 
			texture_ptr->set_mapping(map_ptr);
	
			// spatially varying material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.40);
			sv_matte_ptr->set_kd(0.95);
			sv_matte_ptr->set_cd(texture_ptr);
	
			// generic rectangle:
	
			TRectangle* rectangle_ptr = new TRectangle;
			rectangle_ptr->set_material(sv_matte_ptr);
	
			// transformed rectangle:
	
			Instance* lightlace_ptr = new Instance(rectangle_ptr);  
			lightlace_ptr->scale(1.0, 1.0, 1.5);
			lightlace_ptr->rotate_z(90);
			lightlace_ptr->rotate_y(90);
			add_object(lightlace_ptr);
	
			// ground plane
	
			Matte* matte_ptr1 = new Matte;		
			matte_ptr1->set_ka(0.25);
			matte_ptr1->set_kd(0.5);
			matte_ptr1->set_cd(1.0);
	 
			Plane* plane_ptr = new Plane(Point3D(0.0, -1.0, 0.0), Normal(0.0, 1.0, 0.0));
			plane_ptr->set_material(matte_ptr1);
			add_object(plane_ptr);
			break;
		}
	case 357:
		{
			//29.06
			if( !CheckFile(QString(ppmfile+"CountryScene.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400); 
			vp.set_samples(num_samples);
			vp.set_max_depth(0);
	
			background_color = RGBColor(0.5);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(2, 3.5, 5);
			pinhole_ptr->set_lookat(0); 
			pinhole_ptr->set_view_distance(800.0);
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(14, 20, 25);  
			light_ptr->scale_radiance(1.75);  
			light_ptr->set_shadows(true);
			add_light(light_ptr);

			Image* image_ptr = new Image;					
			image_ptr->read_ppm_file(QString(ppmfile+"CountryScene.ppm").toLatin1().data());
			CylindericalMap* map_ptr = new CylindericalMap;		//It's called CylindericalMap but not CylindricalMap
			ImageTexture* texture_ptr = new ImageTexture(image_ptr); 
			texture_ptr->set_mapping(map_ptr);

			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.40);
			sv_matte_ptr->set_kd(0.95);
			sv_matte_ptr->set_cd(texture_ptr);

			OpenCylinder* cylinder_ptr = new OpenCylinder;
			cylinder_ptr->set_material(sv_matte_ptr); 
			add_object(cylinder_ptr);
			break;
		}
	case 358:
		{
			//29.09a
			if( !CheckFile(QString(ppmfile+"SphereGrid.ppm").toLatin1().data()))
				return;

			int num_samples = 25;
	
			vp.set_hres(700);      
			vp.set_vres(700);    
			vp.set_samples(num_samples);
		
			background_color = black;
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
			camera_ptr->set_eye(40, 20, 40); 			// for Figure29.9(a)
		//	camera_ptr->set_eye(0, 65, 0); 				// for Figure29.9(b)			
			camera_ptr->set_lookat(0.0); 
			camera_ptr->set_view_distance(17000.0);
			camera_ptr->compute_uvw();     
			set_camera(camera_ptr); 
	
	
			// image:					

			Image* image_ptr = new Image;				
			image_ptr->read_ppm_file(QString(ppmfile+"SphereGrid.ppm").toLatin1().data());
	
	
			// mapping:
	
			SphericalMap* map_ptr = new SphericalMap; 
	
	
			// image based texture:  
	
			ImageTexture* texture_ptr = new ImageTexture; 
			texture_ptr->set_image(image_ptr); 
			texture_ptr->set_mapping(map_ptr);
	
	
			// textured material:

			SV_Emissive* sv_emissive_ptr = new SV_Emissive;	
			sv_emissive_ptr->scale_radiance(1.0);	
			sv_emissive_ptr->set_ce(texture_ptr);
	
	
			// generic sphere:
	
			Sphere*	sphere_ptr = new Sphere; 
			sphere_ptr->set_material(sv_emissive_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 359:
		{
			//29.09a
			if( !CheckFile(QString(ppmfile+"SphereGrid.ppm").toLatin1().data()))
				return;

			int num_samples = 25;
	
			vp.set_hres(700);      
			vp.set_vres(700);    
			vp.set_samples(num_samples);
		
			background_color = black;
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
		//	camera_ptr->set_eye(40, 20, 40); 			// for Figure29.9(a)
			camera_ptr->set_eye(0, 65, 0); 				// for Figure29.9(b)			
			camera_ptr->set_lookat(0.0); 
			camera_ptr->set_view_distance(17000.0);
			camera_ptr->compute_uvw();     
			set_camera(camera_ptr); 
	
	
			// image:					

			Image* image_ptr = new Image;				
			image_ptr->read_ppm_file(QString(ppmfile+"SphereGrid.ppm").toLatin1().data());
	
	
			// mapping:
	
			SphericalMap* map_ptr = new SphericalMap; 
	
	
			// image based texture:  
	
			ImageTexture* texture_ptr = new ImageTexture; 
			texture_ptr->set_image(image_ptr); 
			texture_ptr->set_mapping(map_ptr);
	
	
			// textured material:

			SV_Emissive* sv_emissive_ptr = new SV_Emissive;	
			sv_emissive_ptr->scale_radiance(1.0);	
			sv_emissive_ptr->set_ce(texture_ptr);
	
	
			// generic sphere:
	
			Sphere*	sphere_ptr = new Sphere; 
			sphere_ptr->set_material(sv_emissive_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 360:
		{
			//29.10b
			if( !CheckFile(QString(ppmfile+"Sarah.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(400);      
			vp.set_vres(400);    
			vp.set_samples(num_samples);
	
			background_color = black;
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
			camera_ptr->set_eye(0, -65, 0); 
			camera_ptr->set_lookat(0.0); 
			camera_ptr->set_view_distance(12000.0); 
			camera_ptr->compute_uvw();     
			set_camera(camera_ptr); 
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, -1, 0);
			light_ptr->scale_radiance(1.5);  
			add_light(light_ptr);
	
	
			// image:					

			Image* image_ptr = new Image;				
			image_ptr->read_ppm_file(QString(ppmfile+"Sarah.ppm").toLatin1().data());
	
	
			// mapping:
	
			SphericalMap* map_ptr = new SphericalMap; 
	
	
			// image based texture:  
	
			ImageTexture* texture_ptr = new ImageTexture; 
			texture_ptr->set_image(image_ptr); 
			texture_ptr->set_mapping(map_ptr);
	
	
			// textured material:

			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.45);
			sv_matte_ptr->set_kd(0.65);
			sv_matte_ptr->set_cd(texture_ptr);
	
	
			// generic sphere:
	
			Sphere*	sphere_ptr = new Sphere; 
			sphere_ptr->set_material(sv_matte_ptr);
	
	
			// rotated sphere
	
			Instance* sarah_ptr = new Instance(sphere_ptr);
			sarah_ptr->rotate_y(180);
			add_object(sarah_ptr);
			break;
		}
	case 361:
		{
			//29.11b
			if( !CheckFile(QString(ppmfile+"BilliardBall.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(400);      
			vp.set_vres(400);    
			vp.set_samples(num_samples);
		
			background_color = black;
	
			tracer_ptr = new RayCast(this);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			Pinhole* camera_ptr = new Pinhole;
			camera_ptr->set_eye(50, 10, 50);				
			camera_ptr->set_lookat(0.0); 
			camera_ptr->set_view_distance(11000.0); 
			camera_ptr->compute_uvw();     
			set_camera(camera_ptr); 
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(100, 50, 50);
			light_ptr1->scale_radiance(1.5); 
			light_ptr1->set_shadows(true); 
			add_light(light_ptr1);
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(100, 200, -100);
			light_ptr2->scale_radiance(1.5);
			light_ptr2->set_shadows(true);   
			add_light(light_ptr2);
	
	
			// image:					

			Image* image_ptr = new Image;				
			image_ptr->read_ppm_file(QString(ppmfile+"BilliardBall.ppm").toLatin1().data());
	
	
			// mapping:
	
			SphericalMap* map_ptr = new SphericalMap; 
	
	
			// image based texture:  
	
			ImageTexture* texture_ptr = new ImageTexture; 
			texture_ptr->set_image(image_ptr); 
			texture_ptr->set_mapping(map_ptr);
	
	
			// textured material:

			SV_Phong* sv_phong_ptr = new SV_Phong;		
			sv_phong_ptr->set_ka(0.5);
			sv_phong_ptr->set_kd(0.8);
			sv_phong_ptr->set_cd(texture_ptr);
			sv_phong_ptr->set_ks(0.25);
			sv_phong_ptr->set_exp(500.0);
			sv_phong_ptr->set_cs(new ConstantColor());
	
	
			// generic sphere:
	
			Sphere*	sphere_ptr = new Sphere; 
			sphere_ptr->set_material(sv_phong_ptr);
	
	
			// rotated sphere
	
			Instance* billard_ball_ptr = new Instance(sphere_ptr);
			billard_ball_ptr->rotate_y(-30);
			add_object(billard_ball_ptr);
	
	
			// plane
	
			Matte* matte_ptr = new Matte;		
			matte_ptr->set_ka(0.5);
			matte_ptr->set_kd(0.5);
			matte_ptr->set_cd(0.2, 0.75, 0.2);
	
			Plane* plane_ptr = new Plane(Point3D(0, -1, 0), Vector3D(0, 1, 0));
			plane_ptr->set_material(matte_ptr);
			add_object(plane_ptr);
			break;
		}
	case 362:
		{
			//29.12b
			if( !CheckFile(QString(ppmfile+"EarthHighRes.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(700);      
			vp.set_vres(700);    
			vp.set_samples(num_samples);
		
			background_color = black;
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
			camera_ptr->set_eye(0, 0, 65); 				
			camera_ptr->set_lookat(0.0); 
			camera_ptr->set_view_distance(21000.0);
			camera_ptr->compute_uvw();     
			set_camera(camera_ptr); 
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(-0.25, 0.4, 1);		
			light_ptr->scale_radiance(2.5); 
			add_light(light_ptr);
	
	
			// image:					

			Image* image_ptr = new Image;				
		//	image_ptr->read_ppm_file("EarthLowRes.ppm");
			image_ptr->read_ppm_file(QString(ppmfile+"EarthHighRes.ppm").toLatin1().data());
	
	
			// mapping:
	
			SphericalMap* map_ptr = new SphericalMap; 
	
	
			// image based texture:  
	
			ImageTexture* texture_ptr = new ImageTexture; 
			texture_ptr->set_image(image_ptr); 
			texture_ptr->set_mapping(map_ptr);
	
	
			// textured material:

			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.2);
			sv_matte_ptr->set_kd(0.8);
			sv_matte_ptr->set_cd(texture_ptr);
	
	
			// generic sphere:
	
			Sphere*	sphere_ptr = new Sphere; 
			sphere_ptr->set_material(sv_matte_ptr);
	
	
			// rotated sphere
	
			Instance* earth_ptr = new Instance(sphere_ptr);
			earth_ptr->rotate_y(60);
			add_object(earth_ptr);
			break;
		}
	case 363:
		{
			//29.13
			if( !CheckFile(QString(ppmfile+"EarthHighRes.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(700);      
			vp.set_vres(700);    
			vp.set_samples(num_samples);
	
			background_color = black;
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
			camera_ptr->set_eye(0, 65, 0); 				
			camera_ptr->set_lookat(0.0); 
			camera_ptr->set_view_distance(21000.0); 
			camera_ptr->compute_uvw();     
			set_camera(camera_ptr); 
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 1, 0);		
			light_ptr->scale_radiance(2.5);  
			add_light(light_ptr);
	
	
			// image:					

			Image* image_ptr = new Image;	
		//	image_ptr->read_ppm_file("EarthLowRes.ppm");			
			image_ptr->read_ppm_file(QString(ppmfile+"EarthHighRes.ppm").toLatin1().data());
	
	
			// mapping:
	
			SphericalMap* map_ptr = new SphericalMap; 
	
	
			// image based texture:  
	
			ImageTexture* texture_ptr = new ImageTexture; 
			texture_ptr->set_image(image_ptr); 
			texture_ptr->set_mapping(map_ptr);
	
	
			// textured material:

			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.2);
			sv_matte_ptr->set_kd(0.8);
			sv_matte_ptr->set_cd(texture_ptr);
	
	
			// generic sphere:
	
			Sphere*	sphere_ptr = new Sphere; 
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 364:
		{
			//29.16
			if( !CheckFile(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(900);			
			vp.set_vres(900); 
			vp.set_samples(num_samples);
			vp.set_pixel_size(1.0);
	
			tracer_ptr = new RayCast(this);	
	
			FishEye* fisheye_ptr = new FishEye;
			fisheye_ptr->set_eye(0.0); 
			fisheye_ptr->set_lookat(0, 0, -100);
			fisheye_ptr->set_fov(360);
			fisheye_ptr->compute_uvw(); 
			set_camera(fisheye_ptr);
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"uffizi_probe_small.ppm").toLatin1().data());   // development
		//	image_ptr->read_ppm_file("uffizi_probe_large.ppm");   // production

			LightProbeMap* light_probe_ptr = new LightProbeMap;     	
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(light_probe_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;	// ka + kd > 1
			sv_matte_ptr->set_ka(1.0);
			sv_matte_ptr->set_kd(0.85); 	
			sv_matte_ptr->set_cd(image_texture_ptr);
	
			Sphere* unit_sphere_ptr = new Sphere;
			unit_sphere_ptr->set_shadows(false);	
	
			Instance* sphere_ptr = new Instance(unit_sphere_ptr); 
			sphere_ptr->scale(1000000.0);
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 365:
		{
			//29.19a
			if( !CheckFile(QString(ppmfile+"EarthLowRes.ppm").toLatin1().data()))
				return;

			int num_samples = 1;      	// for Figures 29.19(a) & (b)
		//	int num_samples = 25;      	// for Figure 29.19(c)
	
			vp.set_hres(300);      
			vp.set_vres(300);    
			vp.set_samples(num_samples);
		
			background_color = black;
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
			camera_ptr->set_eye(0, 0, 65); 				
			camera_ptr->set_lookat(0.0); 
			camera_ptr->set_view_distance(9000.0);			// for Figure 29.19(a)
		//	camera_ptr->set_view_distance(9000.0 * 8.0);	// for Figure 29.19(b)
		//	camera_ptr->set_view_distance(9000.0 * 20.0);	// for Figure 29.19(c)
			camera_ptr->compute_uvw();     
			set_camera(camera_ptr); 
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(-0.25, 0.4, 1);		
			light_ptr->scale_radiance(2.5);  
			add_light(light_ptr);
	
	
			// image:					

			Image* image_ptr = new Image;				
			image_ptr->read_ppm_file(QString(ppmfile+"EarthLowRes.ppm").toLatin1().data());
	
	
			// mapping:
	
			SphericalMap* map_ptr = new SphericalMap; 
	
	
			// image based texture:  
	
			ImageTexture* texture_ptr = new ImageTexture; 
			texture_ptr->set_image(image_ptr); 
			texture_ptr->set_mapping(map_ptr);
	
	
			// textured material:

			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.2);
			sv_matte_ptr->set_kd(0.8);
			sv_matte_ptr->set_cd(texture_ptr);
	
	
			// generic sphere:
	
			Sphere*	sphere_ptr = new Sphere; 
			sphere_ptr->set_material(sv_matte_ptr);
	
	
			// rotated sphere
	
			Instance* earth_ptr = new Instance(sphere_ptr);
			earth_ptr->rotate_y(-72);
			earth_ptr->rotate_x(40);
			earth_ptr->rotate_z(20);
			add_object(earth_ptr);
			break;
		}
	case 366:
		{
			//29.19b
			if( !CheckFile(QString(ppmfile+"EarthLowRes.ppm").toLatin1().data()))
				return;

			int num_samples = 1;      	// for Figures 29.19(a) & (b)
		//	int num_samples = 25;      	// for Figure 29.19(c)
	
			vp.set_hres(300);      
			vp.set_vres(300);    
			vp.set_samples(num_samples);
		
			background_color = black;
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
			camera_ptr->set_eye(0, 0, 65); 				
			camera_ptr->set_lookat(0.0); 
		//	camera_ptr->set_view_distance(9000.0);			// for Figure 29.19(a)
			camera_ptr->set_view_distance(9000.0 * 8.0);	// for Figure 29.19(b)
		//	camera_ptr->set_view_distance(9000.0 * 20.0);	// for Figure 29.19(c)
			camera_ptr->compute_uvw();     
			set_camera(camera_ptr); 
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(-0.25, 0.4, 1);		
			light_ptr->scale_radiance(2.5);  
			add_light(light_ptr);
	
	
			// image:					

			Image* image_ptr = new Image;				
			image_ptr->read_ppm_file(QString(ppmfile+"EarthLowRes.ppm").toLatin1().data());
	
	
			// mapping:
	
			SphericalMap* map_ptr = new SphericalMap; 
	
	
			// image based texture:  
	
			ImageTexture* texture_ptr = new ImageTexture; 
			texture_ptr->set_image(image_ptr); 
			texture_ptr->set_mapping(map_ptr);
	
	
			// textured material:

			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.2);
			sv_matte_ptr->set_kd(0.8);
			sv_matte_ptr->set_cd(texture_ptr);
	
	
			// generic sphere:
	
			Sphere*	sphere_ptr = new Sphere; 
			sphere_ptr->set_material(sv_matte_ptr);
	
	
			// rotated sphere
	
			Instance* earth_ptr = new Instance(sphere_ptr);
			earth_ptr->rotate_y(-72);
			earth_ptr->rotate_x(40);
			earth_ptr->rotate_z(20);
			add_object(earth_ptr);
			break;
		}
	case 367:
		{
			//29.19c
			if( !CheckFile(QString(ppmfile+"EarthLowRes.ppm").toLatin1().data()))
				return;

		//	int num_samples = 1;      	// for Figures 29.19(a) & (b)
			int num_samples = 25;      	// for Figure 29.19(c)
	
			vp.set_hres(300);      
			vp.set_vres(300);    
			vp.set_samples(num_samples);
		
			background_color = black;
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* camera_ptr = new Pinhole;
			camera_ptr->set_eye(0, 0, 65); 				
			camera_ptr->set_lookat(0.0); 
		//	camera_ptr->set_view_distance(9000.0);			// for Figure 29.19(a)
		//	camera_ptr->set_view_distance(9000.0 * 8.0);	// for Figure 29.19(b)
			camera_ptr->set_view_distance(9000.0 * 20.0);	// for Figure 29.19(c)
			camera_ptr->compute_uvw();     
			set_camera(camera_ptr); 
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(-0.25, 0.4, 1);		
			light_ptr->scale_radiance(2.5);  
			add_light(light_ptr);

			// image:					

			Image* image_ptr = new Image;				
			image_ptr->read_ppm_file(QString(ppmfile+"EarthLowRes.ppm").toLatin1().data());
	
	
			// mapping:
	
			SphericalMap* map_ptr = new SphericalMap; 
	
	
			// image based texture:  
	
			ImageTexture* texture_ptr = new ImageTexture; 
			texture_ptr->set_image(image_ptr); 
			texture_ptr->set_mapping(map_ptr);
	
	
			// textured material:

			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.2);
			sv_matte_ptr->set_kd(0.8);
			sv_matte_ptr->set_cd(texture_ptr);
	
	
			// generic sphere:
	
			Sphere*	sphere_ptr = new Sphere; 
			sphere_ptr->set_material(sv_matte_ptr);
	
	
			// rotated sphere
	
			Instance* earth_ptr = new Instance(sphere_ptr);
			earth_ptr->rotate_y(-72);
			earth_ptr->rotate_x(40);
			earth_ptr->rotate_z(20);
			add_object(earth_ptr);
			break;
		}
	case 368:
		{
			//29.22a
			if( !CheckFile(QString(ppmfile+"BlueGlass.ppm").toLatin1().data()))
				return;

			if( !CheckFile(QString(plyfile+"TwoUVTriangles.ply").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(400);      
			vp.set_vres(400);    
			vp.set_samples(num_samples);	
	
			tracer_ptr = new RayCast(this);
	
			background_color = black;

			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(11, 5, 9);  
			pinhole_ptr->set_view_distance(1600.0);
			pinhole_ptr->set_lookat(0, -0.5, 0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 

	
			Directional* directional_ptr = new Directional;
			directional_ptr->set_direction(0.75, 1, -0.15);     
			directional_ptr->scale_radiance(4.5); 
			directional_ptr->set_shadows(true);
			add_light(directional_ptr);
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"BlueGlass.ppm").toLatin1().data());
	
			ImageTexture* texture_ptr = new ImageTexture; 
			texture_ptr->set_image(image_ptr);

			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.1);
			sv_matte_ptr->set_kd(0.75);
			sv_matte_ptr->set_cd(texture_ptr);
		
			const char* file_name = "TwoUVTriangles.ply";
			Grid* grid_ptr = new Grid(new Mesh);
			grid_ptr->read_flat_uv_triangles(QString(plyfile+"TwoUVTriangles.ply").toLatin1().data());		// for Figure 29.22(a)
		//	grid_ptr->read_smooth_uv_triangles(file_name);		// for Figure 29.22(b)
			grid_ptr->set_material(sv_matte_ptr);   
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
	
			Matte* matte_ptr = new Matte;			
			matte_ptr->set_cd(1, 0.9, 0.6);
			matte_ptr->set_ka(0.25); 
			matte_ptr->set_kd(0.4);
		
			Plane* plane_ptr1 = new Plane(Point3D(0, -2.0, 0), Normal(0, 1, 0));  
			plane_ptr1->set_material(matte_ptr);
			add_object(plane_ptr1);	
			break;
		}
	case 369:
		{
			//29.22b
			if( !CheckFile(QString(ppmfile+"BlueGlass.ppm").toLatin1().data()))
				return;

			if( !CheckFile(QString(plyfile+"TwoUVTriangles.ply").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(400);      
			vp.set_vres(400);    
			vp.set_samples(num_samples);	
	
			tracer_ptr = new RayCast(this);
	
			background_color = black;

			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(11, 5, 9);  
			pinhole_ptr->set_view_distance(1600.0);
			pinhole_ptr->set_lookat(0, -0.5, 0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 

	
			Directional* directional_ptr = new Directional;
			directional_ptr->set_direction(0.75, 1, -0.15);     
			directional_ptr->scale_radiance(4.5); 
			directional_ptr->set_shadows(true);
			add_light(directional_ptr);
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"BlueGlass.ppm").toLatin1().data());
	
			ImageTexture* texture_ptr = new ImageTexture; 
			texture_ptr->set_image(image_ptr);

			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.1);
			sv_matte_ptr->set_kd(0.75);
			sv_matte_ptr->set_cd(texture_ptr);
		
			const char* file_name = "TwoUVTriangles.ply";
			Grid* grid_ptr = new Grid(new Mesh);
		//	grid_ptr->read_flat_uv_triangles(QString(plyfile+"TwoUVTriangles.ply").toLatin1().data());		// for Figure 29.22(a)
			grid_ptr->read_smooth_uv_triangles(QString(plyfile+"TwoUVTriangles.ply").toLatin1().data());		// for Figure 29.22(b)
			grid_ptr->set_material(sv_matte_ptr);   
			grid_ptr->setup_cells();
			add_object(grid_ptr);
	
	
			Matte* matte_ptr = new Matte;			
			matte_ptr->set_cd(1, 0.9, 0.6);
			matte_ptr->set_ka(0.25); 
			matte_ptr->set_kd(0.4);
		
			Plane* plane_ptr1 = new Plane(Point3D(0, -2.0, 0), Normal(0, 1, 0));  
			plane_ptr1->set_material(matte_ptr);
			add_object(plane_ptr1);	
			break;
		}
	case 370:
		{
			//29.26a
			if( !CheckFile(QString(ppmfile+"label.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 8, 30); 
			pinhole_ptr->set_lookat(0, 2, 0); 
			pinhole_ptr->set_view_distance(2000.0); 	  
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	

			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(10, 10, 5);				
			light_ptr1->scale_radiance(1.5); 
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);	
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(0, 0, 1);				
			light_ptr2->scale_radiance(1.5); 
			light_ptr2->set_shadows(false);
			add_light(light_ptr2);	
	
	
			// product jar
	
			Matte* matte_ptr = new Matte;
			matte_ptr->set_ka(0.25);
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(0.9, 1.0, 0.9);     	// pale green
	
			Matte* body_matte_ptr = new Matte;
			body_matte_ptr->set_ka(0.25);
			body_matte_ptr->set_kd(0.75);
			body_matte_ptr->set_cd(red);
	
			Image* image_ptr = new Image;
			image_ptr->read_ppm_file(QString(ppmfile+"label.ppm").toLatin1().data());
	
			CylindericalMap* cylindical_map_ptr = new CylindericalMap;   
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(cylindical_map_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.75);
			sv_matte_ptr->set_cd(image_texture_ptr);
	
	
			// The product jar is centered on the y axis
			// The radius of the cap is body_radius - top_bevel_radius
			// The texture image used here completely covers the vertical curved surface
			// of the body. This has vertical extent from bottom + bottom_bevel_radius
			// to body top - bottom_bevel_radius.
			// If you use the body_matte_ptr defined above for the body, it will be rendered red.
			// See extra image in the Chapter 29 download.
	
	
			double bottom 				= 0.0;		// along y axis
			double body_top 			= 3.6;		// along y axis
			double cap_top 				= 4.1;		// along y axis
			double body_radius 			= 3.0;
			double bottom_bevel_radius 	= 0.5;	  	
			double top_bevel_radius 	= 0.5;		
			double cap_bevel_radius 	= 0.05;		
	
			ProductJar* product_jar_ptr = new ProductJar(	bottom,
															body_top,
															cap_top,
															body_radius,
															bottom_bevel_radius,
															top_bevel_radius,
															cap_bevel_radius);
			product_jar_ptr->set_material(matte_ptr);
		//	product_jar_ptr->set_body_material(body_matte_ptr);		// renders vertical body surface red
			product_jar_ptr->set_body_material(sv_matte_ptr);
	
			Instance* rotated_jar_ptr = new Instance(product_jar_ptr);
			rotated_jar_ptr->rotate_y(180); 		// for Figure 29.26(a)
		//	rotated_jar_ptr->rotate_y(100);  		// for Figure 29.26(b)
			add_object(rotated_jar_ptr);


			// ground plane
	
			Matte* matte_ptr2 = new Matte;		
			matte_ptr2->set_ka(0.25);
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.5);
	
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);
			break;
		}
	case 371:
		{
			//29.26b
			if( !CheckFile(QString(ppmfile+"label.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(10, 8, 30); 
			pinhole_ptr->set_lookat(0, 2, 0); 
			pinhole_ptr->set_view_distance(2000.0); 	  
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	

			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(10, 10, 5);				
			light_ptr1->scale_radiance(1.5); 
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);	
	
			Directional* light_ptr2 = new Directional;
			light_ptr2->set_direction(0, 0, 1);				
			light_ptr2->scale_radiance(1.5); 
			light_ptr2->set_shadows(false);
			add_light(light_ptr2);	
	
	
			// product jar
	
			Matte* matte_ptr = new Matte;
			matte_ptr->set_ka(0.25);
			matte_ptr->set_kd(0.75);
			matte_ptr->set_cd(0.9, 1.0, 0.9);     	// pale green
	
			Matte* body_matte_ptr = new Matte;
			body_matte_ptr->set_ka(0.25);
			body_matte_ptr->set_kd(0.75);
			body_matte_ptr->set_cd(red);
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"label.ppm").toLatin1().data());
	
			CylindericalMap* cylindical_map_ptr = new CylindericalMap;   
	
			ImageTexture* image_texture_ptr = new ImageTexture(image_ptr); 
			image_texture_ptr->set_mapping(cylindical_map_ptr);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.75);
			sv_matte_ptr->set_cd(image_texture_ptr);
	
	
			// The product jar is centered on the y axis
			// The radius of the cap is body_radius - top_bevel_radius
			// The texture image used here completely covers the vertical curved surface
			// of the body. This has vertical extent from bottom + bottom_bevel_radius
			// to body top - bottom_bevel_radius.
			// If you use the body_matte_ptr defined above for the body, it will be rendered red.
			// See extra image in the Chapter 29 download.
	
	
			double bottom 				= 0.0;		// along y axis
			double body_top 			= 3.6;		// along y axis
			double cap_top 				= 4.1;		// along y axis
			double body_radius 			= 3.0;
			double bottom_bevel_radius 	= 0.5;	  	
			double top_bevel_radius 	= 0.5;		
			double cap_bevel_radius 	= 0.05;		
	
			ProductJar* product_jar_ptr = new ProductJar(	bottom,
															body_top,
															cap_top,
															body_radius,
															bottom_bevel_radius,
															top_bevel_radius,
															cap_bevel_radius);
			product_jar_ptr->set_material(matte_ptr);
		//	product_jar_ptr->set_body_material(body_matte_ptr);		// renders vertical body surface red
			product_jar_ptr->set_body_material(sv_matte_ptr);
	
			Instance* rotated_jar_ptr = new Instance(product_jar_ptr);
		//	rotated_jar_ptr->rotate_y(180); 		// for Figure 29.26(a)
			rotated_jar_ptr->rotate_y(100);  		// for Figure 29.26(b)
			add_object(rotated_jar_ptr);


			// ground plane
	
			Matte* matte_ptr2 = new Matte;		
			matte_ptr2->set_ka(0.25);
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.5);
	
			Plane* plane_ptr = new Plane(Point3D(0.0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr2);
			add_object(plane_ptr);
			break;
		}
	case 372:
		{
			//29.27a
			if( !CheckFile(QString(ppmfile+"EveningSky.ppm").toLatin1().data()))
				return;

			int num_samples = 100;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_max_depth(5);
	
			tracer_ptr = new AreaLighting(this);	
		
			AmbientOccluder* ambient_occluder_ptr = new AmbientOccluder;
			ambient_occluder_ptr->set_sampler(new MultiJittered(num_samples));
			ambient_occluder_ptr->set_min_amount(0.5);
			set_ambient_light(ambient_occluder_ptr);

			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 45, 100); 
			pinhole_ptr->set_lookat(-10, 40, 0);  
			pinhole_ptr->set_view_distance(400);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(150, 250, -150);   
			light_ptr->scale_radiance(1.5);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// image
	
			Image* image_ptr = new Image;	
			image_ptr->read_ppm_file(QString(ppmfile+"EveningSky.ppm").toLatin1().data());			// for Figure 29.27(a)
		//	image_ptr->read_ppm_file("MorningSky.ppm");			// for Figure 29.27(b)	
	
	
			// image texture
	 
			HemisphericalMap* map_ptr = new HemisphericalMap;  
			ImageTexture* texture_ptr = new ImageTexture; 
			texture_ptr->set_image(image_ptr);
			texture_ptr->set_mapping(map_ptr);
	
	
			// spatially varying material
	
			SV_Emissive* sv_emissive_ptr = new SV_Emissive;
			sv_emissive_ptr->set_ce(texture_ptr);
			sv_emissive_ptr->scale_radiance(1.0);
	
	
			EnvironmentLight* environment_light_ptr = new EnvironmentLight;
			environment_light_ptr->set_material(sv_emissive_ptr);
			environment_light_ptr->set_sampler(new MultiJittered(num_samples));
			environment_light_ptr->set_shadows(true);
			add_light(environment_light_ptr);


	
			// large concave hemisphere for direct rendering of the skies
	
			ConcaveHemisphere* unit_hemisphere_ptr = new ConcaveHemisphere;
			Instance* hemisphere_ptr = new Instance(unit_hemisphere_ptr); 
			hemisphere_ptr->set_shadows(false);
			hemisphere_ptr->scale(1000000.0);
			hemisphere_ptr->rotate_y(-30);   
			hemisphere_ptr->set_material(sv_emissive_ptr);
			add_object(hemisphere_ptr);							
	
	
			// the other objects
	
			// large sphere - reflective
	
			Reflective* reflective_ptr1 = new Reflective;			
			reflective_ptr1->set_kr(0.9);
			reflective_ptr1->set_cr(1.0, 0.75, 0.5);       // pink
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, 20, -24), 20);
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
	
	
			// small sphere - non reflective
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.2); 
			matte_ptr1->set_kd(0.5);
			matte_ptr1->set_cd(0.85);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(34, 12, 13), 12);
			sphere_ptr2->set_material(matte_ptr1);
			add_object(sphere_ptr2);
	
	
			// medium sphere - reflective
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(-7, 15, 42), 16);
			sphere_ptr3->set_material(reflective_ptr1);
			add_object(sphere_ptr3);
	
	
			// cylinder - reflective
	
			Reflective* reflective_ptr2 = new Reflective;	
			reflective_ptr2->set_kr(0.9);
			reflective_ptr2->set_cr(1.0, 1.0, 0.5);   // lemon
	
			double bottom 	= 0.0;
			double top 		= 85.0; 
			double radius	= 22.0;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(reflective_ptr2);
			add_object(cylinder_ptr);

	
			// box - non reflective
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.2); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.95);
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(matte_ptr2);
			add_object(box_ptr);				
	
	
			// ground plane:
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(0.15); 
			matte_ptr3->set_kd(0.5);	
			matte_ptr3->set_cd(0.7);    
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr3);
			add_object(plane_ptr);
			break;
		}
	case 373:
		{
			//29.27b
			if( !CheckFile(QString(ppmfile+"EveningSky.ppm").toLatin1().data()))
				return;

			int num_samples = 100;
	
			vp.set_hres(600);
			vp.set_vres(400);
			vp.set_samples(num_samples);
			vp.set_max_depth(5);
	
			tracer_ptr = new AreaLighting(this);	
		
			AmbientOccluder* ambient_occluder_ptr = new AmbientOccluder;
			ambient_occluder_ptr->set_sampler(new MultiJittered(num_samples));
			ambient_occluder_ptr->set_min_amount(0.5);
			set_ambient_light(ambient_occluder_ptr);

			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 45, 100); 
			pinhole_ptr->set_lookat(-10, 40, 0);  
			pinhole_ptr->set_view_distance(400);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(150, 250, -150);   
			light_ptr->scale_radiance(1.5);
			light_ptr->set_shadows(true);
			add_light(light_ptr);
	
	
			// image
	
			Image* image_ptr = new Image;	
		//	image_ptr->read_ppm_file(QString(ppmfile+"EveningSky.ppm").toLatin1().data());			// for Figure 29.27(a)
			image_ptr->read_ppm_file(QString(ppmfile+"EveningSky.ppm").toLatin1().data());			// for Figure 29.27(b)	
	
	
			// image texture
	 
			HemisphericalMap* map_ptr = new HemisphericalMap;  
			ImageTexture* texture_ptr = new ImageTexture; 
			texture_ptr->set_image(image_ptr);
			texture_ptr->set_mapping(map_ptr);
	
	
			// spatially varying material
	
			SV_Emissive* sv_emissive_ptr = new SV_Emissive;
			sv_emissive_ptr->set_ce(texture_ptr);
			sv_emissive_ptr->scale_radiance(1.0);
	
	
			EnvironmentLight* environment_light_ptr = new EnvironmentLight;
			environment_light_ptr->set_material(sv_emissive_ptr);
			environment_light_ptr->set_sampler(new MultiJittered(num_samples));
			environment_light_ptr->set_shadows(true);
			add_light(environment_light_ptr);


	
			// large concave hemisphere for direct rendering of the skies
	
			ConcaveHemisphere* unit_hemisphere_ptr = new ConcaveHemisphere;
			Instance* hemisphere_ptr = new Instance(unit_hemisphere_ptr); 
			hemisphere_ptr->set_shadows(false);
			hemisphere_ptr->scale(1000000.0);
			hemisphere_ptr->rotate_y(-30);   
			hemisphere_ptr->set_material(sv_emissive_ptr);
			add_object(hemisphere_ptr);							
	
	
			// the other objects
	
			// large sphere - reflective
	
			Reflective* reflective_ptr1 = new Reflective;			
			reflective_ptr1->set_kr(0.9);
			reflective_ptr1->set_cr(1.0, 0.75, 0.5);       // pink
	
			Sphere* sphere_ptr1 = new Sphere(Point3D(38, 20, -24), 20);
			sphere_ptr1->set_material(reflective_ptr1);
			add_object(sphere_ptr1);
	
	
			// small sphere - non reflective
	
			Matte* matte_ptr1 = new Matte;			
			matte_ptr1->set_ka(0.2); 
			matte_ptr1->set_kd(0.5);
			matte_ptr1->set_cd(0.85);
	
			Sphere* sphere_ptr2 = new Sphere(Point3D(34, 12, 13), 12);
			sphere_ptr2->set_material(matte_ptr1);
			add_object(sphere_ptr2);
	
	
			// medium sphere - reflective
	
			Sphere* sphere_ptr3 = new Sphere(Point3D(-7, 15, 42), 16);
			sphere_ptr3->set_material(reflective_ptr1);
			add_object(sphere_ptr3);
	
	
			// cylinder - reflective
	
			Reflective* reflective_ptr2 = new Reflective;	
			reflective_ptr2->set_kr(0.9);
			reflective_ptr2->set_cr(1.0, 1.0, 0.5);   // lemon
	
			double bottom 	= 0.0;
			double top 		= 85.0; 
			double radius	= 22.0;
			SolidCylinder* cylinder_ptr = new SolidCylinder(bottom, top, radius);
			cylinder_ptr->set_material(reflective_ptr2);
			add_object(cylinder_ptr);

	
			// box - non reflective
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.2); 
			matte_ptr2->set_kd(0.5);
			matte_ptr2->set_cd(0.95);
	
			Box* box_ptr = new Box(Point3D(-35, 0, -110), Point3D(-25, 60, 65));
			box_ptr->set_material(matte_ptr2);
			add_object(box_ptr);				
	
	
			// ground plane:
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_ka(0.15); 
			matte_ptr3->set_kd(0.5);	
			matte_ptr3->set_cd(0.7);    
	
			Plane* plane_ptr = new Plane(Point3D(0, 0.01, 0), Normal(0, 1, 0));
			plane_ptr->set_material(matte_ptr3);
			add_object(plane_ptr);
			break;
		}
	case 374:
		{
			//30.01a
			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);    
			set_ambient_light(ambient_ptr);
	
			background_color = RGBColor(black);

			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(6, 8, 12);         
			pinhole_ptr->set_lookat(0.0, -0.1, 0.0); 
			pinhole_ptr->set_view_distance(2850.0);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(-2, 4, 10);  
			light_ptr->scale_radiance(4.5);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
	
			// wrapped noise texture
	
			// noise
	
			CubicNoise* noise_ptr = new CubicNoise;
			noise_ptr->set_num_octaves(4);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);
	
			// texture
	
			WrappedFBmTexture* wrapped_texture_ptr = new WrappedFBmTexture(noise_ptr);	
			wrapped_texture_ptr->set_color(1.0, 0.85, 0.0);   // yellow
			wrapped_texture_ptr->set_expansion_number(10.0);	
	
			TInstance* scaled_texture_ptr = new TInstance(wrapped_texture_ptr);
			scaled_texture_ptr->scale(0.75);
	
			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(scaled_texture_ptr);
	
	
	
			// cut cube parameters
	
			Point3D p0(-1.0);
			Point3D p1(1.0);
			double sphere_radius = 1.5;
	
			CutCube* cut_cube_ptr = new CutCube(p0, p1, sphere_radius); 
			cut_cube_ptr->set_material(sv_matte_ptr);
			add_object(cut_cube_ptr);
	
			// concave part sphere parameters
	
			Point3D center(p1);
			double radius 		= sphere_radius;
			double phi_min 		= 180.0;
			double phi_max 		= 270.0;
			double theta_min	= 90.0;
			double theta_max 	= 180.0;
	
			ConcavePartSphere* part_sphere_ptr = new ConcavePartSphere(	center, 
																		radius, 
																		phi_min, 
																		phi_max, 
																		theta_min, 
																		theta_max);
			part_sphere_ptr->set_material(sv_matte_ptr);
			add_object(part_sphere_ptr);

			break;
		}
	case 375:
		{
			//30.01b
			if( !CheckFile(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);    
			set_ambient_light(ambient_ptr);
	
			background_color = RGBColor(black);
		

			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(6, 8, 12);        
			pinhole_ptr->set_lookat(0.0, -0.1, 0.0); 
			pinhole_ptr->set_view_distance(2850.0); 
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(-2, 4, 10); 
			light_ptr->scale_radiance(3.0);  
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	

			// marble

			// ramp image
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data());

	
			// marble exture
	
			// The following RampFBmTexture constructor sets lacunarity = 2 and gain = 0.5.
			// These are the default values for LatticeNoise. See Chapter 31.
	
			int 	num_octaves = 6;     
			float 	fbm_amount 	= 8.0;
		
			RampFBmTexture* marble_ptr = new RampFBmTexture(image_ptr, num_octaves, fbm_amount);

			TInstance* transformed_marble_ptr = new TInstance(marble_ptr);
			transformed_marble_ptr->scale(0.2);
			transformed_marble_ptr->rotate_z(80);
	

			// material
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(transformed_marble_ptr);
	
			// cut cube parameters
	
			Point3D p0(-1.0);
			Point3D p1(1.0);
			double sphere_radius = 1.5;
	
			CutCube* cut_cube_ptr = new CutCube(p0, p1, sphere_radius); 
			cut_cube_ptr->set_material(sv_matte_ptr);
			add_object(cut_cube_ptr);
	
	
			// concave part sphere parameters
	
			Point3D center(p1);
			double radius 		= sphere_radius;
			double phi_min 		= 180.0;
			double phi_max 		= 270.0;
			double theta_min	= 90.0;
			double theta_max 	= 180.0;
	
			ConcavePartSphere* part_sphere_ptr = new ConcavePartSphere(	center, 
																		radius, 
																		phi_min, 
																		phi_max, 
																		theta_min, 
																		theta_max);
			part_sphere_ptr->set_material(sv_matte_ptr);
			add_object(part_sphere_ptr);
			break;
		}
	case 376:
		{
			//31.01c
			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = RGBColor(black);
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(1.0);   
			set_ambient_light(ambient_ptr);
		

			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(6, 8, 12);         
			pinhole_ptr->set_lookat(0.0, -0.1, 0.0); 
			pinhole_ptr->set_view_distance(2850.0);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(-2, 4, 10); 
			light_ptr->scale_radiance(4.5);  
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
	
			// cut cube
	
			// wood texture
	
			// This Wood constructor just specifies the light and dark colors.
			// The other parameters are defaults.
			// There are also other constructors for the Wood class.

			Wood* wood_ptr = new Wood(RGBColor(0.5, 0.2, 0.067), black); 
	
			TInstance* transformed_wood_ptr = new TInstance(wood_ptr);
			transformed_wood_ptr->scale(0.4);
			transformed_wood_ptr->rotate_x(3);
			transformed_wood_ptr->translate(0.0, 0.0, 0.05);
	
			// material
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.75);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(transformed_wood_ptr);
	
	
			// cut cube parameters
	
			Point3D p0(-1.0);
			Point3D p1(1.0);
			double sphere_radius = 1.5;
	
			CutCube* cut_cube_ptr = new CutCube(p0, p1, sphere_radius); 
			cut_cube_ptr->set_material(sv_matte_ptr);
			add_object(cut_cube_ptr);
	
	
			// concave part sphere parameters
	
			Point3D center(p1);
			double radius 		= sphere_radius;
			double phi_min 		= 180.0;
			double phi_max 		= 270.0;
			double theta_min	= 90.0;
			double theta_max 	= 180.0;
	
			ConcavePartSphere* part_sphere_ptr = new ConcavePartSphere(	center, 
																		radius, 
																		phi_min, 
																		phi_max, 
																		theta_min, 
																		theta_max);
			part_sphere_ptr->set_material(sv_matte_ptr);
			add_object(part_sphere_ptr);
			break;
		}
	case 377:
		{
			//30.02
			int num_samples = 16;
	
			vp.set_hres(880);
			vp.set_vres(300);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = RGBColor(0.5);
	
			Pinhole* pinholePtr = new Pinhole;
			pinholePtr->set_eye(100, 100, 300); 
			pinholePtr->set_lookat(-0.2, 1.0, 0); 
			pinholePtr->set_vpd(12000.0);              
			pinholePtr->compute_uvw();     
			set_camera(pinholePtr); 
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);
			light_ptr->scale_radiance(1.5);
			add_light(light_ptr);
	
	
			// sphere
	
			Checker3D* checker_pt1 = new Checker3D;
			checker_pt1->set_size(1.0);
			checker_pt1->set_color1(black);
			checker_pt1->set_color2(white);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.75);
			sv_matte_ptr1->set_kd(0.75);
			sv_matte_ptr1->set_cd(checker_pt1);
	
			Sphere* sphere_ptr = new Sphere(Point3D(-9.5, -1, 0), 2.5);
			sphere_ptr->set_material(sv_matte_ptr1);
			add_object(sphere_ptr);
	
	
			// cylinder
	
			Checker3D* checker_ptr2 = new Checker3D;
			checker_ptr2->set_size(1.0);
			checker_ptr2->set_color1(black);
			checker_ptr2->set_color2(white);
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.75);
			sv_matte_ptr2->set_kd(0.75);
			sv_matte_ptr2->set_cd(checker_ptr2);

			Instance* cylinder_ptr = new Instance(new SolidCylinder(-2.5, 4.0, 1.95)); 
			cylinder_ptr->translate(-3.5, 0, 0);
			cylinder_ptr->transform_texture(false);
			cylinder_ptr->set_material(sv_matte_ptr2);
			add_object(cylinder_ptr);


			// cone
	
			Checker3D* checker_ptr3 = new Checker3D;
			checker_ptr3->set_size(1.0);
			checker_ptr3->set_color1(black);
			checker_ptr3->set_color2(white);
	
			SV_Matte* sv_matte_ptr3 = new SV_Matte;		
			sv_matte_ptr3->set_ka(0.75);
			sv_matte_ptr3->set_kd(0.75);
			sv_matte_ptr3->set_cd(checker_ptr3);
	
			Instance* cone_ptr = new Instance(new OpenCone);
			cone_ptr->scale(2.5);  
			cone_ptr->translate(2.35, -1.5, 0);
			cone_ptr->transform_texture(false);
			cone_ptr->set_material(sv_matte_ptr3);
			add_object(cone_ptr);
	
	
			// box
	
			Checker3D* checker_ptr4 = new Checker3D;
			checker_ptr4->set_size(1.0);
			checker_ptr4->set_color1(black);
			checker_ptr4->set_color2(white);
	
			SV_Matte* sv_matte_ptr4 = new SV_Matte;		
			sv_matte_ptr4->set_ka(0.75);
			sv_matte_ptr4->set_kd(0.75);
			sv_matte_ptr4->set_cd(checker_ptr4);

			Box* box_ptr = new Box(Point3D(7, -1.0, -2), Point3D(11, 3, 2));
			box_ptr->set_material(sv_matte_ptr4);
			add_object(box_ptr);
	
	
			// ground plane
	
			Checker3D* checker_ptr5 = new Checker3D;
			checker_ptr5->set_size(1.5);
			checker_ptr5->set_color1(0.35);
			checker_ptr5->set_color2(0.5);
		
			SV_Matte* sv_matte_ptr5 = new SV_Matte;		
			sv_matte_ptr5->set_ka(0.75);
			sv_matte_ptr5->set_kd(0.75);
			sv_matte_ptr5->set_cd(checker_ptr5);

			Plane* plane_ptr = new Plane(Point3D(0, -4.5, 0), Normal(0, 1, 0));
			plane_ptr->set_material(sv_matte_ptr5);
			add_object(plane_ptr);
			break;
		}
	case 378:
		{
			//30.04
			int num_samples = 16;
	
			vp.set_hres(880);
			vp.set_vres(300);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = RGBColor(0.5);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(100, 100, 300); 
			pinhole_ptr->set_lookat(-0.2, 1.0, 0);  
			pinhole_ptr->set_view_distance(12000.0);              
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(0, 0, 1);
			light_ptr1->scale_radiance(1.5);
			add_light(light_ptr1);
	
			// sphere
	
			SphereChecker* sphere_checker_ptr = new SphereChecker;
			sphere_checker_ptr->set_num_horizontal_checkers(16);
			sphere_checker_ptr->set_num_vertical_checkers(8);
			sphere_checker_ptr->set_horizontal_line_width(0.0);
			sphere_checker_ptr->set_vertical_line_width(0.0);
			sphere_checker_ptr->set_color1(white);
			sphere_checker_ptr->set_color2(black);
			sphere_checker_ptr->set_line_color(red);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.75);
			sv_matte_ptr1->set_kd(0.75);
			sv_matte_ptr1->set_cd(sphere_checker_ptr);
	
			Instance* sphere_ptr = new Instance(new Sphere);
			sphere_ptr->set_material(sv_matte_ptr1);
			sphere_ptr->scale(2.5);
			sphere_ptr->translate(-9.5, -1, 0);
			add_object(sphere_ptr);

	
			// cylinder
	
			// This must be built out of separate parts so that we can have different textures 
			// on the top, bottom, and curved surfaces
	
			// material for the curved surface
		
			CylinderChecker* cylinder_checker_ptr = new CylinderChecker;
			cylinder_checker_ptr->set_num_horizontal_checkers(12);
			cylinder_checker_ptr->set_num_vertical_checkers(6);
			cylinder_checker_ptr->set_horizontal_line_width(0.0);
			cylinder_checker_ptr->set_vertical_line_width(0.0);
			cylinder_checker_ptr->set_color1(white);
			cylinder_checker_ptr->set_color2(black);
			cylinder_checker_ptr->set_line_color(red);
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.75);
			sv_matte_ptr2->set_kd(0.75);
			sv_matte_ptr2->set_cd(cylinder_checker_ptr);
	
			OpenCylinder* curved_surface_ptr = new OpenCylinder;
			curved_surface_ptr->set_material(sv_matte_ptr2);
	
	
			// material for the top surface
	
			DiskChecker* disk_checker_ptr = new DiskChecker;
			disk_checker_ptr->set_num_angular_checkers(12);     
			disk_checker_ptr->set_num_radial_checkers(3);
			disk_checker_ptr->set_angular_line_width(0.0);
			disk_checker_ptr->set_radial_line_width(0.0);
			disk_checker_ptr->set_color1(white);
			disk_checker_ptr->set_color2(black);
			disk_checker_ptr->set_line_color(green);
	
			SV_Matte* sv_matte_ptr5 = new SV_Matte;		
			sv_matte_ptr5->set_ka(0.75);
			sv_matte_ptr5->set_kd(0.75);
			sv_matte_ptr5->set_cd(disk_checker_ptr);
	
			Instance* top_ptr = new Instance(new Disk);
			top_ptr->set_material(sv_matte_ptr5);
			top_ptr->translate(0, 1, 0);
	
			// I haven't included the bottom of the cylinder
	
			Compound* generic_cylinder_ptr = new Compound;
			generic_cylinder_ptr->add_object(curved_surface_ptr);
			generic_cylinder_ptr->add_object(top_ptr);	

			Instance* cylinder_ptr = new Instance(generic_cylinder_ptr);
			cylinder_ptr->scale(1.95, 2.95, 1.95); 
			cylinder_ptr->translate(-3.5, 0.5, 0);   
			add_object(cylinder_ptr);
	

			// cone
	
			ConeChecker* cone_checker_ptr = new ConeChecker;
			cone_checker_ptr->set_num_horizontal_checkers(12);
			cone_checker_ptr->set_num_vertical_checkers(8);
			cone_checker_ptr->set_horizontal_line_width(0.0);
			cone_checker_ptr->set_vertical_line_width(0.0);
			cone_checker_ptr->set_color1(white);
			cone_checker_ptr->set_color2(black);
			cone_checker_ptr->set_line_color(red);
		
			SV_Matte* sv_matte_ptr3 = new SV_Matte;		
			sv_matte_ptr3->set_ka(0.75);
			sv_matte_ptr3->set_kd(0.75);
			sv_matte_ptr3->set_cd(cone_checker_ptr);
	
			// I haven't included the bottom of the cone
	
			Instance* cone_ptr = new Instance(new OpenCone);
			cone_ptr->set_material(sv_matte_ptr3);
			cone_ptr->scale(2.5);
			cone_ptr->translate(2.35, -1.5, 0);
			add_object(cone_ptr);

	
			// box
	
			// This has to have a separate Rectangle object for each face.
			// A default rectangle is (x, z) in the set [-1, 1] X [-1, 1], y = 0.
	
			// We need separate checker textures on each face to make the colors and the
			// line thicknesses match up
	
	
			// front (+ve z) face
	
			RectangleChecker* rectangle_checker_ptr1 = new RectangleChecker;
			rectangle_checker_ptr1->set_num_x_checkers(4);
			rectangle_checker_ptr1->set_num_z_checkers(4);
			rectangle_checker_ptr1->set_x_line_width(0.0);
			rectangle_checker_ptr1->set_z_line_width(0.0);
			rectangle_checker_ptr1->set_color1(white);
			rectangle_checker_ptr1->set_color2(black);
			rectangle_checker_ptr1->set_line_color(red);
		
			SV_Matte* sv_matte_ptr4 = new SV_Matte;		
			sv_matte_ptr4->set_ka(0.75);
			sv_matte_ptr4->set_kd(0.75);
			sv_matte_ptr4->set_cd(rectangle_checker_ptr1);
		
			Instance* front_face_ptr = new Instance(new TRectangle);
			front_face_ptr->set_material(sv_matte_ptr4);
			front_face_ptr->rotate_x(90);
			front_face_ptr->translate(0, 0, 1);
	
	
			// top (+ve y) face
		
			RectangleChecker* rectangle_checker_ptr2 = new RectangleChecker;
			rectangle_checker_ptr2->set_num_x_checkers(4);
			rectangle_checker_ptr2->set_num_z_checkers(4);
			rectangle_checker_ptr2->set_x_line_width(0.0);
			rectangle_checker_ptr2->set_z_line_width(0.0);
			rectangle_checker_ptr2->set_color1(black);
			rectangle_checker_ptr2->set_color2(white);
			rectangle_checker_ptr2->set_line_color(green);
		
			SV_Matte* sv_matte_ptr6 = new SV_Matte;		
			sv_matte_ptr6->set_ka(0.75);
			sv_matte_ptr6->set_kd(0.75);
			sv_matte_ptr6->set_cd(rectangle_checker_ptr2);
		
			Instance* top_face_ptr = new Instance(new TRectangle);
			top_face_ptr->set_material(sv_matte_ptr6);
			top_face_ptr->translate(0, 1, 0);
	
	
			// right (+ve x) face
	
			RectangleChecker* rectangle_checker_ptr3 = new RectangleChecker;
			rectangle_checker_ptr3->set_num_x_checkers(4);
			rectangle_checker_ptr3->set_num_z_checkers(4);
			rectangle_checker_ptr3->set_x_line_width(0.0);
			rectangle_checker_ptr3->set_z_line_width(0.0);
			rectangle_checker_ptr3->set_color1(white);
			rectangle_checker_ptr3->set_color2(black);
			rectangle_checker_ptr3->set_line_color(blue);
		
			SV_Matte* sv_matte_ptr7 = new SV_Matte;		
			sv_matte_ptr7->set_ka(0.75);
			sv_matte_ptr7->set_kd(0.75);
			sv_matte_ptr7->set_cd(rectangle_checker_ptr3);
	
			Instance* right_face_ptr = new Instance(new TRectangle);
			right_face_ptr->set_material(sv_matte_ptr7);
			right_face_ptr->rotate_z(-90);
			right_face_ptr->translate(1, 0, 0);
	
	
			// you can construct the left, back, and bottom faces in a similar way
	
			Compound* generic_box_ptr = new Compound;
			generic_box_ptr->add_object(front_face_ptr);
			generic_box_ptr->add_object(top_face_ptr);
			generic_box_ptr->add_object(right_face_ptr);	
	
			Instance* box_ptr = new Instance(generic_box_ptr);
			box_ptr->scale(2.0); 
			box_ptr->translate(9, 1, 0);  
			add_object(box_ptr);
	
	
	
			// ground plane
		
			PlaneChecker* plane_checker_ptr = new PlaneChecker;
			plane_checker_ptr->set_size(1.5); 
			plane_checker_ptr->set_outline_width(0.0);
			plane_checker_ptr->set_color1(0.35);
			plane_checker_ptr->set_color2(0.5);

			plane_checker_ptr->set_outline_color(yellow);
		
			SV_Matte* sv_matte_ptr8 = new SV_Matte;		
			sv_matte_ptr8->set_ka(0.75);
			sv_matte_ptr8->set_kd(0.75);
			sv_matte_ptr8->set_cd(plane_checker_ptr);
	
			Instance* plane_ptr = new Instance(new Plane); // a generic plane is the (x, z) plane
			plane_ptr->set_material(sv_matte_ptr8);
			plane_ptr->translate(0, -4.5, 0);  
			add_object(plane_ptr);
			break;
		}
	case 379:
		{
			//30.06a
			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = RGBColor(black);
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);    
			set_ambient_light(ambient_ptr);
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);         
			pinhole_ptr->set_lookat(0.0); 
			pinhole_ptr->set_view_distance(30000.0);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
		
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);  
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
	
			// wrapped noise texture
	
			// noise
	
			CubicNoise* noise_ptr = new CubicNoise;
			noise_ptr->set_num_octaves(6);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);
	
			// texture
	
			WrappedFBmTexture* wrapped_texture_ptr = new WrappedFBmTexture(noise_ptr);	
			wrapped_texture_ptr->set_color(1.0, 0.85, 0.0);   // yellow
			wrapped_texture_ptr->set_expansion_number(10.0);
	
			float s = 0.5;      // uniform scaling factor
			float xs = 7.5;		// non-uniform scaling factor in x direction
			TInstance* scaled_texture_ptr = new TInstance(wrapped_texture_ptr);
			scaled_texture_ptr->scale(s);				// for Figure 30.6(a)
		//	scaled_texture_ptr->scale(s * xs, s, s);	// for Figure 30.6(b)
	
			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(scaled_texture_ptr);
	
	
			// box parameters
	
			Point3D p0(-1.0);
			Point3D p1(1.0);
	
			Box* box_ptr = new Box(p0, p1); 
			box_ptr->set_material(sv_matte_ptr);
			add_object(box_ptr);	
			break;
		}
	case 380:
		{
			//30.06b
			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = RGBColor(black);
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);    
			set_ambient_light(ambient_ptr);
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);         
			pinhole_ptr->set_lookat(0.0); 
			pinhole_ptr->set_view_distance(30000.0);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
		
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);  
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
	
			// wrapped noise texture
	
			// noise
	
			CubicNoise* noise_ptr = new CubicNoise;
			noise_ptr->set_num_octaves(6);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);
	
			// texture
	
			WrappedFBmTexture* wrapped_texture_ptr = new WrappedFBmTexture(noise_ptr);	
			wrapped_texture_ptr->set_color(1.0, 0.85, 0.0);   // yellow
			wrapped_texture_ptr->set_expansion_number(10.0);
	
			float s = 0.5;      // uniform scaling factor
			float xs = 7.5;		// non-uniform scaling factor in x direction
			TInstance* scaled_texture_ptr = new TInstance(wrapped_texture_ptr);
		//	scaled_texture_ptr->scale(s);				// for Figure 30.6(a)
			scaled_texture_ptr->scale(s * xs, s, s);	// for Figure 30.6(b)
	
			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(scaled_texture_ptr);
	
	
			// box parameters
	
			Point3D p0(-1.0);
			Point3D p1(1.0);
	
			Box* box_ptr = new Box(p0, p1); 
			box_ptr->set_material(sv_matte_ptr);
			add_object(box_ptr);	
			break;
		}
	case 381:
		{
			//30.06c
			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = RGBColor(black);
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);    
			set_ambient_light(ambient_ptr);
	

			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);         
			pinhole_ptr->set_lookat(0.0); 
			pinhole_ptr->set_view_distance(30000.0); 
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
		
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);  
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
	
			// turbulence texture
	
			// noise
	
			CubicNoise* noise_ptr = new CubicNoise;
			noise_ptr->set_num_octaves(1);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);
	
			// texture
	
			TurbulenceTexture* turbulence_texture_ptr = new TurbulenceTexture(noise_ptr);			
			turbulence_texture_ptr->set_color(1.0, 0.5, 0.0);  // orange 
			turbulence_texture_ptr->set_min_value(0.0);  
			turbulence_texture_ptr->set_max_value(1.2);
	
			float s = 0.05;      	// uniform scaling factor
			float xs = 10.0;		// non-uniform scaling factor in x direction
			TInstance* scaled_texture_ptr = new TInstance(turbulence_texture_ptr);
			scaled_texture_ptr->scale(s);				// for Figure 30.6(c)
		//	scaled_texture_ptr->scale(s * xs, s, s);	// for Figure 30.6(b)
	
			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(scaled_texture_ptr);
	
	
			// box parameters
	
			Point3D p0(-1.0);
			Point3D p1(1.0);
	
			Box* box_ptr = new Box(p0, p1); 
			box_ptr->set_material(sv_matte_ptr);
			add_object(box_ptr);	
			break;
		}
	case 382:
		{
			//30.06d
			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = RGBColor(black);
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);    
			set_ambient_light(ambient_ptr);
	

			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);         
			pinhole_ptr->set_lookat(0.0); 
			pinhole_ptr->set_view_distance(30000.0); 
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
		
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);  
			light_ptr->scale_radiance(3.0);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
	
			// turbulence texture
	
			// noise
	
			CubicNoise* noise_ptr = new CubicNoise;
			noise_ptr->set_num_octaves(1);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);
	
			// texture
	
			TurbulenceTexture* turbulence_texture_ptr = new TurbulenceTexture(noise_ptr);			
			turbulence_texture_ptr->set_color(1.0, 0.5, 0.0);  // orange 
			turbulence_texture_ptr->set_min_value(0.0);  
			turbulence_texture_ptr->set_max_value(1.2);
	
			float s = 0.05;      	// uniform scaling factor
			float xs = 10.0;		// non-uniform scaling factor in x direction
			TInstance* scaled_texture_ptr = new TInstance(turbulence_texture_ptr);
		//	scaled_texture_ptr->scale(s);				// for Figure 30.6(c)
			scaled_texture_ptr->scale(s * xs, s, s);	// for Figure 30.6(b)
	
			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(scaled_texture_ptr);
	
	
			// box parameters
	
			Point3D p0(-1.0);
			Point3D p1(1.0);
	
			Box* box_ptr = new Box(p0, p1); 
			box_ptr->set_material(sv_matte_ptr);
			add_object(box_ptr);	
			break;
		}
	case 383:
		{
			//30.07
			int num_samples = 16;
	
			vp.set_hres(904);
			vp.set_vres(300);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = RGBColor(0.75);
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);    
			set_ambient_light(ambient_ptr);

			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 200);         
			pinhole_ptr->set_lookat(0.0); 
			pinhole_ptr->set_view_distance(9600.0);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(50, 100, 100);  
			light_ptr->scale_radiance(4.0);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
	
			// the spheres
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(1.0);
			checker_ptr->set_color1(black);
			checker_ptr->set_color2(white);
	
			TInstance* translated_checker_ptr = new TInstance(checker_ptr);
			translated_checker_ptr->translate(0.5, 0.5, 0.0);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.75);
			sv_matte_ptr->set_cd(translated_checker_ptr);
	
			double radius;
	
	
			// sphere 1	
	
			radius = 3.0;
			Instance* sphere_ptr1 = new Instance(new Sphere(Point3D(0.0), radius));
			sphere_ptr1->set_material(sv_matte_ptr);
			sphere_ptr1->translate(-6.25, 0.0, 0.0);
			add_object(sphere_ptr1);
	
	
			// sphere 2
	
			radius = 2.25;	
			Instance* sphere_ptr2 = new Instance(new Sphere(Point3D(0.0), radius));
			sphere_ptr2->set_material(sv_matte_ptr);
			sphere_ptr2->translate(-1.0, 0.0, 0.0);
			add_object(sphere_ptr2);
	
	
			// sphere 3
	
			radius = 1.75;	
			Instance* sphere_ptr3 = new Instance(new Sphere(Point3D(0.0), radius));
			sphere_ptr3->set_material(sv_matte_ptr);
			sphere_ptr3->translate(3.0, 0.0, 0.0);
			add_object(sphere_ptr3);
	
	
			// sphere 4
	
			radius = 1.0;	
			Instance* sphere_ptr4 = new Instance(new Sphere(Point3D(0.0), radius));
			sphere_ptr4->set_material(sv_matte_ptr);
			sphere_ptr4->translate(5.75, 0.0, 0.0);
			add_object(sphere_ptr4);
	
	
			// sphere 5
	
			radius = 0.75;	
			Instance* sphere_ptr5 = new Instance(new Sphere(Point3D(0.0), radius));
			sphere_ptr5->set_material(sv_matte_ptr);
			sphere_ptr5->translate(7.5, 0.0, 0.0);
			add_object(sphere_ptr5);
	
	
			// sphere 6
	
			radius = 0.5;	
			Instance* sphere_ptr6 = new Instance(new Sphere(Point3D(0.0), radius));
			sphere_ptr6->set_material(sv_matte_ptr);
			sphere_ptr6->translate(8.75, 0.0, 0.0);
			add_object(sphere_ptr6);
			break;
		}
	case 384:
		{
			//30.08
			int num_samples = 16;
	
			vp.set_hres(904);
			vp.set_vres(300);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = RGBColor(0.75);
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);    
			set_ambient_light(ambient_ptr);
	

			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 200);         
			pinhole_ptr->set_lookat(0.0); 
			pinhole_ptr->set_view_distance(9600.0);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
	
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(50, 100, 100);  
			light_ptr->scale_radiance(4.0);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
	
			// the spheres
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(1.0);
			checker_ptr->set_color1(black);
			checker_ptr->set_color2(white);
	
	
			double radius;	
	
			// sphere 1
	
			TInstance* transformed_checker_ptr1 = new TInstance(checker_ptr);
			transformed_checker_ptr1->translate(0.5, 0.5, 0.0);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.5);
			sv_matte_ptr1->set_kd(0.75);
			sv_matte_ptr1->set_cd(transformed_checker_ptr1);	
	
			radius = 3.0;
			Instance* sphere_ptr1 = new Instance(new Sphere(Point3D(0.0), radius));
			sphere_ptr1->set_material(sv_matte_ptr1);
			sphere_ptr1->translate(-6.25, 0.0, 0.0);
			add_object(sphere_ptr1);
	
	
			// sphere 2
	
			TInstance* transformed_checker_ptr2 = new TInstance(checker_ptr);
			transformed_checker_ptr2->scale(0.75);
			transformed_checker_ptr2->translate(0.375, 0.375, 0.0);
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.5);
			sv_matte_ptr2->set_kd(0.75);
			sv_matte_ptr2->set_cd(transformed_checker_ptr2);	
	
			radius = 2.25;	
			Instance* sphere_ptr2 = new Instance(new Sphere(Point3D(0.0), radius));
			sphere_ptr2->set_material(sv_matte_ptr2);
			sphere_ptr2->translate(-1.0, 0.0, 0.0);
			add_object(sphere_ptr2);
	
	
			// sphere 3
	
			TInstance* transformed_checker_ptr3 = new TInstance(checker_ptr);
			transformed_checker_ptr3->scale(0.5833333);
			transformed_checker_ptr3->translate(0.29166, 0.29166, 0.0);
	
			SV_Matte* sv_matte_ptr3 = new SV_Matte;		
			sv_matte_ptr3->set_ka(0.5);
			sv_matte_ptr3->set_kd(0.75);
			sv_matte_ptr3->set_cd(transformed_checker_ptr3);	
	
			radius = 1.75;	
			Instance* sphere_ptr3 = new Instance(new Sphere(Point3D(0.0), radius));
			sphere_ptr3->set_material(sv_matte_ptr3);
			sphere_ptr3->translate(3.0, 0.0, 0.0);
			add_object(sphere_ptr3);
	
	
			// sphere 4
	
			TInstance* transformed_checker_ptr4 = new TInstance(checker_ptr);
			transformed_checker_ptr4->scale(0.3333333);
			transformed_checker_ptr4->translate(0.166666, 0.166666, 0.0);
	
			SV_Matte* sv_matte_ptr4 = new SV_Matte;		
			sv_matte_ptr4->set_ka(0.5);
			sv_matte_ptr4->set_kd(0.75);
			sv_matte_ptr4->set_cd(transformed_checker_ptr4);	
	
			radius = 1.0;	
			Instance* sphere_ptr4 = new Instance(new Sphere(Point3D(0.0), radius));
			sphere_ptr4->set_material(sv_matte_ptr4);
			sphere_ptr4->translate(5.75, 0.0, 0.0);
			add_object(sphere_ptr4);
	
	
			// sphere 5
	
			TInstance* transformed_checker_ptr5 = new TInstance(checker_ptr);
			transformed_checker_ptr5->scale(0.25);
			transformed_checker_ptr5->translate(0.125, 0.125, 0.0);
	
			SV_Matte* sv_matte_ptr5 = new SV_Matte;		
			sv_matte_ptr5->set_ka(0.5);
			sv_matte_ptr5->set_kd(0.75);
			sv_matte_ptr5->set_cd(transformed_checker_ptr5);
	
			radius = 0.75;	
			Instance* sphere_ptr5 = new Instance(new Sphere(Point3D(0.0), radius));
			sphere_ptr5->set_material(sv_matte_ptr5);
			sphere_ptr5->translate(7.5, 0.0, 0.0);
			add_object(sphere_ptr5);
	
	
			// sphere 6
	
			TInstance* transformed_checker_ptr6 = new TInstance(checker_ptr);
			transformed_checker_ptr6->scale(0.166666);
			transformed_checker_ptr6->translate(0.083333, 0.083333, 0.0);
	
			SV_Matte* sv_matte_ptr6 = new SV_Matte;		
			sv_matte_ptr6->set_ka(0.5);
			sv_matte_ptr6->set_kd(0.75);
			sv_matte_ptr6->set_cd(transformed_checker_ptr6);
	
			radius = 0.5;	
			Instance* sphere_ptr6 = new Instance(new Sphere(Point3D(0.0), radius));
			sphere_ptr6->set_material(sv_matte_ptr6);
			sphere_ptr6->translate(8.75, 0.0, 0.0);
			add_object(sphere_ptr6);
			break;
		}
	case 385:
		{
			//30.11a
			int num_samples = 16;
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = RGBColor(0.5);	
	
			Pinhole* pinhole_ptr = new Pinhole;		
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);	
			pinhole_ptr->set_view_distance(7500.0);  
			pinhole_ptr->compute_uvw();  
			set_camera(pinhole_ptr);	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1); 
			light_ptr->scale_radiance(3.0);
			add_light(light_ptr);
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(0.3);
			checker_ptr->set_color1(white);
			checker_ptr->set_color2(black);
	 
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.8);  
			sv_matte_ptr->set_kd(0.4);
			sv_matte_ptr->set_cd(checker_ptr);
	
			Box* box_ptr = new Box(Point3D(-1.0), Point3D(1.0));
			box_ptr->set_material(sv_matte_ptr);
			add_object(box_ptr);
			break;
		}
	case 386:
		{
			//30.11b
			int num_samples = 16;
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = RGBColor(0.5);	
	
			Pinhole* pinhole_ptr = new Pinhole;		
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);	
			pinhole_ptr->set_view_distance(7500.0);  
			pinhole_ptr->compute_uvw();  
			set_camera(pinhole_ptr);	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1); 
			light_ptr->scale_radiance(3.0);
			add_light(light_ptr);
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(0.3);
			checker_ptr->set_color1(white);
			checker_ptr->set_color2(black);
		
			TInstance* scaled_checker_ptr = new TInstance(checker_ptr);
			scaled_checker_ptr->scale(2, 1, 1);
	 
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.8);  
			sv_matte_ptr->set_kd(0.4);
			sv_matte_ptr->set_cd(scaled_checker_ptr);
	
			Box* box_ptr = new Box(Point3D(-1.0), Point3D(1.0));
			box_ptr->set_material(sv_matte_ptr);
			add_object(box_ptr);
			break;
		}
	case 387:
		{
			//30.11c
			int num_samples = 16;
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = RGBColor(0.5);	
	
			Pinhole* pinhole_ptr = new Pinhole;		
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);	
			pinhole_ptr->set_view_distance(7500.0);  
			pinhole_ptr->compute_uvw();  
			set_camera(pinhole_ptr);	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1); 
			light_ptr->scale_radiance(3.0);
			add_light(light_ptr);
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(0.3);
			checker_ptr->set_color1(white);
			checker_ptr->set_color2(black);
		
			TInstance* scaled_checker_ptr = new TInstance(checker_ptr);
			scaled_checker_ptr->scale(2, 1, 1);
	 
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.8);  
			sv_matte_ptr->set_kd(0.4);
			sv_matte_ptr->set_cd(scaled_checker_ptr);
	
			Box* box_ptr = new Box(Point3D(-1.0), Point3D(1.0));
			box_ptr->set_material(sv_matte_ptr);

			Instance* transformed_box_ptr = new Instance(box_ptr);
			transformed_box_ptr->scale(2, 1, 1);
			add_object(transformed_box_ptr);
			break;
		}
	case 388:
		{
			//30.11d
			int num_samples = 16;
	
			vp.set_hres(400);	  		
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = RGBColor(0.5);	
	
			Pinhole* pinhole_ptr = new Pinhole;		
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);	
			pinhole_ptr->set_view_distance(7500.0);  
			pinhole_ptr->compute_uvw();  
			set_camera(pinhole_ptr);	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1); 
			light_ptr->scale_radiance(3.0);
			add_light(light_ptr);
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(0.3);
			checker_ptr->set_color1(white);
			checker_ptr->set_color2(black);
		
			TInstance* scaled_checker_ptr = new TInstance(checker_ptr);
			scaled_checker_ptr->scale(2, 1, 1);
	 
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.8);  
			sv_matte_ptr->set_kd(0.4);
			sv_matte_ptr->set_cd(scaled_checker_ptr);
	
			Box* box_ptr = new Box(Point3D(-1.0), Point3D(1.0));
			box_ptr->set_material(sv_matte_ptr);

			Instance* transformed_box_ptr = new Instance(box_ptr);
			transformed_box_ptr->scale(2, 1, 1);
			transformed_box_ptr->rotate_z(45);
			add_object(transformed_box_ptr);
			break;
		}
	case 389:
		{
			//30.12
			int num_samples = 16;
	
			vp.set_hres(904);	  		
			vp.set_vres(300);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = RGBColor(0.5);	
	
			Pinhole* pinhole_ptr = new Pinhole;		
			pinhole_ptr->set_eye(0, 125, 200);
			pinhole_ptr->set_lookat(0.0);	
			pinhole_ptr->set_view_distance(4400.0);  
			pinhole_ptr->compute_uvw();  
			set_camera(pinhole_ptr);	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(1, 1, 0.5); 
			light_ptr->scale_radiance(4.5);
			add_light(light_ptr);
	
	
			// middle cylinder (generic)
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(1.02); 
			checker_ptr->set_color1(black);
			checker_ptr->set_color2(white);
	 
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.4);  
			sv_matte_ptr->set_kd(0.6);
			sv_matte_ptr->set_cd(checker_ptr);
	
			SolidCylinder* cylinder_ptr1 = new SolidCylinder;
			cylinder_ptr1->set_material(sv_matte_ptr);
			add_object(cylinder_ptr1);
	
	
			// right cylinder (cylinder and checkers are transformed)
	
			Instance* transformed_cylinder_ptr1 = new Instance(new SolidCylinder);
			transformed_cylinder_ptr1->set_material(sv_matte_ptr);
			transformed_cylinder_ptr1->scale(10.0, 0.5, 10.0);
			transformed_cylinder_ptr1->translate(13, 0, 0);
			add_object(transformed_cylinder_ptr1);
	
	
			// left cylinder (only the cylinder is transformed)
	
			Instance* transformed_cylinder_ptr2 = new Instance(new SolidCylinder);
			transformed_cylinder_ptr2->set_material(sv_matte_ptr);
			transformed_cylinder_ptr2->scale(10.0, 0.5, 10.0);
			transformed_cylinder_ptr2->translate(-13, 0, 0);
			transformed_cylinder_ptr2->transform_texture(false);
			add_object(transformed_cylinder_ptr2);
			break;
		}
	case 390:
		{
			//30.13
			if( !CheckFile(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);	  		
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);	
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(20, 10, 40);
			pinhole_ptr->set_lookat(0, 1, 0);  
			pinhole_ptr->set_view_distance(9000.0); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
	
			Directional* light_ptr1 = new Directional;
			light_ptr1->set_direction(30, 40, 20);
			light_ptr1->scale_radiance(2.5);     
			light_ptr1->set_shadows(true);
			add_light(light_ptr1);


			// marble ramp image

			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data());

			// marble parameters
	
			int 	num_octaves = 6;
			float 	fbm_amount 	= 6.0;	
			RampFBmTexture* ramp_marble_ptr = new RampFBmTexture(image_ptr, num_octaves, fbm_amount);		
			
			
			// transformed marble texture
	
			// These intrinsic texture transformations are only to make the marble look "good"
			// on the cylinder.	
			// They are unrelated to the translation in the y direction that's applied to the 
			// marble on the top and bottom cylinder bevels in Figure 30.13(a).	

			TInstance* marble_ptr = new TInstance;
			marble_ptr->set_texture(ramp_marble_ptr);
			marble_ptr->scale(0.4);  
			marble_ptr->rotate_x(270);
			marble_ptr->rotate_y(30);
			marble_ptr->rotate_z(30);
	
		
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.35);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(marble_ptr);
	
	
			// cylinder parameters
	
			double bottom 		= 0.0;
			double top 			= 2.0;
			double radius 		= 1.0;
			double bevel_radius = 0.5;
	
			BeveledCylinder* cylinder_ptr = new BeveledCylinder(bottom, top, radius, bevel_radius);
			cylinder_ptr->set_material(sv_matte_ptr);
			add_object(cylinder_ptr);	
	
	
			
			// ground plane
	
			Matte* matte_ptr1 = new Matte;		
			matte_ptr1->set_ka(0.3);
			matte_ptr1->set_kd(0.85);
			matte_ptr1->set_cd(0.75);
	
			Plane* plane_ptr1 = new Plane(Point3D(0, 0.01, 1), Normal(0, 1, 0)); 
			plane_ptr1->set_material(matte_ptr1);
			add_object(plane_ptr1);	
		
	
			// plane perpendicular to x axis
	
			Matte* matte_ptr2 = new Matte;			
			matte_ptr2->set_ka(0.25);		
			matte_ptr2->set_kd(0.75);
			matte_ptr2->set_cd(0.75);
	
			Plane* plane_ptr2 = new Plane(Point3D(-1.5, 0, 0), Normal(1, 0, 0)); 
			plane_ptr2->set_material(matte_ptr2);
			add_object(plane_ptr2);

	
			// plane perpendicular to z axis
	
			Matte* matte_ptr3 = new Matte;			
			matte_ptr3->set_cd(0.6);
			matte_ptr3->set_ka(0.25);		
			matte_ptr3->set_kd(0.5);
	
			Plane* plane_ptr3 = new Plane(Point3D(0, 0, -1.5), Normal(0, 0, 1)); 
			plane_ptr3->set_material(matte_ptr3);
			add_object(plane_ptr3);
			break;
		}
	case 391:
		{
			//30.14a
			int num_samples = 16;

			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.5);
			tracer_ptr = new RayCast(this);	
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(12, 15, 30);
			pinhole_ptr->set_lookat(0, 0, 0); 
			pinhole_ptr->set_view_distance(3500.0); 	  
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
			
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(10, 10, 20);
			light_ptr->scale_radiance(3.5);
			add_light(light_ptr);
	
			Checker3D* checker_ptr = new Checker3D;
			checker_ptr->set_size(0.6708);	// For Figure 30.14(a)
		//	checker_ptr->set_size(0.416);	// For Figure 30.14(b)
		//	checker_ptr->set_size(0.3);		// For Figure 30.14(c)
			checker_ptr->set_color1(white);  	 
			checker_ptr->set_color2(black);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.6);
			sv_matte_ptr->set_cd(checker_ptr);
		
			double bottom 	= -0.9;
			double top 		= 0.9;
			double radius 	= 1.5;

			OpenCylinder* cylinder_ptr = new OpenCylinder(bottom, top, radius);
			cylinder_ptr->set_material(sv_matte_ptr);
			add_object(cylinder_ptr);
			break;
		}
	case 392:
		{
			//30.14b
			int num_samples = 16;

			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.5);
			tracer_ptr = new RayCast(this);	
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(12, 15, 30);
			pinhole_ptr->set_lookat(0, 0, 0); 
			pinhole_ptr->set_view_distance(3500.0); 	  
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
			
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(10, 10, 20);
			light_ptr->scale_radiance(3.5);
			add_light(light_ptr);
	
			Checker3D* checker_ptr = new Checker3D;
		//	checker_ptr->set_size(0.6708);	// For Figure 30.14(a)
			checker_ptr->set_size(0.416);	// For Figure 30.14(b)
		//	checker_ptr->set_size(0.3);		// For Figure 30.14(c)
			checker_ptr->set_color1(white);  	 
			checker_ptr->set_color2(black);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.6);
			sv_matte_ptr->set_cd(checker_ptr);
		
			double bottom 	= -0.9;
			double top 		= 0.9;
			double radius 	= 1.5;

			OpenCylinder* cylinder_ptr = new OpenCylinder(bottom, top, radius);
			cylinder_ptr->set_material(sv_matte_ptr);
			add_object(cylinder_ptr);
			break;
		}
	case 393:
		{
			//30.14c
			int num_samples = 16;

			vp.set_hres(400);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.5);
			tracer_ptr = new RayCast(this);	
			
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(12, 15, 30);
			pinhole_ptr->set_lookat(0, 0, 0); 
			pinhole_ptr->set_view_distance(3500.0); 	  
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
			
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(10, 10, 20);
			light_ptr->scale_radiance(3.5);
			add_light(light_ptr);
	
			Checker3D* checker_ptr = new Checker3D;
		//	checker_ptr->set_size(0.6708);	// For Figure 30.14(a)
		//	checker_ptr->set_size(0.416);	// For Figure 30.14(b)
			checker_ptr->set_size(0.3);		// For Figure 30.14(c)
			checker_ptr->set_color1(white);  	 
			checker_ptr->set_color2(black);
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.6);
			sv_matte_ptr->set_cd(checker_ptr);
		
			double bottom 	= -0.9;
			double top 		= 0.9;
			double radius 	= 1.5;

			OpenCylinder* cylinder_ptr = new OpenCylinder(bottom, top, radius);
			cylinder_ptr->set_material(sv_matte_ptr);
			add_object(cylinder_ptr);
			break;
		}
	case 394:
		{
			//30.16
			if( !CheckFile(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data()))
				return;

			int num_samples = 16;

			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = RGBColor(0.5);
		
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(3, 9, 25); 
			pinhole_ptr->set_lookat(0.0);  
			pinhole_ptr->set_view_distance(7000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0.6, 1.1, 1);   
			light_ptr->scale_radiance(3.0);
			add_light(light_ptr);
	
	
			// blue marble ramp image
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data());
	
	
			int 	num_octaves 	= 4;
			float 	lacunarity 		= 2.0;
			float 	gain 			= 0.5;
			float 	perturbation	= 5.0;   // fbm amount
	
			RampFBmTexture* marble_ptr = new RampFBmTexture(image_ptr); 

			marble_ptr->set_num_octaves(num_octaves);
			marble_ptr->set_lacunarity(lacunarity);
			marble_ptr->set_gain(gain);

			marble_ptr->set_perturbation(perturbation);
	
			TInstance* scaled_marble_ptr = new TInstance(marble_ptr);
			scaled_marble_ptr->scale(0.1);
	
	
			// wood

			TInstance* wood_ptr = new TInstance(new Wood(RGBColor(0.5, 0.3, 0.1), black));
			wood_ptr->scale(0.2);
			wood_ptr->rotate_x(45);
	
	
			// texture to hold the marble and wood textures	
			SphereTextures* sphere_textures_ptr = new SphereTextures;
			sphere_textures_ptr->set_num_horizontal_checkers(12); 
			sphere_textures_ptr->set_num_vertical_checkers(6);   
			sphere_textures_ptr->set_texture1(scaled_marble_ptr);
			sphere_textures_ptr->set_texture2(wood_ptr);
	
	
			// spatially varying Phong material	
		
			SV_Phong* sv_phong_ptr = new SV_Phong;		
			sv_phong_ptr->set_ka(0.25);  
			sv_phong_ptr->set_kd(0.75);
			sv_phong_ptr->set_cd(sphere_textures_ptr);
			sv_phong_ptr->set_ks(0.25);  
			sv_phong_ptr->set_exp(20.0);
			sv_phong_ptr->set_cs(new ConstantColor(white));
	
	
			Sphere* sphere_ptr = new Sphere;
			sphere_ptr->set_material(sv_phong_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 395:
		{
			//31.18
			int num_samples = 9;
	
			vp.set_hres(600);     
			vp.set_vres(600);    
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0); 
			pinhole_ptr->set_view_distance(3000.0);         
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;		
			noise_ptr->set_num_octaves(1);
			noise_ptr->set_gain(0.5);			// not relevant for one octave
			noise_ptr->set_lacunarity(2.0);		// not relevant for one octave	
	
			// texture:

			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);
			texture_ptr->set_max_value(1.0);
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Box* box_ptr1 = new Box(Point3D(-10.0), Point3D(10.0)); 
			box_ptr1->set_material(sv_matte_ptr);
			add_object(box_ptr1);	
			break;
		}
	case 396:
		{
			//31.21a
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(1);				// for Figure 31.21(a)
		//	noise_ptr->set_num_octaves(2);				// for Figure 31.21(b)
		//	noise_ptr->set_num_octaves(3);				// for Figure 31.21(c)
		//	noise_ptr->set_num_octaves(8);				// for Figure 31.21(c)
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);		
	
			// texture:

			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 397:
		{
			//31.21b
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
		//	noise_ptr->set_num_octaves(1);				// for Figure 31.21(a)
			noise_ptr->set_num_octaves(2);				// for Figure 31.21(b)
		//	noise_ptr->set_num_octaves(3);				// for Figure 31.21(c)
		//	noise_ptr->set_num_octaves(8);				// for Figure 31.21(c)
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);		
	
			// texture:

			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 398:
		{
			//31.21c
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
		//	noise_ptr->set_num_octaves(1);				// for Figure 31.21(a)
		//	noise_ptr->set_num_octaves(2);				// for Figure 31.21(b)
			noise_ptr->set_num_octaves(3);				// for Figure 31.21(c)
		//	noise_ptr->set_num_octaves(8);				// for Figure 31.21(c)
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);		
	
			// texture:

			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 399:
		{
			//31.21d
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
		//	noise_ptr->set_num_octaves(1);				// for Figure 31.21(a)
		//	noise_ptr->set_num_octaves(2);				// for Figure 31.21(b)
		//	noise_ptr->set_num_octaves(3);				// for Figure 31.21(c)
			noise_ptr->set_num_octaves(8);				// for Figure 31.21(d)
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);		
	
			// texture:

			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 400:
		{
			//31.23a
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(1);				// for Figure 31.23(a)
		//	noise_ptr->set_num_octaves(2);				// for Figure 31.23(b)
		//	noise_ptr->set_num_octaves(3);				// for Figure 31.23(c)
		//	noise_ptr->set_num_octaves(8);				// for Figure 31.23(c)
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);		
	
			// texture:

			TurbulenceTexture* texture_ptr = new TurbulenceTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 401:
		{
			//31.23b
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
		//	noise_ptr->set_num_octaves(1);				// for Figure 31.23(a)
			noise_ptr->set_num_octaves(2);				// for Figure 31.23(b)
		//	noise_ptr->set_num_octaves(3);				// for Figure 31.23(c)
		//	noise_ptr->set_num_octaves(8);				// for Figure 31.23(c)
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);		
	
			// texture:

			TurbulenceTexture* texture_ptr = new TurbulenceTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 402:
		{
			//31.23c
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
		//	noise_ptr->set_num_octaves(1);				// for Figure 31.23(a)
		//	noise_ptr->set_num_octaves(2);				// for Figure 31.23(b)
			noise_ptr->set_num_octaves(3);				// for Figure 31.23(c)
		//	noise_ptr->set_num_octaves(8);				// for Figure 31.23(c)
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);		
	
			// texture:

			TurbulenceTexture* texture_ptr = new TurbulenceTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 403:
		{
			//31.23d
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
		//	noise_ptr->set_num_octaves(1);				// for Figure 31.23(a)
		//	noise_ptr->set_num_octaves(2);				// for Figure 31.23(b)
		//	noise_ptr->set_num_octaves(3);				// for Figure 31.23(c)
			noise_ptr->set_num_octaves(8);				// for Figure 31.23(d)
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);		
	
			// texture:

			TurbulenceTexture* texture_ptr = new TurbulenceTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 404:
		{
			//31.25a
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);		
			noise_ptr->set_gain(0.0);				// for Figure 31.25(a) cubic noise - identical to Figure 31.21(a)
		//	noise_ptr->set_gain(0.25);				// for Figure 31.25(b)
		//	noise_ptr->set_gain(0.5);				// for Figure 31.25(c) fractal sum - similar to Figure 31.21(d)
		//	noise_ptr->set_gain(0.75);				// for Figure 31.25(d)
		//	noise_ptr->set_gain(1.0);				// for Figure 31.25(e)
		//	noise_ptr->set_gain(2.0);				// for Figure 31.25(f) new image - not in book
			noise_ptr->set_lacunarity(2.0);		
	
			// texture:

			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 405:
		{
			//31.25b
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);		
		//	noise_ptr->set_gain(0.0);				// for Figure 31.25(a) cubic noise - identical to Figure 31.21(a)
			noise_ptr->set_gain(0.25);				// for Figure 31.25(b)
		//	noise_ptr->set_gain(0.5);				// for Figure 31.25(c) fractal sum - similar to Figure 31.21(d)
		//	noise_ptr->set_gain(0.75);				// for Figure 31.25(d)
		//	noise_ptr->set_gain(1.0);				// for Figure 31.25(e)
		//	noise_ptr->set_gain(2.0);				// for Figure 31.25(f) new image - not in book
			noise_ptr->set_lacunarity(2.0);		
	
			// texture:

			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 406:
		{
			//31.25c
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);		
		//	noise_ptr->set_gain(0.0);				// for Figure 31.25(a) cubic noise - identical to Figure 31.21(a)
		//	noise_ptr->set_gain(0.25);				// for Figure 31.25(b)
			noise_ptr->set_gain(0.5);				// for Figure 31.25(c) fractal sum - similar to Figure 31.21(d)
		//	noise_ptr->set_gain(0.75);				// for Figure 31.25(d)
		//	noise_ptr->set_gain(1.0);				// for Figure 31.25(e)
		//	noise_ptr->set_gain(2.0);				// for Figure 31.25(f) new image - not in book
			noise_ptr->set_lacunarity(2.0);		
	
			// texture:

			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 407:
		{
			//31.25d
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);		
		//	noise_ptr->set_gain(0.0);				// for Figure 31.25(a) cubic noise - identical to Figure 31.21(a)
		//	noise_ptr->set_gain(0.25);				// for Figure 31.25(b)
		//	noise_ptr->set_gain(0.5);				// for Figure 31.25(c) fractal sum - similar to Figure 31.21(d)
			noise_ptr->set_gain(0.75);				// for Figure 31.25(d)
		//	noise_ptr->set_gain(1.0);				// for Figure 31.25(e)
		//	noise_ptr->set_gain(2.0);				// for Figure 31.25(f) new image - not in book
			noise_ptr->set_lacunarity(2.0);		
	
			// texture:

			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 408:
		{
			//31.25e
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);		
		//	noise_ptr->set_gain(0.0);				// for Figure 31.25(a) cubic noise - identical to Figure 31.21(a)
		//	noise_ptr->set_gain(0.25);				// for Figure 31.25(b)
		//	noise_ptr->set_gain(0.5);				// for Figure 31.25(c) fractal sum - similar to Figure 31.21(d)
		//	noise_ptr->set_gain(0.75);				// for Figure 31.25(d)
			noise_ptr->set_gain(1.0);				// for Figure 31.25(e)
		//	noise_ptr->set_gain(2.0);				// for Figure 31.25(f) new image - not in book
			noise_ptr->set_lacunarity(2.0);		
	
			// texture:

			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 409:
		{
			//31.25f
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);		
		//	noise_ptr->set_gain(0.0);				// for Figure 31.25(a) cubic noise - identical to Figure 31.21(a)
		//	noise_ptr->set_gain(0.25);				// for Figure 31.25(b)
		//	noise_ptr->set_gain(0.5);				// for Figure 31.25(c) fractal sum - similar to Figure 31.21(d)
		//	noise_ptr->set_gain(0.75);				// for Figure 31.25(d)
		//	noise_ptr->set_gain(1.0);				// for Figure 31.25(e)
			noise_ptr->set_gain(2.0);				// for Figure 31.25(f) new image - not in book
			noise_ptr->set_lacunarity(2.0);		
	
			// texture:

			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 410:
		{
			//31.26a
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);		
			noise_ptr->set_gain(0.5);				
			noise_ptr->set_lacunarity(0.5);	   		// for Figure 31.26(a)
		//	noise_ptr->set_lacunarity(1.0);	   		// for Figure 31.26(b)
		//	noise_ptr->set_lacunarity(2.0);	   		// for Figure 31.26(c)  fractal sum - identical to Figure 31.25(c)
		//	noise_ptr->set_lacunarity(4.0);	   		// for Figure 31.26(d)
		//	noise_ptr->set_lacunarity(8.0);	   		// for Figure 31.26(e)	
	
			// texture:

			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 411:
		{
			//31.26b
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);		
			noise_ptr->set_gain(0.5);				
		//	noise_ptr->set_lacunarity(0.5);	   		// for Figure 31.26(a)
			noise_ptr->set_lacunarity(1.0);	   		// for Figure 31.26(b)
		//	noise_ptr->set_lacunarity(2.0);	   		// for Figure 31.26(c)  fractal sum - identical to Figure 31.25(c)
		//	noise_ptr->set_lacunarity(4.0);	   		// for Figure 31.26(d)
		//	noise_ptr->set_lacunarity(8.0);	   		// for Figure 31.26(e)	
	
			// texture:

			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 412:
		{
			//31.26c
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);		
			noise_ptr->set_gain(0.5);				
		//	noise_ptr->set_lacunarity(0.5);	   		// for Figure 31.26(a)
		//	noise_ptr->set_lacunarity(1.0);	   		// for Figure 31.26(b)
			noise_ptr->set_lacunarity(2.0);	   		// for Figure 31.26(c)  fractal sum - identical to Figure 31.25(c)
		//	noise_ptr->set_lacunarity(4.0);	   		// for Figure 31.26(d)
		//	noise_ptr->set_lacunarity(8.0);	   		// for Figure 31.26(e)	
	
			// texture:

			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 413:
		{
			//31.26d
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);		
			noise_ptr->set_gain(0.5);				
		//	noise_ptr->set_lacunarity(0.5);	   		// for Figure 31.26(a)
		//	noise_ptr->set_lacunarity(1.0);	   		// for Figure 31.26(b)
		//	noise_ptr->set_lacunarity(2.0);	   		// for Figure 31.26(c)  fractal sum - identical to Figure 31.25(c)
			noise_ptr->set_lacunarity(4.0);	   		// for Figure 31.26(d)
		//	noise_ptr->set_lacunarity(8.0);	   		// for Figure 31.26(e)	
	
			// texture:

			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 414:
		{
			//31.26e
			int num_samples = 1;
	
			vp.set_hres(600);    
			vp.set_vres(600);    
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0);	
			pinhole_ptr->set_view_distance(6000.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(0, 0, 1);		
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);		
			noise_ptr->set_gain(0.5);				
		//	noise_ptr->set_lacunarity(0.5);	   		// for Figure 31.26(a)
		//	noise_ptr->set_lacunarity(1.0);	   		// for Figure 31.26(b)
		//	noise_ptr->set_lacunarity(2.0);	   		// for Figure 31.26(c)  fractal sum - identical to Figure 31.25(c)
		//	noise_ptr->set_lacunarity(4.0);	   		// for Figure 31.26(d)
			noise_ptr->set_lacunarity(8.0);	   		// for Figure 31.26(e)	
	
			// texture:

			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);		
			texture_ptr->set_color(white);  
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);
	
	
			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			Plane* plane_ptr1 = new Plane(Point3D(0.0), Normal(0, 0, 1)); 
			plane_ptr1->set_material(sv_matte_ptr);
			add_object(plane_ptr1);
			break;
		}
	case 415:
		{
			//31.27a
			int num_samples = 16;
			vp.set_hres(600);    
			vp.set_vres(600);
			vp.set_samples(num_samples);
			vp.set_gamut_display(true);
	
			background_color = RGBColor(0.5);
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
	
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(4750.0); 	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(10, 10, 20);		
			light_ptr->scale_radiance(2.5);     
			add_light(light_ptr);
	
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;
			noise_ptr->set_num_octaves(1); 
			noise_ptr->set_gain(0.5);			// not relevant when num_octaves = 1
			noise_ptr->set_lacunarity(8.0);     // not relevant when num_octaves = 1
	
			// texture:		
	
			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);			
			texture_ptr->set_color(RGBColor(0.7, 1.0, 0.5));   // light green
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);

			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			// the sphere:
	
			Sphere* sphere_ptr = new Sphere(Point3D(0.0), 6.0); 
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 416:
		{
			//31.27b
			int num_samples = 16;
	
			vp.set_hres(600);    
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.5);
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
	
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(9500.0); 	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(10, 10, 20);		
			light_ptr->scale_radiance(3.5);     
			add_light(light_ptr);
	
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;
			noise_ptr->set_num_octaves(6); 
			noise_ptr->set_gain(0.5);
			noise_ptr->set_lacunarity(2.0);
	
			// texture:		
	
			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);			
			texture_ptr->set_color(RGBColor(0.5, 0.75, 1.0));   // light blue
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);

			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			// the sphere:
	
			Sphere* sphere_ptr = new Sphere(Point3D(0.0), 3.0); 
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 417:
		{
			//31.27c
			int num_samples = 16;
	
			vp.set_hres(600);    
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.5);
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
	
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(9500.0); 	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(10, 10, 20);		
			light_ptr->scale_radiance(2.5);     
			add_light(light_ptr);
	
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;
			noise_ptr->set_num_octaves(6); 
			noise_ptr->set_gain(0.5);
			noise_ptr->set_lacunarity(8.0);
	
			// texture:		
	
			FBmTexture* texture_ptr = new FBmTexture(noise_ptr);			
			texture_ptr->set_color(RGBColor(0.7, 1.0, 0.5));   // light green
			texture_ptr->set_min_value(0.0);  
			texture_ptr->set_max_value(1.0);

			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			// the sphere:
	
			Sphere* sphere_ptr = new Sphere(Point3D(0.0), 3.0); 
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 418:
		{
			//31.28a
			int num_samples = 16;
	
			vp.set_hres(600);    
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.5);
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
	
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(9500.0); 	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(10, 10, 20);		
			light_ptr->scale_radiance(2.5); 
			add_light(light_ptr);
	
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;
			noise_ptr->set_num_octaves(6); 
			noise_ptr->set_gain(0.5);
			noise_ptr->set_lacunarity(2.0);
	
			// texture:		
	
			TurbulenceTexture* texture_ptr = new TurbulenceTexture(noise_ptr);			
			texture_ptr->set_color(1.0, 0.7, 0.0);  	// orange 			
			texture_ptr->set_min_value(0.0);  			// for Figure 31.28(a)
			texture_ptr->set_max_value(1.2);
		//	texture_ptr->set_min_value(0.15);  			// for Figure 31.28(b)
		//	texture_ptr->set_max_value(0.75);

			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			// the sphere:
	
			Sphere* sphere_ptr = new Sphere(Point3D(0.0), 3.0); 
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 419:
		{
			//31.28b
			int num_samples = 16;
	
			vp.set_hres(600);    
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.5);
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
	
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(9500.0); 	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(10, 10, 20);		
			light_ptr->scale_radiance(2.5); 
			add_light(light_ptr);
	
	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;
			noise_ptr->set_num_octaves(6); 
			noise_ptr->set_gain(0.5);
			noise_ptr->set_lacunarity(2.0);
	
			// texture:		
	
			TurbulenceTexture* texture_ptr = new TurbulenceTexture(noise_ptr);			
			texture_ptr->set_color(1.0, 0.7, 0.0);  	// orange 			
		//	texture_ptr->set_min_value(0.0);  			// for Figure 31.28(a)
		//	texture_ptr->set_max_value(1.2);
			texture_ptr->set_min_value(0.15);  			// for Figure 31.28(b)
			texture_ptr->set_max_value(0.75);

			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
			// the sphere:
	
			Sphere* sphere_ptr = new Sphere(Point3D(0.0), 3.0); 
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 420:
		{
			//31.29a
			int num_samples = 16;
	
			vp.set_hres(600);     
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.5);
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(9500.0); 
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(5, 5, 20);		
			light_ptr->scale_radiance(6.0);
			add_light(light_ptr);

	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(2);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(4.0);		

	
			// texture:

			WrappedFBmTexture* texture_ptr = new WrappedFBmTexture(noise_ptr);	
			texture_ptr->set_color(0.3, 0.2, 0.1);   // brown
			texture_ptr->set_expansion_number(10.0);
			texture_ptr->set_min_value(0.0);
			texture_ptr->set_max_value(1.0);
	
			TInstance* scaled_texture_ptr = new TInstance(texture_ptr);
			scaled_texture_ptr->scale(1.0, 4.0, 4.0);


			// material:
		
			SV_Phong* sv_phong_ptr = new SV_Phong;		
			sv_phong_ptr->set_ka(0.5);  
			sv_phong_ptr->set_kd(0.85);
			sv_phong_ptr->set_cd(scaled_texture_ptr);
			sv_phong_ptr->set_ks(0.075);  
			sv_phong_ptr->set_exp(100.0);
			sv_phong_ptr->set_cs(new ConstantColor(white));

			Instance* sphere_ptr = new Instance(new Sphere(Point3D(0.0), 3.0)); 
			sphere_ptr->set_material(sv_phong_ptr);
			sphere_ptr->rotate_y(45);
			add_object(sphere_ptr);
			break;
		}
	case 421:
		{
			//31.29b
			int num_samples = 1;

			vp.set_hres(600);     
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.5);
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(9500.0);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(5, 5, 20);		
			light_ptr1->scale_radiance(3.0);
			add_light(light_ptr1);

	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(4);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);
	
			// texture:

			WrappedFBmTexture* texture_ptr = new WrappedFBmTexture(noise_ptr);	
			texture_ptr->set_color(1.0, 1.0, 0.0);   	// yellow
			texture_ptr->set_expansion_number(10.0);
			texture_ptr->set_min_value(0.0);
			texture_ptr->set_max_value(1.0);
	
			TInstance* scaled_texture_ptr = new TInstance(texture_ptr);
			scaled_texture_ptr->scale(1.5);
	
	
			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;	 
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(scaled_texture_ptr);
	
	
			Sphere* sphere_ptr = new Sphere(Point3D(0.0), 3.0); 
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 422:
		{
			//31.29c
			int num_samples = 16;

			vp.set_hres(600);    
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.5);
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(9500.0);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr1 = new PointLight;
			light_ptr1->set_location(5, 5, 20);		
			light_ptr1->scale_radiance(3.0);
			add_light(light_ptr1);

	
			// noise
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(6.0);		

	
			// texture: flowery fBm

			WrappedFBmTexture* texture_ptr = new WrappedFBmTexture(noise_ptr);	
			texture_ptr->set_color(0.7, 1.0, 0.5);   // light green
			texture_ptr->set_expansion_number(3.0);
			texture_ptr->set_min_value(0.0);
			texture_ptr->set_max_value(1.0);
	
	
			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(texture_ptr);
	
	
			Sphere* sphere_ptr = new Sphere(Point3D(0.0), 3.0); 
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 423:
		{
			//31.32a
			if( !CheckFile(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);     
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(5800.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(20, 20, 40);
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);

	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);		

			// ramp image:
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data());
	
			// marble texture:	
		
			RampFBmTexture* marble_ptr = new RampFBmTexture(image_ptr);
			marble_ptr->set_noise(noise_ptr);
			marble_ptr->set_perturbation(0.0);
	
			TInstance* transformed_marble_ptr = new TInstance(marble_ptr);
			transformed_marble_ptr->scale(0.2);
			transformed_marble_ptr->rotate_z(80);

			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;	 
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.9);
			sv_matte_ptr->set_cd(marble_ptr);

	
			Sphere* sphere_ptr = new Sphere(Point3D(0.0), 5.0); 
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 424:
		{
			//31.32b
			if( !CheckFile(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);     
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(5800.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(20, 20, 40);
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);

	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);		

			// ramp image:
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data());
	
			// marble texture:	
		
			RampFBmTexture* marble_ptr = new RampFBmTexture(image_ptr);
			marble_ptr->set_noise(noise_ptr);
			marble_ptr->set_perturbation(0.0);
	
			TInstance* transformed_marble_ptr = new TInstance(marble_ptr);
			transformed_marble_ptr->scale(0.2);
			transformed_marble_ptr->rotate_x(-60); 
			transformed_marble_ptr->rotate_y(-60);

			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;	 
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.9);
			sv_matte_ptr->set_cd(transformed_marble_ptr);

	
			Sphere* sphere_ptr = new Sphere(Point3D(0.0), 5.0); 
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 425:
		{
			//31.33a
			if( !CheckFile(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);     
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(5800.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(20, 20, 40);
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);

	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);		

			// ramp image:
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data());
	
			// marble texture:	
		
			RampFBmTexture* marble_ptr = new RampFBmTexture(image_ptr);
			marble_ptr->set_noise(noise_ptr);
			marble_ptr->set_perturbation(4.0);		// for Figure 31.33(a)
		//	marble_ptr->set_perturbation(8.0);		// for Figure 31.33(b)
		//	marble_ptr->set_perturbation(30.0);		// for Figure 31.33(c)

			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;	 
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.9);
			sv_matte_ptr->set_cd(marble_ptr);

	
			Instance* sphere_ptr1 = new Instance(new Sphere(Point3D(0.0), 5.0));
			sphere_ptr1->set_material(sv_matte_ptr);
			sphere_ptr1->rotate_y(180);
			add_object(sphere_ptr1);
			break;
		}
	case 426:
		{
			//31.33b
			if( !CheckFile(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);     
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(5800.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(20, 20, 40);
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);

	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);		

			// ramp image:
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data());
	
			// marble texture:	
		
			RampFBmTexture* marble_ptr = new RampFBmTexture(image_ptr);
			marble_ptr->set_noise(noise_ptr);
		//	marble_ptr->set_perturbation(4.0);		// for Figure 31.33(a)
			marble_ptr->set_perturbation(8.0);		// for Figure 31.33(b)
		//	marble_ptr->set_perturbation(30.0);		// for Figure 31.33(c)

			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;	 
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.9);
			sv_matte_ptr->set_cd(marble_ptr);

	
			Instance* sphere_ptr1 = new Instance(new Sphere(Point3D(0.0), 5.0));
			sphere_ptr1->set_material(sv_matte_ptr);
			sphere_ptr1->rotate_y(180);
			add_object(sphere_ptr1);
			break;
		}
	case 427:
		{
			//31.33c
			if( !CheckFile(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);     
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(5800.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(20, 20, 40);
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);

	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);		

			// ramp image:
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data());
	
			// marble texture:	
		
			RampFBmTexture* marble_ptr = new RampFBmTexture(image_ptr);
			marble_ptr->set_noise(noise_ptr);
		//	marble_ptr->set_perturbation(4.0);		// for Figure 31.33(a)
		//	marble_ptr->set_perturbation(8.0);		// for Figure 31.33(b)
			marble_ptr->set_perturbation(30.0);		// for Figure 31.33(c)

			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;	 
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.9);
			sv_matte_ptr->set_cd(marble_ptr);

	
			Instance* sphere_ptr1 = new Instance(new Sphere(Point3D(0.0), 5.0));
			sphere_ptr1->set_material(sv_matte_ptr);
			sphere_ptr1->rotate_y(180);
			add_object(sphere_ptr1);
			break;
		}
	case 428:
		{
			//31.34a
			if( !CheckFile(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);     
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(5800.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(20, 20, 40);
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);

	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);		

			// ramp image:
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data());
	
			// marble texture:	
		
			RampFBmTexture* marble_ptr = new RampFBmTexture(image_ptr);
			marble_ptr->set_noise(noise_ptr);
			marble_ptr->set_perturbation(8.0);
	
			TInstance* transformed_marble_ptr = new TInstance(marble_ptr);
			transformed_marble_ptr->scale(0.3);

			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;	 
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.9);
			sv_matte_ptr->set_cd(transformed_marble_ptr);
	
	
			Instance* sphere_ptr1 = new Instance(new Sphere(Point3D(0.0), 5.0));
			sphere_ptr1->set_material(sv_matte_ptr);
			sphere_ptr1->rotate_y(180);
			add_object(sphere_ptr1);
			break;
		}
	case 429:
		{
			//31.34b
			if( !CheckFile(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);     
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(5800.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(20, 20, 40);
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);

	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);		

			// ramp image:
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data());
	
			// marble texture:	
		
			RampFBmTexture* marble_ptr = new RampFBmTexture(image_ptr);
			marble_ptr->set_noise(noise_ptr);
			marble_ptr->set_perturbation(6.0);
	
			TInstance* transformed_marble_ptr = new TInstance(marble_ptr);
			transformed_marble_ptr->scale(3.0);
			transformed_marble_ptr->rotate_y(90);
			transformed_marble_ptr->rotate_x(45);

			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;	 
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(transformed_marble_ptr);
	

			Instance* sphere_ptr1 = new Instance(new Sphere(Point3D(0.0), 5.0));
			sphere_ptr1->set_material(sv_matte_ptr);
			sphere_ptr1->rotate_y(180);
			add_object(sphere_ptr1);

			break;
		}
	case 430:
		{
			//31.34c
			if( !CheckFile(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);     
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(20000.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(20, 20, 40);
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);

	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);		

			// ramp image:
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data());
	
			// marble texture:	
		
			RampFBmTexture* marble_ptr = new RampFBmTexture(image_ptr);
			marble_ptr->set_noise(noise_ptr);
			marble_ptr->set_perturbation(40.0);
	
			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;	 
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(marble_ptr);

	
			Instance* sphere_ptr1 = new Instance(new Sphere(Point3D(0.0), 5.0));
			sphere_ptr1->set_material(sv_matte_ptr);
			sphere_ptr1->rotate_y(180);
			add_object(sphere_ptr1);

			break;
		}
	case 431:
		{
			//31.34d
			if( !CheckFile(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);     
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(10000.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(20, 20, 40);
			light_ptr->scale_radiance(2.5);
			add_light(light_ptr);

	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(2.0);		

			// ramp image:
	
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"BlueMarbleRamp.ppm").toLatin1().data());
	
			// marble texture:	
		
			RampFBmTexture* marble_ptr = new RampFBmTexture(image_ptr);
			marble_ptr->set_noise(noise_ptr);
			marble_ptr->set_perturbation(8.0);
	
			TInstance* transformed_marble_ptr = new TInstance(marble_ptr);
			transformed_marble_ptr->scale(2.0, 0.2, 2.0);
			transformed_marble_ptr->rotate_y(45);

			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;	 
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.9);
			sv_matte_ptr->set_cd(transformed_marble_ptr);
	
	
			Instance* sphere_ptr1 = new Instance(new Sphere(Point3D(0.0), 5.0));
			sphere_ptr1->set_material(sv_matte_ptr);
			sphere_ptr1->rotate_y(180);
			add_object(sphere_ptr1);

			break;
		}
	case 432:
		{
			//31.38
			if( !CheckFile(QString(ppmfile+"sandstone_ramp1.ppm").toLatin1().data()))
				return;
			if( !CheckFile(QString(ppmfile+"sandstone_ramp2.ppm").toLatin1().data()))
				return;
			if( !CheckFile(QString(ppmfile+"sandstone_ramp3.ppm").toLatin1().data()))
				return;
			if( !CheckFile(QString(ppmfile+"sandstone_ramp4.ppm").toLatin1().data()))
				return;
			int num_samples = 16;
	
			vp.set_hres(800);
			vp.set_vres(400);
			vp.set_samples(num_samples);
	
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);
			set_ambient_light(ambient_ptr);
	
			background_color = black;
			tracer_ptr = new RayCast(this);
	
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 25, 50);
			pinhole_ptr->set_lookat(0.0); 
			pinhole_ptr->set_view_distance(5320.0); 
			pinhole_ptr->compute_uvw();
			set_camera(pinhole_ptr);
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(30, 40, 35); 
			light_ptr->scale_radiance(5.0);
			add_light(light_ptr);
	
	
			// noise parameters
			// gain = 0.5, lacunarity = 2.0 by default
	
			int 	num_octaves = 4;			
			float 	fbm_amount 	= 0.05; 
	

			// cylinder parameters
	
			double bottom 	= -1.75; 
			double top 		= 1.75; 
			double radius 	= 0.9;
	
	
			// far left cylinder:
	
			Image* image_ptr1 = new Image;						
			image_ptr1->read_ppm_file(QString(ppmfile+"sandstone_ramp1.ppm").toLatin1().data());
	
			TInstance* sandstone_ptr1 = new TInstance(new RampFBmTexture(image_ptr1, num_octaves, fbm_amount));
			sandstone_ptr1->scale(1.0, 2.0, 1.0);
			sandstone_ptr1->rotate_z(110.0);
			sandstone_ptr1->translate(1.0, 4.0, 0.0);
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.35);
			sv_matte_ptr1->set_kd(0.75);
			sv_matte_ptr1->set_cd(sandstone_ptr1);
	
			Instance* cylinder_ptr1 = new Instance(new SolidCylinder(bottom, top, radius)); 
			cylinder_ptr1->set_material(sv_matte_ptr1);
			cylinder_ptr1->rotate_y(-30);
			cylinder_ptr1->translate(-3.0, 0.0, 0.0);
			add_object(cylinder_ptr1);
	
	
			// left middle cylinder:
	
			Image* image_ptr2 = new Image;						
			image_ptr2->read_ppm_file(QString(ppmfile+"sandstone_ramp2.ppm").toLatin1().data());
	
			TInstance* sandstone_ptr2 = new TInstance(new RampFBmTexture(image_ptr2, num_octaves, fbm_amount));
			sandstone_ptr2->scale(1.0, 2.0, 1.0);
			sandstone_ptr2->rotate_z(110.0);
			sandstone_ptr2->translate(0.5, 0.0, 0.0);
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.35);
			sv_matte_ptr2->set_kd(0.75);
			sv_matte_ptr2->set_cd(sandstone_ptr2);
	
			Instance* cylinder_ptr2 = new Instance(new SolidCylinder(bottom, top, radius)); 
			cylinder_ptr2->set_material(sv_matte_ptr2);
			cylinder_ptr2->rotate_y(-30);
			cylinder_ptr2->translate(-1.0, 0.0, 0.0);
			add_object(cylinder_ptr2);
	
	
			// right middle cylinder:
	
			Image* image_ptr3 = new Image;						
			image_ptr3->read_ppm_file(QString(ppmfile+"sandstone_ramp3.ppm").toLatin1().data());
	
			TInstance* sandstone_ptr3 = new TInstance(new RampFBmTexture(image_ptr3, num_octaves, fbm_amount));
			sandstone_ptr3->scale(1.0, 2.0, 1.0);
			sandstone_ptr3->rotate_z(110.0);
			sandstone_ptr3->translate(0.5, -2.0, 0.0);
	
	
			SV_Matte* sv_matte_ptr3 = new SV_Matte;		
			sv_matte_ptr3->set_ka(0.35);
			sv_matte_ptr3->set_kd(0.75);
			sv_matte_ptr3->set_cd(sandstone_ptr3);
	
			Instance* cylinder_ptr3 = new Instance(new SolidCylinder(bottom, top, radius)); 
			cylinder_ptr3->set_material(sv_matte_ptr3);
			cylinder_ptr3->rotate_y(-30);
			cylinder_ptr3->translate(1.0, 0.0, 0.0);
			add_object(cylinder_ptr3);
	
	
			// far right cylinder:
	
			Image* image_ptr4 = new Image;						
			image_ptr4->read_ppm_file(QString(ppmfile+"sandstone_ramp4.ppm").toLatin1().data());
	
			TInstance* sandstone_ptr4 = new TInstance(new RampFBmTexture(image_ptr4, num_octaves, fbm_amount));
			sandstone_ptr4->scale(1.0, 2.0, 1.0);
			sandstone_ptr4->rotate_z(110.0);
			sandstone_ptr4->translate(0.0, -1.0, 0.0);
	
	
			SV_Matte* sv_matte_ptr4 = new SV_Matte;		
			sv_matte_ptr4->set_ka(0.35);
			sv_matte_ptr4->set_kd(0.75);
			sv_matte_ptr4->set_cd(sandstone_ptr4);
	
			Instance* cylinder_ptr4 = new Instance(new SolidCylinder(bottom, top, radius)); 
			cylinder_ptr4->set_material(sv_matte_ptr4);
			cylinder_ptr4->rotate_y(-30);
			cylinder_ptr4->translate(3.0, 0.0, 0.0);
			add_object(cylinder_ptr4);
			break;
		}
	case 433:
		{
			//31.39a
			int num_samples = 16;
	
			vp.set_hres(600);     
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.5);
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(9600.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(20, 20, 40);
			light_ptr->scale_radiance(3.0);
			add_light(light_ptr);

	
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(4.0);		


			WrappedTwoColors* texture_ptr = new WrappedTwoColors(noise_ptr);	
			texture_ptr->set_color1(RGBColor(1.0, 0.8, 0.0));		// gold
			texture_ptr->set_color2(RGBColor(0.5, 0.75, 1.0));  	// light blue  
			texture_ptr->set_expansion_number(2.0);	


			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;	 
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.9);
			sv_matte_ptr->set_cd(texture_ptr);
	
	
			Sphere* sphere_ptr = new Sphere(Point3D(0.0), 3.0);
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 434:
		{
			//31.39b
			int num_samples = 1;
	
			vp.set_hres(600);     
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.5);
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(9600.0);
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(20, 20, 40);
			light_ptr->scale_radiance(3.0);
			add_light(light_ptr);
				
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;	
			noise_ptr->set_num_octaves(6);
			noise_ptr->set_gain(0.5);	
			noise_ptr->set_lacunarity(4.0);		

			// texture:
			WrappedThreeColors* texture_ptr = new WrappedThreeColors(noise_ptr);	
			texture_ptr->set_color1(RGBColor(1.0, 0.8, 0.0));		// gold
			texture_ptr->set_color2(RGBColor(0.7, 1.0, 0.5));		// light green
			texture_ptr->set_color3(RGBColor(0.5, 0.75, 1.0));  	// light blue  
			texture_ptr->set_expansion_number(3.25);

			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;	 
			sv_matte_ptr->set_ka(0.25);
			sv_matte_ptr->set_kd(0.9);
			sv_matte_ptr->set_cd(texture_ptr);
	
	
			Sphere* sphere_ptr = new Sphere(Point3D(0.0), 3.0);
			sphere_ptr->set_material(sv_matte_ptr);
			add_object(sphere_ptr);
			break;
		}
	case 435:
		{
			//31.40
			int num_samples = 16;
	
			vp.set_hres(600);    
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			background_color = RGBColor(0.5);
			tracer_ptr = new RayCast(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 0, 100);
			pinhole_ptr->set_lookat(0.0);
			pinhole_ptr->set_view_distance(9500);  
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			PointLight* light_ptr2 = new PointLight;
			light_ptr2->set_location(5, 5, 20);		
			light_ptr2->scale_radiance(3.0);
			add_light(light_ptr2);
	
	
			// noise 1:
	
			CubicNoise* noise_ptr1 = new CubicNoise;	
			noise_ptr1->set_num_octaves(6);
			noise_ptr1->set_gain(0.5);	
			noise_ptr1->set_lacunarity(4.0);		
	
			WrappedTwoColors* texture_ptr = new WrappedTwoColors(noise_ptr1);	
			texture_ptr->set_color1(1.0, 0.8, 0.0);		// gold
			texture_ptr->set_color2(0.5, 0.75, 1.0);  	// light blue  
			texture_ptr->set_expansion_number(2.0);	
	
			TInstance* transformed_wrapped_ptr = new TInstance(texture_ptr);
			transformed_wrapped_ptr->scale(0.25);


			// noise 2:
	
			CubicNoise* noise_ptr2 = new CubicNoise;	
			noise_ptr2->set_num_octaves(3);
			noise_ptr2->set_gain(0.5);	
			noise_ptr2->set_lacunarity(5.0);
	
			// nested noises texture:	

			NestedNoisesTexture* nested_textures_ptr = new NestedNoisesTexture(noise_ptr2);	
			nested_textures_ptr->set_color(0.25, 1.0, 0.1);   // bright green		
			nested_textures_ptr->set_texture(transformed_wrapped_ptr);
			nested_textures_ptr->set_min_value(0.0);  
			nested_textures_ptr->set_max_value(1.0);
			nested_textures_ptr->set_wrap_factor(3.0);    

			// material:
	
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.35);
			sv_matte_ptr->set_kd(1.0);
			sv_matte_ptr->set_cd(nested_textures_ptr);

	
			Sphere* sphere_ptr1 = new Sphere(Point3D(0.0), 3); 
			sphere_ptr1->set_material(sv_matte_ptr);
			add_object(sphere_ptr1);
			break;
		}
	case 436:
		{
			//31.41a
			if( !CheckFile(QString(ppmfile+"sandstone_ramp1.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = black;
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);    
			set_ambient_light(ambient_ptr);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(6, 8, 12);         
			pinhole_ptr->set_lookat(0.0, -0.1, 0.0); 
			pinhole_ptr->set_view_distance(2850.0);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(-2, 4, 10);  
			light_ptr->scale_radiance(4.5);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
		
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;
			noise_ptr->set_num_octaves(1);
			noise_ptr->set_gain(0.5);
			noise_ptr->set_lacunarity(2.0);	
	
			// image:
		
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"sandstone_ramp1.ppm").toLatin1().data());
	
			// sandstone texture:
	
			RampFBmTexture* sandstone_ptr = new RampFBmTexture(image_ptr);
			sandstone_ptr->set_noise(noise_ptr);
			sandstone_ptr->set_perturbation(0.1);
	
			TInstance* transformed_sandstone_ptr = new TInstance(sandstone_ptr);
			transformed_sandstone_ptr->scale(0.5);
			transformed_sandstone_ptr->rotate_z(90);
			transformed_sandstone_ptr->rotate_y(45);
			transformed_sandstone_ptr->translate(0.0, 0.0, 0.5);  
	
		
			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(transformed_sandstone_ptr);
	
	
			// cut cube parameters:
	
			Point3D p0(-1.0);
			Point3D p1(1.0);
			double sphere_radius = 1.5;
	
			CutCube* cut_cube_ptr = new CutCube(p0, p1, sphere_radius); 
			cut_cube_ptr->set_material(sv_matte_ptr);
			add_object(cut_cube_ptr);
	
	
			// concave part sphere parameters
	
			Point3D center(p1);
			double radius 		= sphere_radius;
			double phi_min 		= 180.0;
			double phi_max 		= 270.0;
			double theta_min	= 90.0;
			double theta_max 	= 180.0;
	
			ConcavePartSphere* part_sphere_ptr = new ConcavePartSphere(	center, 
																		radius, 
																		phi_min, 
																		phi_max, 
																		theta_min, 
																		theta_max);
			part_sphere_ptr->set_material(sv_matte_ptr);
			add_object(part_sphere_ptr);
			break;
		}
	case 437:
		{
			//31.41b
			if( !CheckFile(QString(ppmfile+"sandstone_ramp1.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = black;
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);    
			set_ambient_light(ambient_ptr);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(6, 8, 12);         
			pinhole_ptr->set_lookat(0.0, -0.1, 0.0); 
			pinhole_ptr->set_view_distance(2850.0);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(-2, 4, 10);  
			light_ptr->scale_radiance(4.5);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
		
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;
			noise_ptr->set_num_octaves(6);
			noise_ptr->set_gain(0.5);
			noise_ptr->set_lacunarity(2.0);	
	
			// image:
		
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"sandstone_ramp1.ppm").toLatin1().data());
	
			// sandstone texture:
	
			RampFBmTexture* sandstone_ptr = new RampFBmTexture(image_ptr);
			sandstone_ptr->set_noise(noise_ptr);
			sandstone_ptr->set_perturbation(6.0);
	
			TInstance* transformed_sandstone_ptr = new TInstance(sandstone_ptr);
			transformed_sandstone_ptr->rotate_z(90);
			transformed_sandstone_ptr->rotate_y(45);
			transformed_sandstone_ptr->translate(-6.0, 0.0, 1.0);
	
		
			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(transformed_sandstone_ptr);
	
	
	
			// cut cube parameters:
	
			Point3D p0(-1.0);
			Point3D p1(1.0);
			double sphere_radius = 1.5;
	
			CutCube* cut_cube_ptr = new CutCube(p0, p1, sphere_radius); 
			cut_cube_ptr->set_material(sv_matte_ptr);
			add_object(cut_cube_ptr);
	
	
			// concave part sphere parameters:
	
			Point3D center(p1);
			double radius 		= sphere_radius;
			double phi_min 		= 180.0;
			double phi_max 		= 270.0;
			double theta_min	= 90.0;
			double theta_max 	= 180.0;
	
			ConcavePartSphere* part_sphere_ptr = new ConcavePartSphere(	center, 
																		radius, 
																		phi_min, 
																		phi_max, 
																		theta_min, 
																		theta_max);
			part_sphere_ptr->set_material(sv_matte_ptr);
			add_object(part_sphere_ptr);
			break;
		}
	case 438:
		{
			//31.41c
			if( !CheckFile(QString(ppmfile+"turquoise_ramp.ppm").toLatin1().data()))
				return;

			int num_samples = 16;
	
			vp.set_hres(600);
			vp.set_vres(600);
			vp.set_samples(num_samples);
	
			tracer_ptr = new RayCast(this);
			background_color = black;
			
			Ambient* ambient_ptr = new Ambient;
			ambient_ptr->scale_radiance(0.5);    
			set_ambient_light(ambient_ptr);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(6, 8, 12);         
			pinhole_ptr->set_lookat(0.0, -0.1, 0.0); 
			pinhole_ptr->set_view_distance(2850.0);  
			pinhole_ptr->compute_uvw(); 
			set_camera(pinhole_ptr);
		
			PointLight* light_ptr = new PointLight;
			light_ptr->set_location(-2, 4, 10);  
			light_ptr->scale_radiance(4.5);   
			light_ptr->set_shadows(false);
			add_light(light_ptr);
	
		
			// noise:
	
			CubicNoise* noise_ptr = new CubicNoise;
			noise_ptr->set_num_octaves(6);
			noise_ptr->set_gain(0.5);
			noise_ptr->set_lacunarity(2.0);	
	
			// image:
		
			Image* image_ptr = new Image;						
			image_ptr->read_ppm_file(QString(ppmfile+"turquoise_ramp.ppm").toLatin1().data());
	
			// sandstone texture:
	
			RampFBmTexture* sandstone_ptr = new RampFBmTexture(image_ptr);
			sandstone_ptr->set_noise(noise_ptr);
			sandstone_ptr->set_perturbation(6.0);
	
			TInstance* transformed_sandstone_ptr = new TInstance(sandstone_ptr);
			transformed_sandstone_ptr->rotate_z(90);
			transformed_sandstone_ptr->rotate_y(45);
			transformed_sandstone_ptr->translate(-6.0, 0.0, 1.0);
		
			// material:
		
			SV_Matte* sv_matte_ptr = new SV_Matte;		
			sv_matte_ptr->set_ka(0.5);
			sv_matte_ptr->set_kd(0.85);
			sv_matte_ptr->set_cd(transformed_sandstone_ptr);
	
	
	
			// cut cube parameters:
	
			Point3D p0(-1.0);
			Point3D p1(1.0);
			double sphere_radius = 1.5;
	
			CutCube* cut_cube_ptr = new CutCube(p0, p1, sphere_radius); 
			cut_cube_ptr->set_material(sv_matte_ptr);
			add_object(cut_cube_ptr);
	
	
			// concave part sphere parameters
	
			Point3D center(p1);
			double radius 		= sphere_radius;
			double phi_min 		= 180.0;
			double phi_max 		= 270.0;
			double theta_min	= 90.0;
			double theta_max 	= 180.0;
	
			ConcavePartSphere* part_sphere_ptr = new ConcavePartSphere(	center, 
																		radius, 
																		phi_min, 
																		phi_max, 
																		theta_min, 
																		theta_max);
			part_sphere_ptr->set_material(sv_matte_ptr);
			add_object(part_sphere_ptr);
			break;
		}
	case 439:
		{
			//31.42
			if( !CheckFile(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data()))
				return;
			if( !CheckFile(QString(ppmfile+"TurquoiseAndBrownRamp.ppm").toLatin1().data()))
				return;
			if( !CheckFile(QString(ppmfile+"BlueAndBuffRamp.ppm").toLatin1().data()))
				return;
			if( !CheckFile(QString(ppmfile+"BrownRamp.ppm").toLatin1().data()))
				return;


			int num_samples = 16;

			vp.set_hres(800);     
			vp.set_vres(400);    	
			vp.set_max_depth(1);
			vp.set_samples(num_samples);
	
			background_color = black;
			tracer_ptr = new Whitted(this);
	
			Pinhole* pinhole_ptr = new Pinhole;
			pinhole_ptr->set_eye(0, 30, 100);
			pinhole_ptr->set_lookat(-0.01, 0.09, 0);
			pinhole_ptr->set_view_distance(173333.0); 	
			pinhole_ptr->compute_uvw();     
			set_camera(pinhole_ptr); 
	
	
			Directional* light_ptr = new Directional;
			light_ptr->set_direction(1, 1, 4);		
			light_ptr->scale_radiance(3.0);
			add_light(light_ptr);
	
	
			const char* file_name = "Bunny16K.ply"; 
	
			Grid* grid_ptr = new Grid(new Mesh);
			grid_ptr->read_smooth_triangles(QString(plyfile+"Stanford Bunny\\Bunny16K.ply").toLatin1().data());
			grid_ptr->setup_cells();
	
	
			// center bunny:
	
			Image* image_ptr1 = new Image;						
			image_ptr1->read_ppm_file(QString(ppmfile+"TurquoiseAndBrownRamp.ppm").toLatin1().data());
	
	
			// noise:
	
			CubicNoise* noise_ptr1 = new CubicNoise;	
			noise_ptr1->set_num_octaves(4);
			noise_ptr1->set_gain(0.5);	
			noise_ptr1->set_lacunarity(2.0);	


			// texture:
		
			WrappedRamp* wrapped_ptr1 = new WrappedRamp(image_ptr1);
			wrapped_ptr1->set_noise(noise_ptr1);
			wrapped_ptr1->set_perturbation(6.0);
			wrapped_ptr1->set_wrap_number(8.0);
	
			TInstance* texture_ptr1 = new TInstance(wrapped_ptr1);
			texture_ptr1->scale(0.1);
	

			// material:
	
			SV_Matte* sv_matte_ptr1 = new SV_Matte;		
			sv_matte_ptr1->set_ka(0.15);
			sv_matte_ptr1->set_kd(0.85);
			sv_matte_ptr1->set_cd(texture_ptr1);
	
	
			Instance* bunny_ptr1 = new Instance(grid_ptr);
			bunny_ptr1->set_material(sv_matte_ptr1);
			bunny_ptr1->rotate_y(25);
			add_object(bunny_ptr1);	
			// left bunny 
	
			Image* image_ptr2 = new Image;						
			image_ptr2->read_ppm_file(QString(ppmfile+"BlueAndBuffRamp.ppm").toLatin1().data());
	
	
			// noise:
	
			CubicNoise* noise_ptr2 = new CubicNoise;	
			noise_ptr2->set_num_octaves(4);
			noise_ptr2->set_gain(0.5);	
			noise_ptr2->set_lacunarity(3.0);	

	
			// texture:
	
			WrappedRamp* wrapped_ptr2 = new WrappedRamp(image_ptr2);
			wrapped_ptr2->set_noise(noise_ptr2);
			wrapped_ptr2->set_perturbation(6.0);
			wrapped_ptr2->set_wrap_number(8.0);
	
			TInstance* texture_ptr2 = new TInstance(wrapped_ptr2);
			texture_ptr2->scale(0.075);


			// material:
	
			SV_Matte* sv_matte_ptr2 = new SV_Matte;		
			sv_matte_ptr2->set_ka(0.15);
			sv_matte_ptr2->set_kd(0.85);
			sv_matte_ptr2->set_cd(texture_ptr2);
	
	
			Instance* bunny_ptr2 = new Instance(grid_ptr);
			bunny_ptr2->set_material(sv_matte_ptr2);
			bunny_ptr2->rotate_y(25);
			bunny_ptr2->translate(-0.15, 0.0, 0.0);
			add_object(bunny_ptr2);	
	
	
			// right bunny:
	
			Image* image_ptr3 = new Image;						
			image_ptr3->read_ppm_file(QString(ppmfile+"BrownRamp.ppm").toLatin1().data());
	
	
			// noise:
	
			CubicNoise* noise_ptr3 = new CubicNoise;	
			noise_ptr3->set_num_octaves(4);
			noise_ptr3->set_gain(0.5);	
			noise_ptr3->set_lacunarity(5.0);

	
			// texture:
	
			WrappedRamp* wrapped_ptr3 = new WrappedRamp(image_ptr3);
			wrapped_ptr3->set_noise(noise_ptr3);
			wrapped_ptr3->set_perturbation(6.0);
			wrapped_ptr3->set_wrap_number(8.0);
	
			TInstance* texture_ptr3 = new TInstance(wrapped_ptr3);
			texture_ptr3->scale(0.3);


			// material:
	
			SV_Matte* sv_matte_ptr3 = new SV_Matte;		
			sv_matte_ptr3->set_ka(0.15);
			sv_matte_ptr3->set_kd(0.85);
			sv_matte_ptr3->set_cd(texture_ptr3);
	
	
			Instance* bunny_ptr3 = new Instance(grid_ptr);
			bunny_ptr3->set_material(sv_matte_ptr3);
			bunny_ptr3->rotate_y(25);
			bunny_ptr3->translate(0.15, 0.0, 0.0);
			add_object(bunny_ptr3);	
	

			// reflective ground plane
	
			Reflective*	reflective_ptr = new Reflective;			
			reflective_ptr->set_ka(0.2); 
			reflective_ptr->set_kd(0.75);
			reflective_ptr->set_cd(black);
			reflective_ptr->set_ks(0.0);
			reflective_ptr->set_exp(20);
			reflective_ptr->set_kr(0.5);  
			reflective_ptr->set_cr(0.8, 1.0, 0.8);    
		
			Plane* plane_ptr = new Plane(Point3D(0, 0.033, 0), Normal(0, 1, 0));	
			plane_ptr->set_material(reflective_ptr);
			add_object(plane_ptr);
			break;
		}
	default:
		break;
	}
	return;
}
